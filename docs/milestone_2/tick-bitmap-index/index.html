<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); }    \[ \]  Tick Bitmap Index #  As the first step towards dynamic swaps, we need to implement an index of ticks."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="Tick Bitmap Index"><meta property="og:description" content="function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); }    \[ \]  Tick Bitmap Index #  As the first step towards dynamic swaps, we need to implement an index of ticks."><meta property="og:type" content="article"><meta property="og:url" content="https://uniswapv3book.com/docs/milestone_2/tick-bitmap-index/"><meta property="article:section" content="docs"><title>Tick Bitmap Index | Uniswap V3 Book 中文版</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.82c5dbd23447cee0b4c2aa3ed08ce0961faa40e1fa370eee4f8c9f02e0d46b5f.css integrity="sha256-gsXb0jRHzuC0wqo+0Izglh+qQOH6Nw7uT4yfAuDUa18=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.d6b0217789cab12411fda11381b98a7b8564b6410ec290ed237c4738da0a1f38.js integrity="sha256-1rAhd4nKsSQR/aETgbmKe4VktkEOwpDtI3xHONoKHzg=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Uniswap V3 Book 中文版</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>Milestone 0. 简介</span><ul><li><a href=/docs/introduction/introduction-to-markets/>交易市场简介</a></li><li><a href=/docs/introduction/constant-function-market-maker/>恒定函数做市商(CFMM)</a></li><li><a href=/docs/introduction/uniswap-v3/>Uniswap V3</a></li><li><a href=/docs/introduction/dev-environment/>开发环境</a></li></ul></li><li class=book-section-flat><span>Milestone 1. First Swap</span><ul><li><a href=/docs/milestone_1/introduction/>Introduction</a></li><li><a href=/docs/milestone_1/calculating-liquidity/>Calculating Liquidity</a></li><li><a href=/docs/milestone_1/providing-liquidity/>Providing Liquidity</a></li><li><a href=/docs/milestone_1/first-swap/>First Swap</a></li><li><a href=/docs/milestone_1/manager-contract/>Manager Contract</a></li><li><a href=/docs/milestone_1/deployment/>Deployment</a></li><li><a href=/docs/milestone_1/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 2. Second Swap</span><ul><li><a href=/docs/milestone_2/introduction/>Introduction</a></li><li><a href=/docs/milestone_2/output-amount-calculation/>Output Amount Calculation</a></li><li><a href=/docs/milestone_2/math-in-solidity/>Math in Solidity</a></li><li><a href=/docs/milestone_2/tick-bitmap-index/ class=active>Tick Bitmap Index</a></li><li><a href=/docs/milestone_2/generalize-minting/>Generalize Minting</a></li><li><a href=/docs/milestone_2/generalize-swapping/>Generalize Swapping</a></li><li><a href=/docs/milestone_2/quoter-contract/>Quoter Contract</a></li><li><a href=/docs/milestone_2/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 3. Cross-tick Swaps</span><ul><li><a href=/docs/milestone_3/introduction/>Introduction</a></li><li><a href=/docs/milestone_3/different-ranges/>Different Price Ranges</a></li><li><a href=/docs/milestone_3/cross-tick-swaps/>Cross-Tick Swaps</a></li><li><a href=/docs/milestone_3/slippage-protection/>Slippage Protection</a></li><li><a href=/docs/milestone_3/liquidity-calculation/>Liquidity Calculation</a></li><li><a href=/docs/milestone_3/more-on-fixed-point-numbers/>A Little Bit More on Fixed-point Numbers</a></li><li><a href=/docs/milestone_3/flash-loans/>Flash Loans</a></li><li><a href=/docs/milestone_3/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 4. Multi-pool Swaps</span><ul><li><a href=/docs/milestone_4/introduction/>Introduction</a></li><li><a href=/docs/milestone_4/factory-contract/>Factory Contract</a></li><li><a href=/docs/milestone_4/path/>Swap Path</a></li><li><a href=/docs/milestone_4/multi-pool-swaps/>Multi-pool Swaps</a></li><li><a href=/docs/milestone_4/user-interface/>User Interface</a></li><li><a href=/docs/milestone_4/tick-rounding/>Tick Rounding</a></li></ul></li><li class=book-section-flat><span>Milestone 5. Fees and Price Oracle</span><ul><li><a href=/docs/milestone_5/introduction/>Introduction</a></li><li><a href=/docs/milestone_5/swap-fees/>Swap Fees</a></li><li><a href=/docs/milestone_5/flash-loan-fees/>Flash Loan Fees</a></li><li><a href=/docs/milestone_5/protocol-fees/>Protocol Fees</a></li><li><a href=/docs/milestone_5/price-oracle/>Price Oracle</a></li><li><a href=/docs/milestone_5/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 6: NFT positions</span><ul><li><a href=/docs/milestone_6/introduction/>Introduction</a></li><li><a href=/docs/milestone_6/erc721-overview/>ERC721 Overview</a></li><li><a href=/docs/milestone_6/nft-manager/>NFT Manager</a></li><li><a href=/docs/milestone_6/nft-renderer/>NFT Renderer</a></li></ul></li><li class=book-section-flat><span>补充资料</span><ul><li><a href=/docs/reference/dictionary/>中英名词对照</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Tick Bitmap Index</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#tick-bitmap-index>Tick Bitmap Index</a><ul><li><a href=#bitmap>Bitmap</a></li><li><a href=#tickbitmap-contract>TickBitmap Contract</a><ul><li><a href=#flipping-flags>Flipping Flags</a></li><li><a href=#finding-next-tick>Finding Next Tick</a></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><link rel=stylesheet href=/katex/katex.min.css><script>function renderKatex(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})}</script><script defer src=/katex/katex.min.js></script>
<script defer src=/katex/auto-render.min.js onload=renderKatex(document.body)></script><span>
\[ \]</span><h1 id=tick-bitmap-index>Tick Bitmap Index
<a class=anchor href=#tick-bitmap-index>#</a></h1><p>As the first step towards dynamic swaps, we need to implement an index of ticks. In the previous milestone, we used to
calculate the target tick when making a swap:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>swap</span>(<span style=color:#66d9ef>address</span> recipient, <span style=color:#66d9ef>bytes</span> calldata data)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>returns</span> (<span style=color:#66d9ef>int256</span> amount0, <span style=color:#66d9ef>int256</span> amount1)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int24</span> nextTick <span style=color:#f92672>=</span> <span style=color:#ae81ff>85184</span>;
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>When there&rsquo;s liquidity provided in different price ranges, we cannot simply calculate the target tick. We need to <strong>find
it</strong> depending on the amount of liquidity in different price ranges. Thus, we need to index all ticks that have liquidity
and then use the index to find ticks to &ldquo;fill&rdquo; enough liquidity for a swap. In this step, we&rsquo;re going to implement such
index.</p><h2 id=bitmap>Bitmap
<a class=anchor href=#bitmap>#</a></h2><p>Bitmap is a popular technique of indexing data in a compact way. A bitmap is simply an array of zeros and ones, where
each element as and index and corresponds to some external entity (something that&rsquo;s indexed). Each element can be a zero
or a one, which can be seemed as setting a flag: when 0, flag is not set; when 1, flag is set. What makes this approach
favorable is that the whole array can be stored as a single number in the binary number system!</p><p>For example, the array <code>111101001101001</code> is number 31337. The number takes two bytes (0x7a69) and two bytes can store 16
flags (1 byte = 8 bits).</p><p>Uniswap V3 uses this technique to store the information about initialized ticks, that is ticks with some liquidity. When
a flag is set (1), the tick has liquidity; when flag is not set (0), the tick is not initialized. Let&rsquo;s review the
implementation.</p><h2 id=tickbitmap-contract>TickBitmap Contract
<a class=anchor href=#tickbitmap-contract>#</a></h2><p>In the pool contract, the tick index is stored in a state variable:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>contract</span> <span style=color:#a6e22e>UniswapV3Pool</span> {
</span></span><span style=display:flex><span>    <span style=color:#f92672>using</span> TickBitmap <span style=color:#66d9ef>for</span> <span style=color:#66d9ef>mapping</span>(<span style=color:#66d9ef>int16</span> <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>uint256</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>mapping</span>(<span style=color:#66d9ef>int16</span> <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>uint256</span>) <span style=color:#66d9ef>public</span> tickBitmap;
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This is mapping where keys are <code>int16</code>&rsquo;s and values are words (<code>uint256</code>). Imagine an infinite continuous array of ones
and zeros:</p><p>[TODO: add illustration]</p><p>Each element in this array corresponds to a tick. To navigate in this array, we break it into words: sub-arrays of
length 256 bits. To find tick&rsquo;s position in this array, we do:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>position</span>(<span style=color:#66d9ef>int24</span> tick) <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>pure</span> <span style=color:#66d9ef>returns</span> (<span style=color:#66d9ef>int16</span> wordPos, <span style=color:#66d9ef>uint8</span> bitPos) {
</span></span><span style=display:flex><span>    wordPos <span style=color:#f92672>=</span> <span style=color:#66d9ef>int16</span>(tick <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>8</span>);
</span></span><span style=display:flex><span>    bitPos <span style=color:#f92672>=</span> <span style=color:#66d9ef>uint8</span>(<span style=color:#66d9ef>uint24</span>(tick <span style=color:#f92672>%</span> <span style=color:#ae81ff>256</span>));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That is: we find its word position and then its bit in this word. <code>>> 8</code> is identical to division by 256. So, word
position is the integer part of tick index divided by 256, and bit position is the remainder.</p><p>As an example, let&rsquo;s calculate word and bit positions for one of our ticks:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>tick <span style=color:#f92672>=</span> <span style=color:#ae81ff>85176</span>
</span></span><span style=display:flex><span>word_pos <span style=color:#f92672>=</span> tick <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>8</span> <span style=color:#75715e># or tick // 2**8</span>
</span></span><span style=display:flex><span>bit_pos <span style=color:#f92672>=</span> tick <span style=color:#f92672>%</span> <span style=color:#ae81ff>256</span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Word </span><span style=color:#e6db74>{</span>word_pos<span style=color:#e6db74>}</span><span style=color:#e6db74>, bit </span><span style=color:#e6db74>{</span>bit_pos<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#75715e># Word 332, bit 184</span>
</span></span></code></pre></div><h3 id=flipping-flags>Flipping Flags
<a class=anchor href=#flipping-flags>#</a></h3><p>When adding liquidity into a pool, we need to set a couple of tick flags in the bitmap: one for the lower tick and one
for the upper tick. We do this in <code>flipTick</code> method of the bitmap mapping:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>flipTick</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>mapping</span>(<span style=color:#66d9ef>int16</span> <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>uint256</span>) <span style=color:#66d9ef>storage</span> self,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int24</span> tick,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int24</span> tickSpacing
</span></span><span style=display:flex><span>) <span style=color:#66d9ef>internal</span> {
</span></span><span style=display:flex><span>    require(tick <span style=color:#f92672>%</span> tickSpacing <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>); <span style=color:#75715e>// ensure that the tick is spaced
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    (<span style=color:#66d9ef>int16</span> wordPos, <span style=color:#66d9ef>uint8</span> bitPos) <span style=color:#f92672>=</span> position(tick <span style=color:#f92672>/</span> tickSpacing);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> mask <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> bitPos;
</span></span><span style=display:flex><span>    self[wordPos] <span style=color:#f92672>^=</span> mask;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>Until later in the book, <code>tickSpacing</code> is always 1.</p></blockquote><p>After finding word and bit positions, we need to make a mask. A mask is a number that has a single 1 flag set at the
bit position of the tick. To find the mask, we simply calculate <code>2**bit_pos</code> (equivalent of <code>1 &lt;&lt; bit_pos</code>):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>mask <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>**</span>bit_pos <span style=color:#75715e># or 1 &lt;&lt; bit_pos</span>
</span></span><span style=display:flex><span>print(bin(mask))
</span></span><span style=display:flex><span><span style=color:#75715e>#0b10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</span>
</span></span></code></pre></div><p>Next, to flip a flag, we apply the mask to the tick&rsquo;s word via bitwise XOR:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>word <span style=color:#f92672>=</span> (<span style=color:#ae81ff>2</span><span style=color:#f92672>**</span><span style=color:#ae81ff>256</span>) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#75715e># set word to all ones</span>
</span></span><span style=display:flex><span>print(bin(word <span style=color:#f92672>^</span> mask))
</span></span><span style=display:flex><span><span style=color:#75715e>#0b11111111111111111111111111111111111111111111111111111111111111111111111-&gt;0&lt;-1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111</span>
</span></span></code></pre></div><p>You&rsquo;ll see that 184th bit (counting from the right starting at 0) has flipped to 0.</p><h3 id=finding-next-tick>Finding Next Tick
<a class=anchor href=#finding-next-tick>#</a></h3><p>Next step is finding ticks with liquidity using the bitmap index.</p><p>During swapping, we need to find a tick with liquidity that&rsquo;s before or after the current tick (that is: to the left or
to the right of it). In the previous milestone, we used to <a href=https://github.com/Jeiwan/uniswapv3-code/blob/85b8605c37a9065c141a234ee2c18d9507eeba22/src/UniswapV3Pool.sol#L142>calculate and hard code it</a>,
but now we need to find such tick using the bitmap index. We&rsquo;ll do this in <code>TickMath.nextInitializedTickWithinOneWord</code>
method. In this function, we&rsquo;ll need to implement two scenarios:</p><ol><li>When selling token $X$ (ETH in our case), find next initialized tick in the current tick&rsquo;s word and <strong>to the right</strong> of the current tick.</li><li>When selling token $Y$ (USDC in our case), find next initialized tick in the next (current + 1) tick&rsquo;s word and <strong>to the left</strong> of the current tick.</li></ol><p>This corresponds to the price movement when making swaps in either directions:</p><p>[TODO: add illustration, price change direction and tick change direction]</p><p>We include the current price when price grows.</p><p>Now, let&rsquo;s look at the implementation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>nextInitializedTickWithinOneWord</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>mapping</span>(<span style=color:#66d9ef>int16</span> <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>uint256</span>) <span style=color:#66d9ef>storage</span> self,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int24</span> tick,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int24</span> tickSpacing,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> lte
</span></span><span style=display:flex><span>) <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>view</span> <span style=color:#66d9ef>returns</span> (<span style=color:#66d9ef>int24</span> next, <span style=color:#66d9ef>bool</span> initialized) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int24</span> compressed <span style=color:#f92672>=</span> tick <span style=color:#f92672>/</span> tickSpacing;
</span></span><span style=display:flex><span>    ...
</span></span></code></pre></div><ol><li>First arguments makes this function a method of <code>mapping(int16 => uint256)</code>.</li><li><code>tick</code> is the current tick.</li><li><code>tickSpacing</code> is always 1 until we start using it in Milestone 3.</li><li><code>lte</code> is the flag that sets the direction. When <code>true</code>, we&rsquo;re selling token $X$ and searching for next initialized tick
to the right of the current one. When <code>false,</code> it&rsquo;s the other way around.</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>if</span> (lte) {
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>int16</span> wordPos, <span style=color:#66d9ef>uint8</span> bitPos) <span style=color:#f92672>=</span> position(compressed);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> mask <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> bitPos) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> bitPos);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> masked <span style=color:#f92672>=</span> self[wordPos] <span style=color:#f92672>&amp;</span> mask;
</span></span><span style=display:flex><span>    ...
</span></span></code></pre></div><p>When selling $X$, we&rsquo;re:</p><ol><li>taking current tick&rsquo;s word and bit positions;</li><li>making a mask where all bits to the right of the current bit position, including it, are ones (<code>mask</code> is all ones,
its length = <code>bitPos</code>);</li><li>applying the mask to the current tick&rsquo;s word.</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    initialized <span style=color:#f92672>=</span> masked <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    next <span style=color:#f92672>=</span> initialized
</span></span><span style=display:flex><span>        <span style=color:#f92672>?</span> (compressed <span style=color:#f92672>-</span> <span style=color:#66d9ef>int24</span>(<span style=color:#66d9ef>uint24</span>(bitPos <span style=color:#f92672>-</span> BitMath.mostSignificantBit(masked)))) <span style=color:#f92672>*</span> tickSpacing
</span></span><span style=display:flex><span>        <span style=color:#f92672>:</span> (compressed <span style=color:#f92672>-</span> <span style=color:#66d9ef>int24</span>(<span style=color:#66d9ef>uint24</span>(bitPos))) <span style=color:#f92672>*</span> tickSpacing;
</span></span><span style=display:flex><span>    ...
</span></span></code></pre></div><p>Next, <code>masked</code> won&rsquo;t equal 0 if at least one bit of it is set to 1. If so, there&rsquo;s an initialized tick; if not, there
isn&rsquo;t (not in the current word). Depending on the result, we either return the index of the next initialized tick or the
leftmost bit in the next word–this will allow to search for initialized ticks in the word during another loop cycle.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>int16</span> wordPos, <span style=color:#66d9ef>uint8</span> bitPos) <span style=color:#f92672>=</span> position(compressed <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> mask <span style=color:#f92672>=</span> <span style=color:#f92672>~</span>((<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> bitPos) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> masked <span style=color:#f92672>=</span> self[wordPos] <span style=color:#f92672>&amp;</span> mask;
</span></span><span style=display:flex><span>    ...
</span></span></code></pre></div><p>Similarly, when selling $Y$, we&rsquo;re:</p><ol><li>taking next tick&rsquo;s word and bit positions;</li><li>making a different mask, where all bits to the left of next tick bit position are ones and all the bits to the right
are zeros;</li><li>applying the mask to the next tick&rsquo;s word.</li></ol><p>Again, if there&rsquo;s no initialized ticks to the left, the rightmost bit of the previous word is returned:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    initialized <span style=color:#f92672>=</span> masked <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    next <span style=color:#f92672>=</span> initialized
</span></span><span style=display:flex><span>        <span style=color:#f92672>?</span> (compressed <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> <span style=color:#66d9ef>int24</span>(<span style=color:#66d9ef>uint24</span>((BitMath.leastSignificantBit(masked) <span style=color:#f92672>-</span> bitPos)))) <span style=color:#f92672>*</span> tickSpacing
</span></span><span style=display:flex><span>        <span style=color:#f92672>:</span> (compressed <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> <span style=color:#66d9ef>int24</span>(<span style=color:#66d9ef>uint24</span>((type(<span style=color:#a6e22e>uint8</span>).max <span style=color:#f92672>-</span> bitPos)))) <span style=color:#f92672>*</span> tickSpacing;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And that&rsquo;s it!</p><p>As you can see, <code>nextInitializedTickWithinOneWord</code> doesn&rsquo;t find the exact tick–it&rsquo;s scope of search is current or next
tick&rsquo;s word. Indeed, we don&rsquo;t want to iterate over all the words since the we don&rsquo;t send boundaries on the bitmap index.
This function, however, plays well with <code>swap</code> function–soon, we&rsquo;ll see this.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#tick-bitmap-index>Tick Bitmap Index</a><ul><li><a href=#bitmap>Bitmap</a></li><li><a href=#tickbitmap-contract>TickBitmap Contract</a><ul><li><a href=#flipping-flags>Flipping Flags</a></li><li><a href=#finding-next-tick>Finding Next Tick</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>