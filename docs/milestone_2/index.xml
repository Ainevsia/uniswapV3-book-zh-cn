<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Milestone 2. Second Swap on Uniswap V3 Book 中文版</title><link>https://uniswapv3book.com/docs/milestone_2/</link><description>Recent content in Milestone 2. Second Swap on Uniswap V3 Book 中文版</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://uniswapv3book.com/docs/milestone_2/index.xml" rel="self" type="application/rss+xml"/><item><title>Introduction</title><link>https://uniswapv3book.com/docs/milestone_2/introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/introduction/</guid><description>Second Swap # Alright, this is where it gets real. So far, our implementation has been looking too synthetic and static. We have calculated and hard coded all the amounts to make the learning curve less steep, and now we&amp;rsquo;re ready to make it dynamic. We&amp;rsquo;re going to implement the second swap, that is a swap in the opposite direction: sell ETH to buy USDC. To do this, we&amp;rsquo;re going to improve our smart contracts significantly:</description></item><item><title>Output Amount Calculation</title><link>https://uniswapv3book.com/docs/milestone_2/output-amount-calculation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/output-amount-calculation/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Output Amount Calculation # Our collection of Uniswap math formulas lacks a final piece: the formula of calculating the output amount when selling ETH (that is: selling token $x$).</description></item><item><title>Math in Solidity</title><link>https://uniswapv3book.com/docs/milestone_2/math-in-solidity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/math-in-solidity/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Math in Solidity # Due to Solidity not supporting numbers with th fractional part, math in Solidity is somewhat complicated.</description></item><item><title>Tick Bitmap Index</title><link>https://uniswapv3book.com/docs/milestone_2/tick-bitmap-index/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/tick-bitmap-index/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Tick Bitmap Index # As the first step towards dynamic swaps, we need to implement an index of ticks.</description></item><item><title>Generalize Minting</title><link>https://uniswapv3book.com/docs/milestone_2/generalize-minting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/generalize-minting/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Generalize Minting # Now, we&amp;rsquo;re ready to update mint function so it calculates the amounts of tokens instead of hard coding them.</description></item><item><title>Generalize Swapping</title><link>https://uniswapv3book.com/docs/milestone_2/generalize-swapping/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/generalize-swapping/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Generalize Swapping # This will be the hardest chapter of this milestone. Before updating the code, we need to understand how the algorithm of swapping in Uniswap V3 works.</description></item><item><title>Quoter Contract</title><link>https://uniswapv3book.com/docs/milestone_2/quoter-contract/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/quoter-contract/</guid><description>Quoter Contract # To integrate our updated Pool contract into the front end app, we need a way to calculate swap amounts without making a swap. Users will type in the amount they want to sell, and we want to calculate and show them the amount they&amp;rsquo;ll get in exchange. We&amp;rsquo;ll do this through Quoter contract.
Since liquidity in Uniswap V3 is scattered over multiple price ranges, we cannot calculate swap amounts with a formula (which was possible in Uniswap V2).</description></item><item><title>User Interface</title><link>https://uniswapv3book.com/docs/milestone_2/user-interface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/user-interface/</guid><description>User Interface # Let&amp;rsquo;s make our web app work more like a real DEX. We can now remove hardcoded swap amounts and let users type arbitrary amounts. Moreover, we can now let users swap in the both direction, so we also need a button to swap the token inputs. After updating, the swap form will look like:
&amp;lt;form className=&amp;#34;SwapForm&amp;#34;&amp;gt; &amp;lt;SwapInput amount={zeroForOne ? amount0 : amount1} disabled={!enabled || loading} readOnly={false} setAmount={setAmount_(zeroForOne ?</description></item></channel></rss>