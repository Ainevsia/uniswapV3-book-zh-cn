<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); }    \[ \]  Generalize Minting #  Now, we&rsquo;re ready to update mint function so it calculates the amounts of tokens instead of hard coding them."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="Generalize Minting"><meta property="og:description" content="function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); }    \[ \]  Generalize Minting #  Now, we&rsquo;re ready to update mint function so it calculates the amounts of tokens instead of hard coding them."><meta property="og:type" content="article"><meta property="og:url" content="https://uniswapv3book.com/docs/milestone_2/generalize-minting/"><meta property="article:section" content="docs"><title>Generalize Minting | Uniswap V3 Book 中文版</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.82c5dbd23447cee0b4c2aa3ed08ce0961faa40e1fa370eee4f8c9f02e0d46b5f.css integrity="sha256-gsXb0jRHzuC0wqo+0Izglh+qQOH6Nw7uT4yfAuDUa18=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.b0360dea9154348d79406c9c19eeb0985101e9918359a842737f3d85d0ad9739.js integrity="sha256-sDYN6pFUNI15QGycGe6wmFEB6ZGDWahCc389hdCtlzk=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Uniswap V3 Book 中文版</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>Milestone 0. 简介</span><ul><li><a href=/docs/introduction/introduction-to-markets/>交易市场简介</a></li><li><a href=/docs/introduction/constant-function-market-maker/>恒定乘积做市商(CFMM)</a></li><li><a href=/docs/introduction/uniswap-v3/>Uniswap V3</a></li><li><a href=/docs/introduction/dev-environment/>Development Environment</a></li></ul></li><li class=book-section-flat><span>Milestone 1. First Swap</span><ul><li><a href=/docs/milestone_1/introduction/>Introduction</a></li><li><a href=/docs/milestone_1/calculating-liquidity/>Calculating Liquidity</a></li><li><a href=/docs/milestone_1/providing-liquidity/>Providing Liquidity</a></li><li><a href=/docs/milestone_1/first-swap/>First Swap</a></li><li><a href=/docs/milestone_1/manager-contract/>Manager Contract</a></li><li><a href=/docs/milestone_1/deployment/>Deployment</a></li><li><a href=/docs/milestone_1/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 2. Second Swap</span><ul><li><a href=/docs/milestone_2/introduction/>Introduction</a></li><li><a href=/docs/milestone_2/output-amount-calculation/>Output Amount Calculation</a></li><li><a href=/docs/milestone_2/math-in-solidity/>Math in Solidity</a></li><li><a href=/docs/milestone_2/tick-bitmap-index/>Tick Bitmap Index</a></li><li><a href=/docs/milestone_2/generalize-minting/ class=active>Generalize Minting</a></li><li><a href=/docs/milestone_2/generalize-swapping/>Generalize Swapping</a></li><li><a href=/docs/milestone_2/quoter-contract/>Quoter Contract</a></li><li><a href=/docs/milestone_2/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 3. Cross-tick Swaps</span><ul><li><a href=/docs/milestone_3/introduction/>Introduction</a></li><li><a href=/docs/milestone_3/different-ranges/>Different Price Ranges</a></li><li><a href=/docs/milestone_3/cross-tick-swaps/>Cross-Tick Swaps</a></li><li><a href=/docs/milestone_3/slippage-protection/>Slippage Protection</a></li><li><a href=/docs/milestone_3/liquidity-calculation/>Liquidity Calculation</a></li><li><a href=/docs/milestone_3/more-on-fixed-point-numbers/>A Little Bit More on Fixed-point Numbers</a></li><li><a href=/docs/milestone_3/flash-loans/>Flash Loans</a></li><li><a href=/docs/milestone_3/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 4. Multi-pool Swaps</span><ul><li><a href=/docs/milestone_4/introduction/>Introduction</a></li><li><a href=/docs/milestone_4/factory-contract/>Factory Contract</a></li><li><a href=/docs/milestone_4/path/>Swap Path</a></li><li><a href=/docs/milestone_4/multi-pool-swaps/>Multi-pool Swaps</a></li><li><a href=/docs/milestone_4/user-interface/>User Interface</a></li><li><a href=/docs/milestone_4/tick-rounding/>Tick Rounding</a></li></ul></li><li class=book-section-flat><span>Milestone 5. Fees and Price Oracle</span><ul><li><a href=/docs/milestone_5/introduction/>Introduction</a></li><li><a href=/docs/milestone_5/swap-fees/>Swap Fees</a></li><li><a href=/docs/milestone_5/flash-loan-fees/>Flash Loan Fees</a></li><li><a href=/docs/milestone_5/protocol-fees/>Protocol Fees</a></li><li><a href=/docs/milestone_5/price-oracle/>Price Oracle</a></li><li><a href=/docs/milestone_5/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 6: NFT positions</span><ul><li><a href=/docs/milestone_6/introduction/>Introduction</a></li><li><a href=/docs/milestone_6/erc721-overview/>ERC721 Overview</a></li><li><a href=/docs/milestone_6/nft-manager/>NFT Manager</a></li><li><a href=/docs/milestone_6/nft-renderer/>NFT Renderer</a></li></ul></li><li class=book-section-flat><span>补充资料</span><ul><li><a href=/docs/reference/dictionary/>中英名词对照</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Generalize Minting</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#generalize-minting>Generalize Minting</a><ul><li><a href=#indexing-initialized-ticks>Indexing Initialized Ticks</a></li><li><a href=#token-amounts-calculation>Token Amounts Calculation</a></li></ul></li></ul></nav></aside></header><article class=markdown><link rel=stylesheet href=/katex/katex.min.css><script>function renderKatex(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})}</script><script defer src=/katex/katex.min.js></script>
<script defer src=/katex/auto-render.min.js onload=renderKatex(document.body)></script><span>
\[ \]</span><h1 id=generalize-minting>Generalize Minting
<a class=anchor href=#generalize-minting>#</a></h1><p>Now, we&rsquo;re ready to update <code>mint</code> function so it calculates the amounts of tokens instead of hard coding them.</p><h2 id=indexing-initialized-ticks>Indexing Initialized Ticks
<a class=anchor href=#indexing-initialized-ticks>#</a></h2><p>Recall that, in <code>mint</code> function, we update the TickInfo mapping to store information about available liquidity at ticks.
Now, we also need to index newly initialized ticks in the bitmap index–we&rsquo;ll later use this index to find next initialized
tick during swapping.</p><p>First, we need to update <code>Tick.update</code> function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#75715e>// src/lib/Tick.sol
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>update</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>mapping</span>(<span style=color:#66d9ef>int24</span> <span style=color:#f92672>=&gt;</span> Tick.Info) <span style=color:#66d9ef>storage</span> self,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int24</span> tick,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint128</span> liquidityDelta
</span></span><span style=display:flex><span>) <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>returns</span> (<span style=color:#66d9ef>bool</span> flipped) {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    flipped <span style=color:#f92672>=</span> (liquidityAfter <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) <span style=color:#f92672>!=</span> (liquidityBefore <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It now returns <code>flipped</code> flag, which is set to true when liquidity is added to an empty tick or when entire liquidity
is removed from a tick.</p><p>Then, in <code>mint</code> function, we update the bitmap index:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#75715e>// src/UniswapV3Pool.sol
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>...
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> flippedLower <span style=color:#f92672>=</span> ticks.update(lowerTick, amount);
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> flippedUpper <span style=color:#f92672>=</span> ticks.update(upperTick, amount);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (flippedLower) {
</span></span><span style=display:flex><span>    tickBitmap.flipTick(lowerTick, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (flippedUpper) {
</span></span><span style=display:flex><span>    tickBitmap.flipTick(upperTick, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><blockquote><p>Again, we&rsquo;re setting tick spacing to 1 until we introduce different values in Milestone 3.</p></blockquote><h2 id=token-amounts-calculation>Token Amounts Calculation
<a class=anchor href=#token-amounts-calculation>#</a></h2><p>The biggest change in <code>mint</code> function is switching to tokens amount calculation. In Milestone 1, we hard coded these
values:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>    amount0 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>998976618347425280</span> <span style=color:#66d9ef>ether</span>;
</span></span><span style=display:flex><span>    amount1 <span style=color:#f92672>=</span> <span style=color:#ae81ff>5000</span> <span style=color:#66d9ef>ether</span>;
</span></span></code></pre></div><p>And now we&rsquo;re going to calculate them in Solidity using formulas from Milestone 1. Let&rsquo;s recall those formulas:</p><p>$$\Delta x = \frac{L(\sqrt{p(i_u)} - \sqrt{p(i_c)})}{\sqrt{p(i_u)}\sqrt{p(i_c)}}$$
$$\Delta y = L(\sqrt{p(i_c)} - \sqrt{p(i_l)})$$</p><p>$\Delta x$ is the amount of <code>token0</code>, or token $X$. Let&rsquo;s implement it in Solidity:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#75715e>// src/lib/Math.sol
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>calcAmount0Delta</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint160</span> sqrtPriceAX96,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint160</span> sqrtPriceBX96,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint128</span> liquidity
</span></span><span style=display:flex><span>) <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>pure</span> <span style=color:#66d9ef>returns</span> (<span style=color:#66d9ef>uint256</span> amount0) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (sqrtPriceAX96 <span style=color:#f92672>&gt;</span> sqrtPriceBX96)
</span></span><span style=display:flex><span>        (sqrtPriceAX96, sqrtPriceBX96) <span style=color:#f92672>=</span> (sqrtPriceBX96, sqrtPriceAX96);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    require(sqrtPriceAX96 <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    amount0 <span style=color:#f92672>=</span> divRoundingUp(
</span></span><span style=display:flex><span>        mulDivRoundingUp(
</span></span><span style=display:flex><span>            (<span style=color:#66d9ef>uint256</span>(liquidity) <span style=color:#f92672>&lt;&lt;</span> FixedPoint96.RESOLUTION),
</span></span><span style=display:flex><span>            (sqrtPriceBX96 <span style=color:#f92672>-</span> sqrtPriceAX96),
</span></span><span style=display:flex><span>            sqrtPriceBX96
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>        sqrtPriceAX96
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>This function is identical to <code>calc_amount0</code> in our Python script.</p></blockquote><p>First step is to sort the prices to ensure we don&rsquo;t underflow when subtracting. Next, we convert <code>liquidity</code> to a Q96.64
number by multiplying it by 2**96. Next, according to the formula, we multiply it by the difference of the prices and
divide it by the bigger price. Then, we divide by the smaller price. The order of division doesn&rsquo;t matter, but we want
to have two divisions because multiplication of prices can overflow.</p><p>We&rsquo;re using <code>mulDivRoundingUp</code> to multiply and divide in one operation. This function is based on <code>mulDiv</code> from <code>PRBMath</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>mulDivRoundingUp</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> a,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> denominator
</span></span><span style=display:flex><span>) <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>pure</span> <span style=color:#66d9ef>returns</span> (<span style=color:#66d9ef>uint256</span> result) {
</span></span><span style=display:flex><span>    result <span style=color:#f92672>=</span> PRBMath.mulDiv(a, b, denominator);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (mulmod(a, b, denominator) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        require(result <span style=color:#f92672>&lt;</span> type(<span style=color:#a6e22e>uint256</span>).max);
</span></span><span style=display:flex><span>        result<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>mulmod</code> is a Solidity function that multiplies two numbers (<code>a</code> and <code>b</code>), divides the result by <code>denominator</code>, and
returns the remainder. If the remainder is positive, we round the result up.</p><blockquote><p>We always round calculated amounts up because we haven&rsquo;t implement liquidity removal yet. We adding liquidity, we want
to ensure that calculated token amounts &ldquo;fill&rdquo; the entire liquidity.</p></blockquote><p>Next, $\Delta y$:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>calcAmount1Delta</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint160</span> sqrtPriceAX96,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint160</span> sqrtPriceBX96,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint128</span> liquidity
</span></span><span style=display:flex><span>) <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>pure</span> <span style=color:#66d9ef>returns</span> (<span style=color:#66d9ef>uint256</span> amount1) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (sqrtPriceAX96 <span style=color:#f92672>&gt;</span> sqrtPriceBX96)
</span></span><span style=display:flex><span>        (sqrtPriceAX96, sqrtPriceBX96) <span style=color:#f92672>=</span> (sqrtPriceBX96, sqrtPriceAX96);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    amount1 <span style=color:#f92672>=</span> mulDivRoundingUp(
</span></span><span style=display:flex><span>        liquidity,
</span></span><span style=display:flex><span>        (sqrtPriceBX96 <span style=color:#f92672>-</span> sqrtPriceAX96),
</span></span><span style=display:flex><span>        FixedPoint96.Q96
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>This function is identical to <code>calc_amount1</code> in our Python script.</p></blockquote><p>Again, we&rsquo;re using <code>mulDivRoundingUp</code> to avoid overflows during multiplication.</p><p>And that&rsquo;s it! We can now use the functions to calculate token amounts:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#75715e>// src/UniswapV3Pool.sol
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>mint</span>(...) {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    Slot0 <span style=color:#66d9ef>memory</span> slot0_ <span style=color:#f92672>=</span> slot0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    amount0 <span style=color:#f92672>=</span> Math.calcAmount0Delta(
</span></span><span style=display:flex><span>        TickMath.getSqrtRatioAtTick(slot0_.tick),
</span></span><span style=display:flex><span>        TickMath.getSqrtRatioAtTick(upperTick),
</span></span><span style=display:flex><span>        amount
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    amount1 <span style=color:#f92672>=</span> Math.calcAmount1Delta(
</span></span><span style=display:flex><span>        TickMath.getSqrtRatioAtTick(slot0_.tick),
</span></span><span style=display:flex><span>        TickMath.getSqrtRatioAtTick(lowerTick),
</span></span><span style=display:flex><span>        amount
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Everything else remains the same. You&rsquo;ll need to update the amounts in the pool tests, they&rsquo;ll be slightly different
due to rounding.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#generalize-minting>Generalize Minting</a><ul><li><a href=#indexing-initialized-ticks>Indexing Initialized Ticks</a></li><li><a href=#token-amounts-calculation>Token Amounts Calculation</a></li></ul></li></ul></nav></div></aside></main></body></html>