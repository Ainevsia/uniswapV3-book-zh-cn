<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="User Interface #  After introducing swap paths, we can significantly simplify the internal of our web app. First of all, every swap now uses a path since path doesn&rsquo;t have to contain multiple pools. Second, it&rsquo;s now easier to change the direction of swap: we can simply reverse the path. And, thanks to the unified pool address generation via CREATE2 and unique salts, we no longer need to store pool addresses and care about tokens order."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="User Interface"><meta property="og:description" content="User Interface #  After introducing swap paths, we can significantly simplify the internal of our web app. First of all, every swap now uses a path since path doesn&rsquo;t have to contain multiple pools. Second, it&rsquo;s now easier to change the direction of swap: we can simply reverse the path. And, thanks to the unified pool address generation via CREATE2 and unique salts, we no longer need to store pool addresses and care about tokens order."><meta property="og:type" content="article"><meta property="og:url" content="https://uniswapv3book.com/docs/milestone_4/user-interface/"><meta property="article:section" content="docs"><title>User Interface | Uniswap V3 Development Book</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.82c5dbd23447cee0b4c2aa3ed08ce0961faa40e1fa370eee4f8c9f02e0d46b5f.css integrity="sha256-gsXb0jRHzuC0wqo+0Izglh+qQOH6Nw7uT4yfAuDUa18=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.7dd8482a2abd0a6221fb6f55b03476359d038ce11f0b41e2a8fe6393d9118928.js integrity="sha256-fdhIKiq9CmIh+29VsDR2NZ0DjOEfC0HiqP5jk9kRiSg=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Uniswap V3 Development Book</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>Milestone 0. Introduction</span><ul><li><a href=/docs/introduction/introduction-to-markets/>Introduction to markets</a></li><li><a href=/docs/introduction/constant-function-market-maker/>Constant Function Market Makers</a></li><li><a href=/docs/introduction/uniswap-v3/>Uniswap V3</a></li><li><a href=/docs/introduction/dev-environment/>Development Environment</a></li></ul></li><li class=book-section-flat><span>Milestone 1. First Swap</span><ul><li><a href=/docs/milestone_1/introduction/>Introduction</a></li><li><a href=/docs/milestone_1/calculating-liquidity/>Calculating Liquidity</a></li><li><a href=/docs/milestone_1/providing-liquidity/>Providing Liquidity</a></li><li><a href=/docs/milestone_1/first-swap/>First Swap</a></li><li><a href=/docs/milestone_1/manager-contract/>Manager Contract</a></li><li><a href=/docs/milestone_1/deployment/>Deployment</a></li><li><a href=/docs/milestone_1/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 2. Second Swap</span><ul><li><a href=/docs/milestone_2/introduction/>Introduction</a></li><li><a href=/docs/milestone_2/output-amount-calculation/>Output Amount Calculation</a></li><li><a href=/docs/milestone_2/math-in-solidity/>Math in Solidity</a></li><li><a href=/docs/milestone_2/tick-bitmap-index/>Tick Bitmap Index</a></li><li><a href=/docs/milestone_2/generalize-minting/>Generalize Minting</a></li><li><a href=/docs/milestone_2/generalize-swapping/>Generalize Swapping</a></li><li><a href=/docs/milestone_2/quoter-contract/>Quoter Contract</a></li><li><a href=/docs/milestone_2/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 3. Cross-tick Swaps</span><ul><li><a href=/docs/milestone_3/introduction/>Introduction</a></li><li><a href=/docs/milestone_3/different-ranges/>Different Price Ranges</a></li><li><a href=/docs/milestone_3/cross-tick-swaps/>Cross-Tick Swaps</a></li><li><a href=/docs/milestone_3/slippage-protection/>Slippage Protection</a></li><li><a href=/docs/milestone_3/liquidity-calculation/>Liquidity Calculation</a></li><li><a href=/docs/milestone_3/more-on-fixed-point-numbers/>A Little Bit More on Fixed-point Numbers</a></li><li><a href=/docs/milestone_3/flash-loans/>Flash Loans</a></li><li><a href=/docs/milestone_3/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 4. Multi-pool Swaps</span><ul><li><a href=/docs/milestone_4/introduction/>Introduction</a></li><li><a href=/docs/milestone_4/factory-contract/>Factory Contract</a></li><li><a href=/docs/milestone_4/path/>Swap Path</a></li><li><a href=/docs/milestone_4/multi-pool-swaps/>Multi-pool Swaps</a></li><li><a href=/docs/milestone_4/user-interface/ class=active>User Interface</a></li><li><a href=/docs/milestone_4/tick-rounding/>Tick Rounding</a></li></ul></li><li class=book-section-flat><span>Milestone 5. Fees and Price Oracle</span><ul><li><a href=/docs/milestone_5/introduction/>Introduction</a></li><li><a href=/docs/milestone_5/swap-fees/>Swap Fees</a></li><li><a href=/docs/milestone_5/flash-loan-fees/>Flash Loan Fees</a></li><li><a href=/docs/milestone_5/protocol-fees/>Protocol Fees</a></li><li><a href=/docs/milestone_5/price-oracle/>Price Oracle</a></li><li><a href=/docs/milestone_5/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 6: NFT positions</span><ul><li><a href=/docs/milestone_6/introduction/>Introduction</a></li><li><a href=/docs/milestone_6/erc721-overview/>ERC721 Overview</a></li><li><a href=/docs/milestone_6/nft-manager/>NFT Manager</a></li><li><a href=/docs/milestone_6/nft-renderer/>NFT Renderer</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>User Interface</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#user-interface>User Interface</a><ul><li><a href=#autorouter>AutoRouter</a></li><li><a href=#a-simple-router-design>A Simple Router Design</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=user-interface>User Interface
<a class=anchor href=#user-interface>#</a></h1><p>After introducing swap paths, we can significantly simplify the internal of our web app. First of all, every swap now
uses a path since path doesn&rsquo;t have to contain multiple pools. Second, it&rsquo;s now easier to change the direction of swap:
we can simply reverse the path. And, thanks to the unified pool address generation via <code>CREATE2</code> and unique salts, we
no longer need to store pool addresses and care about tokens order.</p><p>However, we cannot integrate multi-pool swaps in the web app without adding one crucial algorithm. Ask yourself the
question: &ldquo;How to find a path between two tokens that don&rsquo;t have a pool?&rdquo;</p><h2 id=autorouter>AutoRouter
<a class=anchor href=#autorouter>#</a></h2><p>Uniswap implements what&rsquo;s called <em>AutoRouter</em>, an algorithm that find shortest path between two tokens. Moreover, it also
splits one payment into multiple smaller payments to find the best average exchange rate. The profit can be as big as
<a href=https://uniswap.org/blog/auto-router-v2>36.84% compared to trades that are not split</a>. This sounds great, however, we&rsquo;re
not going to build such an advanced algorithm. Instead, we&rsquo;ll be a simpler one.</p><h2 id=a-simple-router-design>A Simple Router Design
<a class=anchor href=#a-simple-router-design>#</a></h2><p>Suppose we have a whole bunch of pools:</p><p>[TODO: illustrate]</p><p>How do find a shortest path between two tokens in such a mess?</p><p>The most suitable solution for such kind of task is based on a <em>graph</em>. A graph is a data structure that consists of
nodes (objects representing something) and edges (links connecting nodes). We can turn that mess of pools into a graph
where each node is a token (that has a pool) and each edge is a pool this token belongs to. So a pool represented as a
graph is two nodes connected with an edge. And the above pools become this graph:</p><p>[TODO: illustrate]</p><p>The biggest advantage graphs give us is the ability to traverse them, from one node to another, to find paths. Specifically,
we&rsquo;ll use <a href=https://en.wikipedia.org/wiki/A*_search_algorithm>A* search algorithm</a>. Feel free learning about how the
algorithm works, but, in our app, we&rsquo;ll use a library to make our life easier. The set of libraries we&rsquo;ll use is:
<a href=https://github.com/anvaka/ngraph.graph>ngraph.ngraph</a> for building graphs and <a href=https://github.com/anvaka/ngraph.path>ngraph.path</a>
for finding paths (it&rsquo;s the latter that implements A* search algorithm, as well as some others).</p><p>In the UI app, let&rsquo;s create a path finder. This will be a class that, when instantiated, turns a list of pairs into a
graph to later use the graph to find a shortest path between two tokens.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>createGraph</span> <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;ngraph.graph&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>path</span> <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;ngraph.path&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PathFinder</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>constructor</span>(<span style=color:#a6e22e>pairs</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>graph</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>createGraph</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>pairs</span>.<span style=color:#a6e22e>forEach</span>((<span style=color:#a6e22e>pair</span>) =&gt; {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>graph</span>.<span style=color:#a6e22e>addNode</span>(<span style=color:#a6e22e>pair</span>.<span style=color:#a6e22e>token0</span>.<span style=color:#a6e22e>address</span>);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>graph</span>.<span style=color:#a6e22e>addNode</span>(<span style=color:#a6e22e>pair</span>.<span style=color:#a6e22e>token1</span>.<span style=color:#a6e22e>address</span>);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>graph</span>.<span style=color:#a6e22e>addLink</span>(<span style=color:#a6e22e>pair</span>.<span style=color:#a6e22e>token0</span>.<span style=color:#a6e22e>address</span>, <span style=color:#a6e22e>pair</span>.<span style=color:#a6e22e>token1</span>.<span style=color:#a6e22e>address</span>, <span style=color:#a6e22e>pair</span>.<span style=color:#a6e22e>tickSpacing</span>);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>graph</span>.<span style=color:#a6e22e>addLink</span>(<span style=color:#a6e22e>pair</span>.<span style=color:#a6e22e>token1</span>.<span style=color:#a6e22e>address</span>, <span style=color:#a6e22e>pair</span>.<span style=color:#a6e22e>token0</span>.<span style=color:#a6e22e>address</span>, <span style=color:#a6e22e>pair</span>.<span style=color:#a6e22e>tickSpacing</span>);
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>finder</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>path</span>.<span style=color:#a6e22e>aStar</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>graph</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  ...
</span></span></code></pre></div><p>In the constructor, we&rsquo;re creating an empty graph and fill it with linked nodes. Each node is a token address and links
have associated data, which is tick spacings–we&rsquo;ll be able to extract this information from paths found by A*. After
initializing a graph, we instantiate A* algorithm implementation.</p><p>Next, we need to implement a function that will find a path between tokens and turn it into an array of token addresses
and tick spacings:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>findPath</span>(<span style=color:#a6e22e>fromToken</span>, <span style=color:#a6e22e>toToken</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>finder</span>.<span style=color:#a6e22e>find</span>(<span style=color:#a6e22e>fromToken</span>, <span style=color:#a6e22e>toToken</span>).<span style=color:#a6e22e>reduce</span>((<span style=color:#a6e22e>acc</span>, <span style=color:#a6e22e>node</span>, <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>orig</span>) =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>acc</span>.<span style=color:#a6e22e>length</span> <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>acc</span>.<span style=color:#a6e22e>push</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>graph</span>.<span style=color:#a6e22e>getLink</span>(<span style=color:#a6e22e>orig</span>[<span style=color:#a6e22e>i</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>].<span style=color:#a6e22e>id</span>, <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>id</span>).<span style=color:#a6e22e>data</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>acc</span>.<span style=color:#a6e22e>push</span>(<span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>id</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>acc</span>;
</span></span><span style=display:flex><span>  }, []).<span style=color:#a6e22e>reverse</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>this.finder.find(fromToken, toToken)</code> returns a list of nodes and, unfortunately, doesn&rsquo;t contain the information
about edges between them (we store tick spacings in edges). Thus, we&rsquo;re calling <code>this.graph.getLink(previousNode, currentNode)</code>
to find edges.</p><p>Now, whenever user changes input or output token, we can call <code>pathFinder.findPath(token0, token1)</code> to build a new path.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#user-interface>User Interface</a><ul><li><a href=#autorouter>AutoRouter</a></li><li><a href=#a-simple-router-design>A Simple Router Design</a></li></ul></li></ul></nav></div></aside></main></body></html>