<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Milestone 0. 简介 on Uniswap V3 Book 中文版</title><link>https://uniswapv3book.com/docs/introduction/</link><description>Recent content in Milestone 0. 简介 on Uniswap V3 Book 中文版</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://uniswapv3book.com/docs/introduction/index.xml" rel="self" type="application/rss+xml"/><item><title>交易市场简介</title><link>https://uniswapv3book.com/docs/introduction/introduction-to-markets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/introduction/introduction-to-markets/</guid><description>交易市场简介 # 中心化交易所(CEX)如何工作 # 在本书中，我们将会搭建一个运行在以太坊(Ethereum)上的去中心化交易所(DEX)。DEX的设计模式非常复杂多样，因此我们先来考虑中心化交易所的设计。中心化交易所(CEX)的核心为订单簿(order book)，存储了用户的所有买单和卖单。订单簿中的每一笔订单都包含了订单成交的价格以及成交数量。
交易能够正常进行的保障是流动性(liquidity)，也即整个市场中所有可获得的资产数目。假设你希望购买一个衣柜但是没有人售卖，即为没有流动性；如果你希望卖出一个衣柜但是没有人愿意购买，即为市场有流动性但是没有买方。没有流动性，就无法在市场中进行买卖。
在CEX中，流动性存放在订单簿中。如果某个用户提交了一个卖单，他就为市场提供了流动性；如果某人提交了一个买单，他们希望市场有流动性，否则交易就无法进行。
如果市场没有流动性，但是仍然希望进行交易，就需要做市商(market maker)。做市商是向市场提供流动性的，拥有大量各种资产的公司或个人。通过提供流动性，做市商能够从交易中获取利润。
去中心化交易所(DEX)如何工作 # 毫无疑问，去中心化的交易也需要流动性，并且也需要做市商向市场提供多种资产的流动性。然而，在DEX中这个过程无法被中心化地处理，我们需要一种去中心化的做市商方案。相关解决方案非常多样化，而本书将主要关注Uniswap提供的方案。
自动做市商(AMM) # 链上交易市场的历史 一文提到了一种称作自动做市商(Automated Market Maker)的思路。正如其名，这种算法能够自动化完成像做市商一样的工作。更进一步，这种算法是去中心化且无需许可的，也即：
没有被任何单个中心化机构控制 所有资产并不存储在同一地方 任何人在任何地点都能使用 什么是自动做市商AMM？ # 一个AMM是一套定义如何管理流动性的智能合约。每个单独的交易对（例如ETH/USDC）都是一个单独的智能合约，存储了ETH和USDC的资产并且撮合交易，在这个合约中我们可以将ETH兑换成USDC或者将USDC兑换成ETH。
在AMM中，一个核心思想为池子(pooling)：每个合约都是一个存储流动性的池子，允许不同的用户（包括其他合约）在其中进行某种方式的交易。在AMM中有两种角色，*流动性提供者(LP)*以及交易者；这两者通过流动性池进行交互，交互的方式由合约进行规定且不可更改。
这种方法与CEX的关键区别在于： 智能合约是完全自动化的并且不受任何人控制。没有经理，没有系统管理员，没有特权用户，一切都没有。这里只有LP和交易者，任何人都可以担任这两种角色（也可以同时），并且所有的算法都是公开的、程序规定的、不可更改的。
在后面的篇章，我们将更进一步了解Uniswap是如何实现AMM的。
注意在后文中，pool和pair两个词可能会被交替使用，因为一个Uniswap的流动性池即一对token</description></item><item><title>恒定函数做市商(CFMM)</title><link>https://uniswapv3book.com/docs/introduction/constant-function-market-maker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/introduction/constant-function-market-maker/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] 恒定函数做市商 (Constant Function Market Makers) # 本章节主要讲述了Uniswap V2白皮书中的内容. 理解其中的数学原理能帮助你更好地构建像Uniswap这样的应用, 不过假设你没有理解本章全部内容也没有关系
正如我们在上一节中提到的那样，AMM的构建有许多不同的方法。我们将主要关注与构建一种特定的AMM：恒定函数做市商（有时也被称为恒定乘积做市商）。尽管名字听起来很复杂，但是它的核心数学原理只是一个非常简单的公式：
$$x * y = k$$</description></item><item><title>Uniswap V3</title><link>https://uniswapv3book.com/docs/introduction/uniswap-v3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/introduction/uniswap-v3/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Introduction to Uniswap V3 # This chapter retells the whitepaper of Uniswap V3. Again, it&amp;rsquo;s totally ok if you don&amp;rsquo;t understand all the concepts.</description></item><item><title>Development Environment</title><link>https://uniswapv3book.com/docs/introduction/dev-environment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/introduction/dev-environment/</guid><description>Development environment # We&amp;rsquo;re going to build two applications:
An on-chain one: a set of smart contracts deployed on Ethereum. An off-chain one: a front-end application that will interact with the smart contracts. While the front-end application development is part of this book, it won&amp;rsquo;t be our main focus. We will build it solely to demonstrate how smart contracts are integrated with front-end applications. Thus, the front-end application is optional, but I&amp;rsquo;ll still provide the code.</description></item></channel></rss>