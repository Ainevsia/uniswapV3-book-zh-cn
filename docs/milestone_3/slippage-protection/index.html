<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); }    \[ \]  Slippage Protection #  Slippage is a very important issued in decentralized exchanges. Slippage simply means the difference between the price that you see on the screen when initialing a transaction and the actual price the swap is executed at."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="Slippage Protection"><meta property="og:description" content="function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); }    \[ \]  Slippage Protection #  Slippage is a very important issued in decentralized exchanges. Slippage simply means the difference between the price that you see on the screen when initialing a transaction and the actual price the swap is executed at."><meta property="og:type" content="article"><meta property="og:url" content="https://uniswapv3book.com/docs/milestone_3/slippage-protection/"><meta property="article:section" content="docs"><title>Slippage Protection | Uniswap V3 Book 中文版</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.82c5dbd23447cee0b4c2aa3ed08ce0961faa40e1fa370eee4f8c9f02e0d46b5f.css integrity="sha256-gsXb0jRHzuC0wqo+0Izglh+qQOH6Nw7uT4yfAuDUa18=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.b0360dea9154348d79406c9c19eeb0985101e9918359a842737f3d85d0ad9739.js integrity="sha256-sDYN6pFUNI15QGycGe6wmFEB6ZGDWahCc389hdCtlzk=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Uniswap V3 Book 中文版</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>Milestone 0. 简介</span><ul><li><a href=/docs/introduction/introduction-to-markets/>交易市场简介</a></li><li><a href=/docs/introduction/constant-function-market-maker/>恒定乘积做市商(CFMM)</a></li><li><a href=/docs/introduction/uniswap-v3/>Uniswap V3</a></li><li><a href=/docs/introduction/dev-environment/>Development Environment</a></li></ul></li><li class=book-section-flat><span>Milestone 1. First Swap</span><ul><li><a href=/docs/milestone_1/introduction/>Introduction</a></li><li><a href=/docs/milestone_1/calculating-liquidity/>Calculating Liquidity</a></li><li><a href=/docs/milestone_1/providing-liquidity/>Providing Liquidity</a></li><li><a href=/docs/milestone_1/first-swap/>First Swap</a></li><li><a href=/docs/milestone_1/manager-contract/>Manager Contract</a></li><li><a href=/docs/milestone_1/deployment/>Deployment</a></li><li><a href=/docs/milestone_1/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 2. Second Swap</span><ul><li><a href=/docs/milestone_2/introduction/>Introduction</a></li><li><a href=/docs/milestone_2/output-amount-calculation/>Output Amount Calculation</a></li><li><a href=/docs/milestone_2/math-in-solidity/>Math in Solidity</a></li><li><a href=/docs/milestone_2/tick-bitmap-index/>Tick Bitmap Index</a></li><li><a href=/docs/milestone_2/generalize-minting/>Generalize Minting</a></li><li><a href=/docs/milestone_2/generalize-swapping/>Generalize Swapping</a></li><li><a href=/docs/milestone_2/quoter-contract/>Quoter Contract</a></li><li><a href=/docs/milestone_2/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 3. Cross-tick Swaps</span><ul><li><a href=/docs/milestone_3/introduction/>Introduction</a></li><li><a href=/docs/milestone_3/different-ranges/>Different Price Ranges</a></li><li><a href=/docs/milestone_3/cross-tick-swaps/>Cross-Tick Swaps</a></li><li><a href=/docs/milestone_3/slippage-protection/ class=active>Slippage Protection</a></li><li><a href=/docs/milestone_3/liquidity-calculation/>Liquidity Calculation</a></li><li><a href=/docs/milestone_3/more-on-fixed-point-numbers/>A Little Bit More on Fixed-point Numbers</a></li><li><a href=/docs/milestone_3/flash-loans/>Flash Loans</a></li><li><a href=/docs/milestone_3/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 4. Multi-pool Swaps</span><ul><li><a href=/docs/milestone_4/introduction/>Introduction</a></li><li><a href=/docs/milestone_4/factory-contract/>Factory Contract</a></li><li><a href=/docs/milestone_4/path/>Swap Path</a></li><li><a href=/docs/milestone_4/multi-pool-swaps/>Multi-pool Swaps</a></li><li><a href=/docs/milestone_4/user-interface/>User Interface</a></li><li><a href=/docs/milestone_4/tick-rounding/>Tick Rounding</a></li></ul></li><li class=book-section-flat><span>Milestone 5. Fees and Price Oracle</span><ul><li><a href=/docs/milestone_5/introduction/>Introduction</a></li><li><a href=/docs/milestone_5/swap-fees/>Swap Fees</a></li><li><a href=/docs/milestone_5/flash-loan-fees/>Flash Loan Fees</a></li><li><a href=/docs/milestone_5/protocol-fees/>Protocol Fees</a></li><li><a href=/docs/milestone_5/price-oracle/>Price Oracle</a></li><li><a href=/docs/milestone_5/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 6: NFT positions</span><ul><li><a href=/docs/milestone_6/introduction/>Introduction</a></li><li><a href=/docs/milestone_6/erc721-overview/>ERC721 Overview</a></li><li><a href=/docs/milestone_6/nft-manager/>NFT Manager</a></li><li><a href=/docs/milestone_6/nft-renderer/>NFT Renderer</a></li></ul></li><li class=book-section-flat><span>补充资料</span><ul><li><a href=/docs/reference/dictionary/>中英名词对照</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Slippage Protection</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#slippage-protection>Slippage Protection</a><ul><li><a href=#slippage-protection-in-swaps>Slippage Protection in Swaps</a></li><li><a href=#slippage-protection-in-minting>Slippage Protection in Minting</a></li></ul></li></ul></nav></aside></header><article class=markdown><link rel=stylesheet href=/katex/katex.min.css><script>function renderKatex(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})}</script><script defer src=/katex/katex.min.js></script>
<script defer src=/katex/auto-render.min.js onload=renderKatex(document.body)></script><span>
\[ \]</span><h1 id=slippage-protection>Slippage Protection
<a class=anchor href=#slippage-protection>#</a></h1><p>Slippage is a very important issued in decentralized exchanges. Slippage simply means the difference between the price
that you see on the screen when initialing a transaction and the actual price the swap is executed at. This difference
appears because there&rsquo;s a short (and sometimes long, depending on network congestion and gas costs) delay between when
you send a transaction and when it gets mined. In more technical terms, blockchain state changes every block and there&rsquo;s
no guarantee that your transaction will be applied at a specific block.</p><p>Another important problem that slippage protection fixes is <em>sandwich attacks</em>–this is a common type of attacks on
decentralized exchange users. During sandwiching, attackers &ldquo;wrap&rdquo; your swap transactions in their two transactions:
one goes before your transaction and the other goes after it. In the first transaction, an attacker modifier the state of
a pool so that your swap becomes very unprofitable for you and somewhat profitable for the attacker. This is achieved by
adjusting pool liquidity so that your trade happens at a lower price. In the second transaction, the attacker reestablishes
pool liquidity and the price. As a result, you get much less tokens than expected due to manipulated prices and the
attacker get some profit.</p><p>The way slippage protection is implemented in decentralized exchanges is by letting user choose how far the actual price
is allowed to drop. By default, Uniswap V3 sets slippage tolerance to 0.1%, which means a swap is executed only if the
price at the moment of execution is as small as 99.9% of the price the user saw in the browser. This is a very tight
range and users are allowed to adjust this number, which is useful when volatility is high.</p><p>Let&rsquo;s add slippage protection to our implementation!</p><h2 id=slippage-protection-in-swaps>Slippage Protection in Swaps
<a class=anchor href=#slippage-protection-in-swaps>#</a></h2><p>To protect swaps, we need to add one more parameter to <code>swap</code> function–we want to let user choose a stop price, a price
at which swapping will stop. We&rsquo;ll call the parameter <code>sqrtPriceLimitX96</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>swap</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>address</span> recipient,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> zeroForOne,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> amountSpecified,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint160</span> sqrtPriceLimitX96,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bytes</span> calldata data
</span></span><span style=display:flex><span>) <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>returns</span> (<span style=color:#66d9ef>int256</span> amount0, <span style=color:#66d9ef>int256</span> amount1) {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (
</span></span><span style=display:flex><span>        zeroForOne
</span></span><span style=display:flex><span>            <span style=color:#f92672>?</span> sqrtPriceLimitX96 <span style=color:#f92672>&gt;</span> slot0_.sqrtPriceX96 <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>                sqrtPriceLimitX96 <span style=color:#f92672>&lt;</span> TickMath.MIN_SQRT_RATIO
</span></span><span style=display:flex><span>            <span style=color:#f92672>:</span> sqrtPriceLimitX96 <span style=color:#f92672>&lt;</span> slot0_.sqrtPriceX96 <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                sqrtPriceLimitX96 <span style=color:#f92672>&gt;</span> TickMath.MAX_SQRT_RATIO
</span></span><span style=display:flex><span>    ) revert InvalidPriceLimit();
</span></span><span style=display:flex><span>    ...
</span></span></code></pre></div><p>When selling token $X$ (<code>zeroForOne</code> is true), <code>sqrtPriceLimitX96</code> must be between the current price and the minimal
$sqrt{P}$ since selling token $X$ moves the price down. Likewise, when selling token $Y$, <code>sqrtPriceLimitX96</code> must be
between the current price and the maximal $\sqrt{P}$ because price moves up.</p><p>In the while loop, we want to satisfy two conditions: full swap amount is filled and current price isn&rsquo;t equal to <code>sqrtPriceLimitX96</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>..
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (
</span></span><span style=display:flex><span>    state.amountSpecifiedRemaining <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>    state.sqrtPriceX96 <span style=color:#f92672>!=</span> sqrtPriceLimitX96
</span></span><span style=display:flex><span>) {
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>Which means that Uniswap V3 pools don&rsquo;t fail when slippage tolerance gets hit and simply executes swap partially.</p><p>Final place where we need to use <code>sqrtPriceLimitX96</code> is when calling <code>SwapMath.computeSwapStep</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>(state.sqrtPriceX96, step.amountIn, step.amountOut) <span style=color:#f92672>=</span> SwapMath
</span></span><span style=display:flex><span>    .computeSwapStep(
</span></span><span style=display:flex><span>        state.sqrtPriceX96,
</span></span><span style=display:flex><span>        (
</span></span><span style=display:flex><span>            zeroForOne
</span></span><span style=display:flex><span>                <span style=color:#f92672>?</span> step.sqrtPriceNextX96 <span style=color:#f92672>&lt;</span> sqrtPriceLimitX96
</span></span><span style=display:flex><span>                <span style=color:#f92672>:</span> step.sqrtPriceNextX96 <span style=color:#f92672>&gt;</span> sqrtPriceLimitX96
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>            <span style=color:#f92672>?</span> sqrtPriceLimitX96
</span></span><span style=display:flex><span>            <span style=color:#f92672>:</span> step.sqrtPriceNextX96,
</span></span><span style=display:flex><span>        state.liquidity,
</span></span><span style=display:flex><span>        state.amountSpecifiedRemaining
</span></span><span style=display:flex><span>    );
</span></span></code></pre></div><p>Here, we want to ensure that <code>computeSwapStep</code> never calculates swap amounts outside of <code>sqrtPriceLimitX96</code>–this guarantees
that the current price will never cross the limiting price.</p><h2 id=slippage-protection-in-minting>Slippage Protection in Minting
<a class=anchor href=#slippage-protection-in-minting>#</a></h2><p>Adding liquidity also requires slippage protection. This comes from the fact that price cannot be changed when adding
liquidity (liquidity must be proportional to current price), thus liquidity providers also suffer from slippage. Unlike
<code>swap</code> function however, we&rsquo;re not forced to implement slippage protection in Pool contract–recall that Pool contract is
a core contract and we don&rsquo;t want to put unnecessary logic into it. This is why we made Manager contract, and it&rsquo;s in
the Manager contract where we&rsquo;ll implement slippage protection.</p><p>Manager contract is a wrapper contract that makes calls to Pool contract more convenient. To implement slippage protection
in <code>mint</code> function, we can simply check the amounts of tokens taken by Pool and compare them to some minimal amounts
chosen by user. Additionally, we can free users from calculating $\sqrt{P_{lower}}$ and $\sqrt{P_{upper}}$, as well as
liquidity, and calculate these in <code>Manager.mint</code> function.</p><p>Our update <code>mint</code> function will now take more parameters, so let&rsquo;s group them in a struct:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#75715e>// src/UniswapV3Manager.sol
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>contract</span> <span style=color:#a6e22e>UniswapV3Manager</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>MintParams</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>address</span> poolAddress;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int24</span> lowerTick;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int24</span> upperTick;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint256</span> amount0Desired;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint256</span> amount1Desired;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint256</span> amount0Min;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint256</span> amount1Min;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>mint</span>(MintParams calldata params)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>returns</span> (<span style=color:#66d9ef>uint256</span> amount0, <span style=color:#66d9ef>uint256</span> amount1)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        ...
</span></span></code></pre></div><p><code>amount0Min</code> and <code>amount1Min</code> are the amounts that are calculated based on slippage tolerance. They must be smaller than
the desired amounts, with the gap set by the slippage tolerance setting. Liquidity provider expect to provide amounts
not smaller than <code>amount0Min</code> and <code>amount1Min</code>.</p><p>Next, we calculate $\sqrt{P_{lower}}$, $\sqrt{P_{upper}}$, and liquidity:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>...
</span></span><span style=display:flex><span>IUniswapV3Pool pool <span style=color:#f92672>=</span> IUniswapV3Pool(params.poolAddress);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>uint160</span> sqrtPriceX96, ) <span style=color:#f92672>=</span> pool.slot0();
</span></span><span style=display:flex><span><span style=color:#66d9ef>uint160</span> sqrtPriceLowerX96 <span style=color:#f92672>=</span> TickMath.getSqrtRatioAtTick(
</span></span><span style=display:flex><span>    params.lowerTick
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>uint160</span> sqrtPriceUpperX96 <span style=color:#f92672>=</span> TickMath.getSqrtRatioAtTick(
</span></span><span style=display:flex><span>    params.upperTick
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>uint128</span> liquidity <span style=color:#f92672>=</span> LiquidityMath.getLiquidityForAmounts(
</span></span><span style=display:flex><span>    sqrtPriceX96,
</span></span><span style=display:flex><span>    sqrtPriceLowerX96,
</span></span><span style=display:flex><span>    sqrtPriceUpperX96,
</span></span><span style=display:flex><span>    params.amount0Desired,
</span></span><span style=display:flex><span>    params.amount1Desired
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p><code>LiquidityMath.getLiquidityForAmounts</code> is a new function, we&rsquo;ll discuss it in the next chapter.</p><p>Next step is to provide liquidity to the pool and the amounts returned by the pool: if they&rsquo;re too low, we revert.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>(amount0, amount1) <span style=color:#f92672>=</span> pool.mint(
</span></span><span style=display:flex><span>    msg.sender,
</span></span><span style=display:flex><span>    params.lowerTick,
</span></span><span style=display:flex><span>    params.upperTick,
</span></span><span style=display:flex><span>    liquidity,
</span></span><span style=display:flex><span>    abi.encode(
</span></span><span style=display:flex><span>        IUniswapV3Pool.CallbackData({
</span></span><span style=display:flex><span>            token0<span style=color:#f92672>:</span> pool.token0(),
</span></span><span style=display:flex><span>            token1<span style=color:#f92672>:</span> pool.token1(),
</span></span><span style=display:flex><span>            payer<span style=color:#f92672>:</span> msg.sender
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (amount0 <span style=color:#f92672>&lt;</span> params.amount0Min <span style=color:#f92672>||</span> amount1 <span style=color:#f92672>&lt;</span> params.amount1Min)
</span></span><span style=display:flex><span>    revert SlippageCheckFailed(amount0, amount1);
</span></span></code></pre></div><p>That&rsquo;s it!</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#slippage-protection>Slippage Protection</a><ul><li><a href=#slippage-protection-in-swaps>Slippage Protection in Swaps</a></li><li><a href=#slippage-protection-in-minting>Slippage Protection in Minting</a></li></ul></li></ul></nav></div></aside></main></body></html>