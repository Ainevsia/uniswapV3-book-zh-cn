<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); }    \[ \]  Deployment #  Alright, our pool contract is done. Now, let&rsquo;s see how we can deploy it to a local Ethereum network so we could use it from a front-end app later on."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="Deployment"><meta property="og:description" content="function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); }    \[ \]  Deployment #  Alright, our pool contract is done. Now, let&rsquo;s see how we can deploy it to a local Ethereum network so we could use it from a front-end app later on."><meta property="og:type" content="article"><meta property="og:url" content="https://uniswapv3book.com/docs/milestone_1/deployment/"><meta property="article:section" content="docs"><title>Deployment | Uniswap V3 Book 中文版</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.82c5dbd23447cee0b4c2aa3ed08ce0961faa40e1fa370eee4f8c9f02e0d46b5f.css integrity="sha256-gsXb0jRHzuC0wqo+0Izglh+qQOH6Nw7uT4yfAuDUa18=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.7a6b92274bac2b7305b25d0d3388e16d65529b5eebf7f9ff739fa1f96fb4cf7e.js integrity="sha256-emuSJ0usK3MFsl0NM4jhbWVSm17r9/n/c5+h+W+0z34=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Uniswap V3 Book 中文版</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>Milestone 0. 简介</span><ul><li><a href=/docs/introduction/introduction-to-markets/>交易市场简介</a></li><li><a href=/docs/introduction/constant-function-market-maker/>恒定函数做市商(CFMM)</a></li><li><a href=/docs/introduction/uniswap-v3/>Uniswap V3</a></li><li><a href=/docs/introduction/dev-environment/>Development Environment</a></li></ul></li><li class=book-section-flat><span>Milestone 1. First Swap</span><ul><li><a href=/docs/milestone_1/introduction/>Introduction</a></li><li><a href=/docs/milestone_1/calculating-liquidity/>Calculating Liquidity</a></li><li><a href=/docs/milestone_1/providing-liquidity/>Providing Liquidity</a></li><li><a href=/docs/milestone_1/first-swap/>First Swap</a></li><li><a href=/docs/milestone_1/manager-contract/>Manager Contract</a></li><li><a href=/docs/milestone_1/deployment/ class=active>Deployment</a></li><li><a href=/docs/milestone_1/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 2. Second Swap</span><ul><li><a href=/docs/milestone_2/introduction/>Introduction</a></li><li><a href=/docs/milestone_2/output-amount-calculation/>Output Amount Calculation</a></li><li><a href=/docs/milestone_2/math-in-solidity/>Math in Solidity</a></li><li><a href=/docs/milestone_2/tick-bitmap-index/>Tick Bitmap Index</a></li><li><a href=/docs/milestone_2/generalize-minting/>Generalize Minting</a></li><li><a href=/docs/milestone_2/generalize-swapping/>Generalize Swapping</a></li><li><a href=/docs/milestone_2/quoter-contract/>Quoter Contract</a></li><li><a href=/docs/milestone_2/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 3. Cross-tick Swaps</span><ul><li><a href=/docs/milestone_3/introduction/>Introduction</a></li><li><a href=/docs/milestone_3/different-ranges/>Different Price Ranges</a></li><li><a href=/docs/milestone_3/cross-tick-swaps/>Cross-Tick Swaps</a></li><li><a href=/docs/milestone_3/slippage-protection/>Slippage Protection</a></li><li><a href=/docs/milestone_3/liquidity-calculation/>Liquidity Calculation</a></li><li><a href=/docs/milestone_3/more-on-fixed-point-numbers/>A Little Bit More on Fixed-point Numbers</a></li><li><a href=/docs/milestone_3/flash-loans/>Flash Loans</a></li><li><a href=/docs/milestone_3/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 4. Multi-pool Swaps</span><ul><li><a href=/docs/milestone_4/introduction/>Introduction</a></li><li><a href=/docs/milestone_4/factory-contract/>Factory Contract</a></li><li><a href=/docs/milestone_4/path/>Swap Path</a></li><li><a href=/docs/milestone_4/multi-pool-swaps/>Multi-pool Swaps</a></li><li><a href=/docs/milestone_4/user-interface/>User Interface</a></li><li><a href=/docs/milestone_4/tick-rounding/>Tick Rounding</a></li></ul></li><li class=book-section-flat><span>Milestone 5. Fees and Price Oracle</span><ul><li><a href=/docs/milestone_5/introduction/>Introduction</a></li><li><a href=/docs/milestone_5/swap-fees/>Swap Fees</a></li><li><a href=/docs/milestone_5/flash-loan-fees/>Flash Loan Fees</a></li><li><a href=/docs/milestone_5/protocol-fees/>Protocol Fees</a></li><li><a href=/docs/milestone_5/price-oracle/>Price Oracle</a></li><li><a href=/docs/milestone_5/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 6: NFT positions</span><ul><li><a href=/docs/milestone_6/introduction/>Introduction</a></li><li><a href=/docs/milestone_6/erc721-overview/>ERC721 Overview</a></li><li><a href=/docs/milestone_6/nft-manager/>NFT Manager</a></li><li><a href=/docs/milestone_6/nft-renderer/>NFT Renderer</a></li></ul></li><li class=book-section-flat><span>补充资料</span><ul><li><a href=/docs/reference/dictionary/>中英名词对照</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Deployment</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#deployment>Deployment</a><ul><li><a href=#choosing-local-blockchain-network>Choosing Local Blockchain Network</a></li><li><a href=#running-local-blockchain>Running Local Blockchain</a></li><li><a href=#first-deployment>First Deployment</a></li><li><a href=#interacting-with-contracts-abi>Interacting With Contracts, ABI</a><ul><li><a href=#token-balance>Token Balance</a></li><li><a href=#current-tick-and-price>Current Tick and Price</a></li><li><a href=#abi>ABI</a></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><link rel=stylesheet href=/katex/katex.min.css><script>function renderKatex(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})}</script><script defer src=/katex/katex.min.js></script>
<script defer src=/katex/auto-render.min.js onload=renderKatex(document.body)></script><span>
\[ \]</span><h1 id=deployment>Deployment
<a class=anchor href=#deployment>#</a></h1><p>Alright, our pool contract is done. Now, let&rsquo;s see how we can deploy it to a local Ethereum network so we could use it from
a front-end app later on.</p><h2 id=choosing-local-blockchain-network>Choosing Local Blockchain Network
<a class=anchor href=#choosing-local-blockchain-network>#</a></h2><p>Smart contracts development requires running a local network, where you deploy your contracts during development and
testing. This is what we want from such a network:</p><ol><li>Real blockchain. It must be a real Ethereum network, not an emulation. We want to be sure that our contract will work
in the local network exactly as it would in the mainnet.</li><li>Speed. We want our transactions to be minted immediately, so we could iterate quickly.</li><li>Ether. To pay transaction fees, we need some ether, and we want the local network to allow us to generate any amount
of ether.</li><li>Cheat codes. Besides providing the standard API, we want a local network to allow us to do more. For example, we want
to be able to deploy contracts at any address, execute transactions from any address (impersonate other address), change
contract state directly, etc.</li></ol><p>There are multiple solutions as of today:</p><ol><li><a href=https://trufflesuite.com/ganache/>Ganache</a> from Truffle Suite.</li><li><a href=https://hardhat.org/>Hardhat</a>, which is a development environment that includes a local node besides other useful
things.</li><li><a href=https://github.com/foundry-rs/foundry/tree/master/anvil>Anvil</a> from Foundry.</li></ol><p>All of these are viable solutions and each of them will satisfy our needs. Having said that, projects have been slowly
migrating from Ganache (which is the oldest of the solutions) to Hardhat (which seems to be the most widely used these
days), and now there&rsquo;s the new kid on the block: Foundry. Foundry is also the only of these solutions that uses Solidity
for writing tests (the others use JavaScript). Moreover, Foundry also allows to write deployment scripts in Solidity.
Thus, since we&rsquo;ve decided to use Solidity everywhere, we&rsquo;ll use Anvil to run a local development blockchain, and we&rsquo;ll
write deployment scripts in Solidity.</p><h2 id=running-local-blockchain>Running Local Blockchain
<a class=anchor href=#running-local-blockchain>#</a></h2><p>Anvil doesn&rsquo;t require configuration, we can run it with a single command and it&rsquo;ll do:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ anvil
</span></span><span style=display:flex><span>                             _   _
</span></span><span style=display:flex><span>                            <span style=color:#f92672>(</span>_<span style=color:#f92672>)</span> | |
</span></span><span style=display:flex><span>      __ _   _ __   __   __  _  | |
</span></span><span style=display:flex><span>     / _<span style=color:#e6db74>`</span> | | <span style=color:#960050;background-color:#1e0010>&#39;</span>_ <span style=color:#ae81ff>\ </span> <span style=color:#ae81ff>\ \ </span>/ / | | | |
</span></span><span style=display:flex><span>    | <span style=color:#f92672>(</span>_| | | | | |  <span style=color:#ae81ff>\ </span>V /  | | | |
</span></span><span style=display:flex><span>     <span style=color:#ae81ff>\_</span>_,_| |_| |_|   <span style=color:#ae81ff>\_</span>/   |_| |_|
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    0.1.0 <span style=color:#f92672>(</span>d89f6af 2022-06-24T00:15:17.897682Z<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    https://github.com/foundry-rs/foundry
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>Listening on 127.0.0.1:8545
</span></span></code></pre></div><p>Anvil runs a single Ethereum node, so this is not really a network, but that&rsquo;s ok. By default, it creates 10 accounts
with 10,000 ETH in each of them. It prints the addresses and related private keys when it starts–we&rsquo;ll be using one of
these addresses when deploying and interacting with the contract from UI.</p><p>Anvil exposes JSON-RPC API interface at <code>127.0.0.1:8545</code>–this interface is the main way of interacting with Ethereum
nodes. You can find full API reference <a href=https://ethereum.org/en/developers/docs/apis/json-rpc/>here</a>. And this is how
you can call it via <code>curl</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ curl -X POST -H <span style=color:#e6db74>&#39;Content-Type: application/json&#39;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  --data <span style=color:#e6db74>&#39;{&#34;id&#34;:1,&#34;jsonrpc&#34;:&#34;2.0&#34;,&#34;method&#34;:&#34;eth_chainId&#34;}&#39;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  http://127.0.0.1:8545
</span></span><span style=display:flex><span><span style=color:#f92672>{</span><span style=color:#e6db74>&#34;jsonrpc&#34;</span>:<span style=color:#e6db74>&#34;2.0&#34;</span>,<span style=color:#e6db74>&#34;id&#34;</span>:1,<span style=color:#e6db74>&#34;result&#34;</span>:<span style=color:#e6db74>&#34;0x7a69&#34;</span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>$ curl -X POST -H <span style=color:#e6db74>&#39;Content-Type: application/json&#39;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  --data <span style=color:#e6db74>&#39;{&#34;id&#34;:1,&#34;jsonrpc&#34;:&#34;2.0&#34;,&#34;method&#34;:&#34;eth_getBalance&#34;,&#34;params&#34;:[&#34;0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266&#34;,&#34;latest&#34;]}&#39;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  http://127.0.0.1:8545
</span></span><span style=display:flex><span><span style=color:#f92672>{</span><span style=color:#e6db74>&#34;jsonrpc&#34;</span>:<span style=color:#e6db74>&#34;2.0&#34;</span>,<span style=color:#e6db74>&#34;id&#34;</span>:1,<span style=color:#e6db74>&#34;result&#34;</span>:<span style=color:#e6db74>&#34;0x21e19e0c9bab2400000&#34;</span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>You can also use <code>cast</code> (part of Foundry) for that:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cast chain-id
</span></span><span style=display:flex><span><span style=color:#ae81ff>31337</span>
</span></span><span style=display:flex><span>$ cast balance 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266
</span></span><span style=display:flex><span><span style=color:#ae81ff>10000000000000000000000</span>
</span></span></code></pre></div><p>Now, let&rsquo;s deploy the pool and manager contracts to the local network.</p><h2 id=first-deployment>First Deployment
<a class=anchor href=#first-deployment>#</a></h2><p>At its core, deploying a contract means:</p><ol><li>Compiling source code into EVM bytecode.</li><li>Sending a transaction with the bytecode.</li><li>Creating a new address, executing the constructor part of the bytecode, storing initialized bytecode on the address.
This step is done automatically by an Ethereum node, when your contract creation transaction is mined.</li></ol><p>Deployment usually consists of multiple steps: preparing parameters, deploying auxiliary contracts, deploying main
contracts, initializing contracts, etc. Scripting helps to automate these steps, and we&rsquo;ll write scripts in Solidity!</p><p>Create <code>scripts/DeployDevelopment.sol</code> contract with this content:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#75715e>// SPDX-License-Identifier: UNLICENSED
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>pragma solidity</span> <span style=color:#f92672>^</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>8</span>.<span style=color:#ae81ff>14</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;forge-std/Script.sol&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>contract</span> <span style=color:#a6e22e>DeployDevelopment</span> <span style=color:#66d9ef>is</span> Script {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>run</span>() <span style=color:#66d9ef>public</span> {
</span></span><span style=display:flex><span>      ...
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It looks very similar to the test contract, with only difference is that it inherits from <code>Script</code> contract, not from
<code>Test</code>. And, by convention, we need to define <code>run</code> function which will be the body of our deployment script. In the
<code>run</code> function, we define the parameters of the deployment first:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>uint256</span> wethBalance <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>ether</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>uint256</span> usdcBalance <span style=color:#f92672>=</span> <span style=color:#ae81ff>5042</span> <span style=color:#66d9ef>ether</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int24</span> currentTick <span style=color:#f92672>=</span> <span style=color:#ae81ff>85176</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>uint160</span> currentSqrtP <span style=color:#f92672>=</span> <span style=color:#ae81ff>5602277097478614198912276234240</span>;
</span></span></code></pre></div><p>These are the same values we used before. Notice that we&rsquo;re about to mint 5042 USDC–that&rsquo;s 5000 USDC we&rsquo;ll provide as
liquidity into the pool and 42 USDC we&rsquo;ll sell in a swap.</p><p>Next, we define the set of steps that will be executed as the deployment transaction (well, each of the steps will be
a separate transaction). For this, we&rsquo;re using <code>startBroadcast/endBroadcast</code> cheat codes:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>vm.startBroadcast();
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>vm.stopBroadcast();
</span></span></code></pre></div><blockquote><p>These cheat codes are <a href=https://github.com/foundry-rs/foundry/tree/master/forge#cheat-codes>provided by of Foundry</a>.
We got them in the script contract by inheriting from <code>forge-std/Script.sol</code>.</p></blockquote><p>Everything that goes after the <code>broadcast()</code> cheat code or between <code>startBroadcast()/stopBroadcast()</code> is converted to
transactions and these transactions are sent to the node that executes the script.</p><p>Between the broadcast cheat codes, we&rsquo;ll put the actual deployment steps. First, we need to deploy the tokens:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>ERC20Mintable token0 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ERC20Mintable(<span style=color:#e6db74>&#34;Wrapped Ether&#34;</span>, <span style=color:#e6db74>&#34;WETH&#34;</span>, <span style=color:#ae81ff>18</span>);
</span></span><span style=display:flex><span>ERC20Mintable token1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ERC20Mintable(<span style=color:#e6db74>&#34;USD Coin&#34;</span>, <span style=color:#e6db74>&#34;USDC&#34;</span>, <span style=color:#ae81ff>18</span>);
</span></span></code></pre></div><p>We cannot deploy the pool without having tokens, so we need to deploy them first.</p><blockquote><p>Since we&rsquo;re deploying to a local development network, we need to deploy the tokens ourselves. In the mainnet and public
test networks (Ropsten, Goerli, Sepolia), the tokens are already created. Thus, to deploy to those networks, we&rsquo;ll need
to write network-specific deployment scripts.</p></blockquote><p>The next step is to deploy the pool contract:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>UniswapV3Pool pool <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> UniswapV3Pool(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>address</span>(token0),
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>address</span>(token1),
</span></span><span style=display:flex><span>    currentSqrtP,
</span></span><span style=display:flex><span>    currentTick
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>Next goes Manager contract deployment:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>UniswapV3Manager manager <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> UniswapV3Manager();
</span></span></code></pre></div><p>And finally, we can mint some amount of ETH and USDC to our address:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>token0.mint(msg.sender, wethBalance);
</span></span><span style=display:flex><span>token1.mint(msg.sender, usdcBalance);
</span></span></code></pre></div><blockquote><p><code>msg.sender</code> in Foundry scripts is the address that sends transactions within the <code>broadcast</code> block. We&rsquo;ll be able to
set it when running scripts.</p></blockquote><p>Finally, at the end of the script, add some <code>console.log</code> calls to print the addresses of deployed contracts:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>console.log(<span style=color:#e6db74>&#34;WETH address&#34;</span>, <span style=color:#66d9ef>address</span>(token0));
</span></span><span style=display:flex><span>console.log(<span style=color:#e6db74>&#34;USDC address&#34;</span>, <span style=color:#66d9ef>address</span>(token1));
</span></span><span style=display:flex><span>console.log(<span style=color:#e6db74>&#34;Pool address&#34;</span>, <span style=color:#66d9ef>address</span>(pool));
</span></span><span style=display:flex><span>console.log(<span style=color:#e6db74>&#34;Manager address&#34;</span>, <span style=color:#66d9ef>address</span>(manager));
</span></span></code></pre></div><p>Alright, let&rsquo;s run the script (ensure Anvil is running in another terminal window):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ forge script scripts/DeployDevelopment.s.sol --broadcast --fork-url http://localhost:8545 --private-key $PRIVATE_KEY
</span></span></code></pre></div><p><code>--broadcast</code> enables broadcasting of transactions. It&rsquo;s not enabled by default because not every script sends
transactions. <code>--fork-url</code> sets the address of the node to send transactions to. <code>--private-key</code> sets the sender wallet:
a private key is needed to sign transactions. You can pick any of the private keys printed by Anvil when it&rsquo;s starting.
I took the first one:</p><blockquote><p>0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80</p></blockquote><p>Deployment takes several seconds. In the end, you&rsquo;ll see a list of transactions it sent. It&rsquo;ll also save transactions
receipts to <code>broadcast</code> folder. In Anvil, you&rsquo;ll also see many lines with <code>eth_sendRawTransaction</code>, <code>eth_getTransactionByHash</code>,
and <code>eth_getTransactionReceipt</code>–after sending transactions to Anvil, Forge uses the JSON-RPC API to check their status
and get transaction execution results (receipts).</p><p>Congratulations! You&rsquo;ve just deployed a smart contract!</p><h2 id=interacting-with-contracts-abi>Interacting With Contracts, ABI
<a class=anchor href=#interacting-with-contracts-abi>#</a></h2><p>Now, let&rsquo;s see how we can interact with the deployed contracts.</p><p>Every contract exposes a set of public functions. In the case of the pool contract, these are <code>mint(...)</code> and <code>swap(...)</code>.
Additionally, Solidity creates getters for public variables, so we can also call <code>token0()</code>, <code>token1()</code>, <code>positions()</code>, etc.
However, since contracts are compiled bytecodes, <strong>function names are lost during compilation and not stored on
blockchain</strong>. Instead, every function is identified by a selector, which is the first 4 bytes of the hash of the
signature of the function. In pseudocode:</p><pre tabindex=0><code>hash(&#34;transfer(address,address,uint256)&#34;)[0:4]
</code></pre><blockquote><p>EVM uses <a href=https://en.wikipedia.org/wiki/SHA-3>the Keccak hashing algorithm</a>, which was standardized as SHA-3.
Specifically, the hashing function in Solidity is <code>keccak256</code>.</p></blockquote><p>Knowing this, let&rsquo;s make two calls to the deployed contracts: one will be a low-level call via <code>curl</code>, and one will be
made using <code>cast</code>.</p><h3 id=token-balance>Token Balance
<a class=anchor href=#token-balance>#</a></h3><p>Let&rsquo;s check the WETH balance of the deployer address. The signature of the function is <code>balanceOf(address)</code> (as defined
in <a href=https://eips.ethereum.org/EIPS/eip-20>ERC-20</a>). To find the
ID of this function (its selector), we&rsquo;ll hash it and take the first four bytes:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cast keccak <span style=color:#e6db74>&#34;balanceOf(address)&#34;</span>| cut -b 1-10
</span></span><span style=display:flex><span>0x70a08231
</span></span></code></pre></div><p>To pass the address, we simply append it to the function selector (and add left padding up to 32 digits since addresses
take 32 bytes in function call data):</p><blockquote><p>0x70a08231000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266</p></blockquote><p><code>0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266</code> is the address we&rsquo;re going to check balance of. This is our address, the first
account in Anvil.</p><p>Next, we execute <code>eth_call</code> JSON-RPC method to make the call. Notice that this doesn&rsquo;t require sending a transaction–this
endpoint is used to read data from contracts.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ params<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;{&#34;from&#34;:&#34;0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266&#34;,&#34;to&#34;:&#34;0xe7f1725e7734ce288f8367e1bb143e90bb3f0512&#34;,&#34;data&#34;:&#34;0x70a08231000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266&#34;}&#39;</span>
</span></span><span style=display:flex><span>$ curl -X POST -H <span style=color:#e6db74>&#39;Content-Type: application/json&#39;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  --data <span style=color:#e6db74>&#39;{&#34;id&#34;:1,&#34;jsonrpc&#34;:&#34;2.0&#34;,&#34;method&#34;:&#34;eth_call&#34;,&#34;params&#34;:[&#39;</span><span style=color:#e6db74>&#34;</span>$params<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>&#39;,&#34;latest&#34;]}&#39;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  http://127.0.0.1:8545
</span></span><span style=display:flex><span><span style=color:#f92672>{</span><span style=color:#e6db74>&#34;jsonrpc&#34;</span>:<span style=color:#e6db74>&#34;2.0&#34;</span>,<span style=color:#e6db74>&#34;id&#34;</span>:1,<span style=color:#e6db74>&#34;result&#34;</span>:<span style=color:#e6db74>&#34;0x00000000000000000000000000000000000000000000011153ce5e56cf880000&#34;</span><span style=color:#f92672>}</span>
</span></span></code></pre></div><blockquote><p>The &ldquo;to&rdquo; address is the USDC token. It&rsquo;s printed by the deployment script and it can be different in your case.</p></blockquote><p>Ethereum nodes return results as raw bytes, to parse them we need to know the type of a returned value. In the case of
<code>balanceOf</code> function, the type of a returned value is <code>uint256</code>. Using <code>cast</code>, we can convert it to a decimal number and
then convert it to ethers:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cast --to-dec 0x00000000000000000000000000000000000000000000011153ce5e56cf880000| cast --from-wei
</span></span><span style=display:flex><span>5042.000000000000000000
</span></span></code></pre></div><p>The balance is correct! We minted 42 USDC to our address.</p><h3 id=current-tick-and-price>Current Tick and Price
<a class=anchor href=#current-tick-and-price>#</a></h3><p>The above example is a demonstration of low-level contract calls. Usually, you never do calls via <code>curl</code> and use a tool
or library that makes it easier. And Cast can help us here again!</p><p>Let&rsquo;s get the current price and tick of a pool using <code>cast</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cast call POOL_ADDRESS <span style=color:#e6db74>&#34;slot0()&#34;</span>| xargs cast --abi-decode <span style=color:#e6db74>&#34;a()(uint160,int24)&#34;</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>5602277097478614198912276234240</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>85176</span>
</span></span></code></pre></div><p>Nice! The first value is the current $\sqrt{P}$ and the second value is the current tick.</p><blockquote><p>Since <code>--abi-decode</code> requires full function signature we have to specify &ldquo;a()&rdquo; even though we only want to decode
function output.</p></blockquote><h3 id=abi>ABI
<a class=anchor href=#abi>#</a></h3><p>To simplify interaction with contracts, Solidity compiler can output ABI, Application Binary Interface.</p><p>ABI is a JSON file that contains the description of all public methods and events of a contract. The goal of this file
is to make it easier to encode function parameters and decode return values. To get ABI with Forge, use this command:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ forge inspect UniswapV3Pool abi
</span></span></code></pre></div><p>Feel free skimming through the file to better understand its content.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#deployment>Deployment</a><ul><li><a href=#choosing-local-blockchain-network>Choosing Local Blockchain Network</a></li><li><a href=#running-local-blockchain>Running Local Blockchain</a></li><li><a href=#first-deployment>First Deployment</a></li><li><a href=#interacting-with-contracts-abi>Interacting With Contracts, ABI</a><ul><li><a href=#token-balance>Token Balance</a></li><li><a href=#current-tick-and-price>Current Tick and Price</a></li><li><a href=#abi>ABI</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>