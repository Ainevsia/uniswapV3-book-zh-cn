<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); }    \[ \]  Calculating liquidity #  Trading is not possible without liquidity, and to make our first swap we need to put some liquidity into the pool contract."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="Calculating Liquidity"><meta property="og:description" content="function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); }    \[ \]  Calculating liquidity #  Trading is not possible without liquidity, and to make our first swap we need to put some liquidity into the pool contract."><meta property="og:type" content="article"><meta property="og:url" content="https://uniswapv3book.com/docs/milestone_1/calculating-liquidity/"><meta property="article:section" content="docs"><title>Calculating Liquidity | Uniswap V3 Development Book</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.82c5dbd23447cee0b4c2aa3ed08ce0961faa40e1fa370eee4f8c9f02e0d46b5f.css integrity="sha256-gsXb0jRHzuC0wqo+0Izglh+qQOH6Nw7uT4yfAuDUa18=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.7dd8482a2abd0a6221fb6f55b03476359d038ce11f0b41e2a8fe6393d9118928.js integrity="sha256-fdhIKiq9CmIh+29VsDR2NZ0DjOEfC0HiqP5jk9kRiSg=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Uniswap V3 Development Book</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>Milestone 0. Introduction</span><ul><li><a href=/docs/introduction/introduction-to-markets/>Introduction to markets</a></li><li><a href=/docs/introduction/constant-function-market-maker/>Constant Function Market Makers</a></li><li><a href=/docs/introduction/uniswap-v3/>Uniswap V3</a></li><li><a href=/docs/introduction/dev-environment/>Development Environment</a></li></ul></li><li class=book-section-flat><span>Milestone 1. First Swap</span><ul><li><a href=/docs/milestone_1/introduction/>Introduction</a></li><li><a href=/docs/milestone_1/calculating-liquidity/ class=active>Calculating Liquidity</a></li><li><a href=/docs/milestone_1/providing-liquidity/>Providing Liquidity</a></li><li><a href=/docs/milestone_1/first-swap/>First Swap</a></li><li><a href=/docs/milestone_1/manager-contract/>Manager Contract</a></li><li><a href=/docs/milestone_1/deployment/>Deployment</a></li><li><a href=/docs/milestone_1/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 2. Second Swap</span><ul><li><a href=/docs/milestone_2/introduction/>Introduction</a></li><li><a href=/docs/milestone_2/output-amount-calculation/>Output Amount Calculation</a></li><li><a href=/docs/milestone_2/math-in-solidity/>Math in Solidity</a></li><li><a href=/docs/milestone_2/tick-bitmap-index/>Tick Bitmap Index</a></li><li><a href=/docs/milestone_2/generalize-minting/>Generalize Minting</a></li><li><a href=/docs/milestone_2/generalize-swapping/>Generalize Swapping</a></li><li><a href=/docs/milestone_2/quoter-contract/>Quoter Contract</a></li><li><a href=/docs/milestone_2/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 3. Cross-tick Swaps</span><ul><li><a href=/docs/milestone_3/introduction/>Introduction</a></li><li><a href=/docs/milestone_3/different-ranges/>Different Price Ranges</a></li><li><a href=/docs/milestone_3/cross-tick-swaps/>Cross-Tick Swaps</a></li><li><a href=/docs/milestone_3/slippage-protection/>Slippage Protection</a></li><li><a href=/docs/milestone_3/liquidity-calculation/>Liquidity Calculation</a></li><li><a href=/docs/milestone_3/more-on-fixed-point-numbers/>A Little Bit More on Fixed-point Numbers</a></li><li><a href=/docs/milestone_3/flash-loans/>Flash Loans</a></li><li><a href=/docs/milestone_3/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 4. Multi-pool Swaps</span><ul><li><a href=/docs/milestone_4/introduction/>Introduction</a></li><li><a href=/docs/milestone_4/factory-contract/>Factory Contract</a></li><li><a href=/docs/milestone_4/path/>Swap Path</a></li><li><a href=/docs/milestone_4/multi-pool-swaps/>Multi-pool Swaps</a></li><li><a href=/docs/milestone_4/user-interface/>User Interface</a></li><li><a href=/docs/milestone_4/tick-rounding/>Tick Rounding</a></li></ul></li><li class=book-section-flat><span>Milestone 5. Fees and Price Oracle</span><ul><li><a href=/docs/milestone_5/introduction/>Introduction</a></li><li><a href=/docs/milestone_5/swap-fees/>Swap Fees</a></li><li><a href=/docs/milestone_5/flash-loan-fees/>Flash Loan Fees</a></li><li><a href=/docs/milestone_5/protocol-fees/>Protocol Fees</a></li><li><a href=/docs/milestone_5/price-oracle/>Price Oracle</a></li><li><a href=/docs/milestone_5/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 6: NFT positions</span><ul><li><a href=/docs/milestone_6/introduction/>Introduction</a></li><li><a href=/docs/milestone_6/erc721-overview/>ERC721 Overview</a></li><li><a href=/docs/milestone_6/nft-manager/>NFT Manager</a></li><li><a href=/docs/milestone_6/nft-renderer/>NFT Renderer</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Calculating Liquidity</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#calculating-liquidity>Calculating liquidity</a><ul><li><a href=#price-range-calculation>Price Range Calculation</a></li><li><a href=#token-amounts-calculation>Token Amounts Calculation</a></li><li><a href=#liquidity-amount-calculation>Liquidity Amount Calculation</a></li><li><a href=#token-amounts-calculation-again>Token Amounts Calculation, Again</a></li></ul></li></ul></nav></aside></header><article class=markdown><link rel=stylesheet href=/katex/katex.min.css><script>function renderKatex(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})}</script><script defer src=/katex/katex.min.js></script>
<script defer src=/katex/auto-render.min.js onload=renderKatex(document.body)></script><span>
\[ \]</span><h1 id=calculating-liquidity>Calculating liquidity
<a class=anchor href=#calculating-liquidity>#</a></h1><p>Trading is not possible without liquidity, and to make our first swap we need to put some liquidity into the pool contract.
Here&rsquo;s what we need to know to add liquidity to the pool contract:</p><ol><li>A price range. As a liquidity provider, we want to provide liquidity at a specific price range, and it&rsquo;ll only be used
in this range.</li><li>Amount of liquidity, which is the amounts of two tokens. We&rsquo;ll need to transfer these amounts to the pool contract.</li></ol><p>Here, we&rsquo;re going to calculate these manually, but, in a later chapter, a contract will do this for us. Let&rsquo;s begin with
a price range.</p><h2 id=price-range-calculation>Price Range Calculation
<a class=anchor href=#price-range-calculation>#</a></h2><p>Recall that, in Uniswap V3, the entire price range is demaracted into ticks: each tick corresponds to a price and has
an index. In our first pool implementation, we&rsquo;re going to buy ETH for USDC at the price of <span>$5000</span> per 1 ETH.
Buying ETH will remove some amount of it from the pool and will push the price slightly above <span>$5000</span>.
We want to provide liquidity at a range that includes this price. And we want to be sure that the final price will stay
<strong>within this range</strong> (we&rsquo;ll do multi-range swaps in a later milestone).</p><p>We&rsquo;ll need to find three ticks:</p><ol><li>The current tick will correspond to the current price (5000 USDC for 1 ETH).</li><li>The lower and upper bounds of the price range we&rsquo;re providing liquidity into. Let the lower price be <span>$4545</span>
and the upper price be <span>$5500</span>.</li></ol><p>From the theoretical introduction we know that:</p><p>$$\sqrt{P} = \sqrt{\frac{y}{x}}$$</p><p>Since we&rsquo;ve agreed to use ETH as the $x$ reserve and USDC as the $y$ reserve, the prices at each of the ticks are:</p><p>$$\sqrt{P_c} = \sqrt{\frac{5000}{1}} = \sqrt{5000} \approx 70.71$$</p><p>$$\sqrt{P_l} = \sqrt{\frac{4545}{1}} \approx 67.42$$</p><p>$$\sqrt{P_u} = \sqrt{\frac{5500}{1}} \approx 74.16$$</p><p>Where $P_c$ is the current price, $P_l$ is the lower bound of the range, $P_u$ is the upper bound of the range.</p><p>Now, we can find corresponding ticks. We know that prices and ticks are connected via this formula:</p><p>$$\sqrt{P(i)}=1.0001^{\frac{i}{2}}$$</p><p>Thus, we can find tick $i$ via:</p><p>$$i = log_{\sqrt{1.0001}} \sqrt{P(i)}$$</p><blockquote><p>The square roots in this formula cancel out, but since we&rsquo;re working with $\sqrt{p}$ we need to preserve them.</p></blockquote><p>Let&rsquo;s find the ticks:</p><ol><li>Current tick: $i_c = log_{\sqrt{1.0001}} 70.71 = 85176$</li><li>Lower tick: $i_l = log_{\sqrt{1.0001}} 67.42 = 84222$</li><li>Upper tick: $i_u = log_{\sqrt{1.0001}} 74.16 = 86129$</li></ol><blockquote><p>To calculate these, I used Python:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> math
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>price_to_tick</span>(p):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> math<span style=color:#f92672>.</span>floor(math<span style=color:#f92672>.</span>log(p, <span style=color:#ae81ff>1.0001</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>price_to_tick(<span style=color:#ae81ff>5000</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>85176</span>
</span></span></code></pre></div></blockquote><p>That&rsquo;s it for price range calculation!</p><p>Last thing to note here is that Uniswap uses Q64.96 number to store $\sqrt{P}$. This is a fixed point number that has
64 bits for the integer part and 96 bits for the fractional part. In our above calculations, prices are floating point
numbers: <code>70.71</code>, <code>67.42</code>, <code>74.16</code>. We need to convert them to Q64.96. Luckily, this is simple: we need to multiply the
numbers by the maximum value of the fractional part of Q64.96, which is $2^{96}$. We&rsquo;ll get:</p><p>$$\sqrt{P_c} = 5602277097478614198912276234240$$</p><p>$$\sqrt{P_l} = 5314786713428871004159001755648$$</p><p>$$\sqrt{P_u} = 5875717789736564987741329162240$$</p><blockquote><p>In Python:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>q96 <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>**</span><span style=color:#ae81ff>96</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>price_to_sqrtp</span>(p):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> int(math<span style=color:#f92672>.</span>sqrt(p) <span style=color:#f92672>*</span> q96)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>price_to_sqrtp(<span style=color:#ae81ff>5000</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>5602277097478614198912276234240</span>
</span></span></code></pre></div><p>Notice that we&rsquo;re multiplying before converting to integer. Otherwise, we&rsquo;ll lose precision.</p></blockquote><h2 id=token-amounts-calculation>Token Amounts Calculation
<a class=anchor href=#token-amounts-calculation>#</a></h2><p>Next step is to decide how many tokens we want to deposit into the pool. The answer is: as many as we want. The amounts
are not strictly defined, we can deposit as much as it is enough to buy a small amount of ETH without making the current
price leave the price range we put liquidity into. During development and testing we&rsquo;ll be able to mint any amount of tokens,
so getting the amounts we want is not a problem.</p><p>For our first swap, let&rsquo;s deposit 1 ETH and 5000 USDC.</p><blockquote><p>Recall that the proportion of current pool reserves tells the current spot price. So if we want to put more tokens into
the pool and keep the same price, the amounts must be proportional, e.g.: 2 ETH and 10,000 USDC; 10 ETH and 500,000 USDC, etc.</p></blockquote><h2 id=liquidity-amount-calculation>Liquidity Amount Calculation
<a class=anchor href=#liquidity-amount-calculation>#</a></h2><p>Next, we need to calculate $L$ based on the amounts we&rsquo;ll deposit. This is a tricky part, so hold tight!</p><p>From the theoretical introduction, you remember that:
$$L = \sqrt{xy}$$</p><p>However, this formula is for the infinite curve 🙂 But we want to put liquidity into a limited price range, which is just
a segment of that infinite curve. We need to calculate $L$ specifically for the price range we&rsquo;re going to deposit liquidity
into. We need some more advanced calculations.</p><p>To calculate $L$ for a price range, let&rsquo;s look at one interesting fact we have discussed earlier: price ranges can be
depleted. It&rsquo;s absolutely possible to buy the entire amount of one token from a price range and leave the pool with only
the other token.</p><p><img src=/images/milestone_1/range_depleted.png alt="Range depletion example"></p><p>At the points $a$ and $b$, there&rsquo;s only one token in the range: ETH at the point $a$ and USDC at the point $b$.</p><p>That being said, we want to find an $L$ that will allow the price to move to either of the points. We want enough
liquidity for the price to reach either of the boundaries of a price range. Thus, we want $L$ to be calculated based on
the maximum amounts of $\Delta x$ and $\Delta y$.</p><p>Now, let&rsquo;s see what the prices are at the edges. When ETH is bought from a pool, the price is growing; when USDC is bought,
the price is falling. Recall that the price is $\frac{y}{x}$. So, at the point $a$, the price is lowest of the range;
at the point $b$, the price is highest.</p><blockquote><p>In fact, prices are not defined at these points because there&rsquo;s only one reserve in the pool, but what we need to
understand here is that the price around the point $b$ is higher than the start price, and the price at the point $a$ is
lower than the start price.</p></blockquote><p>Now, break the curve from the image above into two segments: one to the left of the start point and one to the right of
the start point. We&rsquo;re going to calculate <strong>two</strong> $L$&rsquo;s, one for each of the segments. Why? Because each of the two
tokens of a pool contributes to <strong>either of the segments</strong>. And since we want to distribute liquidity evenly along the
entire curve, we want to pick the minimal of the two $L$&rsquo;s.</p><p><img src=/images/milestone_1/curve_liquidity.png alt="Liquidity on the curve"></p><p>And the final detail I need to focus your attention on here is: <strong>new liquidity must not change the current price</strong>. That
is, it must be proportional to the current proportion of the reserves. And this is why the two $L$&rsquo;s can be different–when
the proportion is not preserved. And we pick the small $L$ to reestablish the proportion.</p><p>I hope this will make more sense after we implement this in code! Now, let&rsquo;s look at the formulas.</p><p>Let&rsquo;s recall how $\Delta x$ and $\Delta y$ are calculated:</p><p>$$\Delta x = \Delta \frac{1}{\sqrt{P}} L$$
$$\Delta y = \Delta \sqrt{P} L$$</p><p>We can expands these formulas by replacing the delta P&rsquo;s with actual prices (we know them from the above):</p><p>$$\Delta x = (\frac{1}{\sqrt{P_b}} - \frac{1}{\sqrt{P_c}}) L$$
$$\Delta y = (\sqrt{P_c} - \sqrt{P_a}) L$$</p><p>$P_a$ is the price at the point $a$, $P_b$ is the price at the point $b$, and $P_c$ is the current price.</p><p>Let&rsquo;s find the $L$ from the first formula:</p><p>$$\Delta x = (\frac{1}{\sqrt{P_b}} - \frac{1}{\sqrt{P_c}}) L$$
$$\Delta x = \frac{L}{\sqrt{P_b}} - \frac{L}{\sqrt{P_c}}$$
$$\Delta x = \frac{L(\sqrt{P_b} - \sqrt{P_c})}{\sqrt{P_b} \sqrt{P_c}}$$
$$L = \Delta x \frac{\sqrt{P_b} \sqrt{P_c}}{\sqrt{P_b} - \sqrt{P_c}}$$</p><p>And from the second formula:
$$\Delta y = (\sqrt{P_c} - \sqrt{P_a}) L$$
$$L = \frac{\Delta y}{\sqrt{P_c} - \sqrt{P_a}}$$</p><p>So, these are our two $L$&rsquo;s, one for each of the segments:</p><p>$$L = \Delta x \frac{\sqrt{P_b} \sqrt{P_c}}{\sqrt{P_b} - \sqrt{P_c}}$$
$$L = \frac{\Delta y}{\sqrt{P_c} - \sqrt{P_a}}$$</p><p>Now, let&rsquo;s plug the prices we calculated earlier into them:</p><p>$$L = \Delta x \frac{\sqrt{P_b}\sqrt{P_c}}{\sqrt{P_b}-\sqrt{P_c}} = 1 ETH * \frac{67.42 * 70.71}{70.71 - 67.42}$$
After converting to Q64.96, we get:</p><p>$$L = 1519437308014769733632$$</p><p>And for the other $L$:
$$L = \frac{\Delta y}{\sqrt{P_c}-\sqrt{P_a}} = \frac{5000USDC}{74.16-70.71}$$
$$L = 1517882343751509868544$$</p><p>Of these two, we&rsquo;ll pick the smaller one.</p><blockquote><p>In Python:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>sqrtp_low <span style=color:#f92672>=</span> price_to_sqrtp(<span style=color:#ae81ff>4545</span>)
</span></span><span style=display:flex><span>sqrtp_cur <span style=color:#f92672>=</span> price_to_sqrtp(<span style=color:#ae81ff>5000</span>)
</span></span><span style=display:flex><span>sqrtp_upp <span style=color:#f92672>=</span> price_to_sqrtp(<span style=color:#ae81ff>5500</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>liquidity0</span>(amount, pa, pb):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> pa <span style=color:#f92672>&gt;</span> pb:
</span></span><span style=display:flex><span>        pa, pb <span style=color:#f92672>=</span> pb, pa
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (amount <span style=color:#f92672>*</span> (pa <span style=color:#f92672>*</span> pb) <span style=color:#f92672>/</span> q96) <span style=color:#f92672>/</span> (pb <span style=color:#f92672>-</span> pa)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>liquidity1</span>(amount, pa, pb):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> pa <span style=color:#f92672>&gt;</span> pb:
</span></span><span style=display:flex><span>        pa, pb <span style=color:#f92672>=</span> pb, pa
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> amount <span style=color:#f92672>*</span> q96 <span style=color:#f92672>/</span> (pb <span style=color:#f92672>-</span> pa)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>liq0 <span style=color:#f92672>=</span> liquidity0(amount_eth, sqrtp_cur, sqrtp_upp)
</span></span><span style=display:flex><span>liq1 <span style=color:#f92672>=</span> liquidity1(amount_usdc, sqrtp_cur, sqrtp_low)
</span></span><span style=display:flex><span>liq <span style=color:#f92672>=</span> int(min(liq0, liq1))
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1517882343751509868544</span>
</span></span></code></pre></div></blockquote><h2 id=token-amounts-calculation-again>Token Amounts Calculation, Again
<a class=anchor href=#token-amounts-calculation-again>#</a></h2><p>Since we choose the amounts we&rsquo;re going to deposit, the amounts can be wrong. We cannot deposit any amounts at any price
ranges; liquidity amount needs to be distributed evenly along the curve of the price range we&rsquo;re depositing into. Thus, even
though users choose amounts, the contract needs to re-calculate them, and actual amounts will be slightly different (at
least because of rounding).</p><p>Luckily, we already know the formulas:</p><p>$$\Delta x = \frac{L(\sqrt{P_b} - \sqrt{P_c})}{\sqrt{P_b} \sqrt{P_c}}$$
$$\Delta y = L(\sqrt{P_c} - \sqrt{P_a})$$</p><blockquote><p>In Python:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>calc_amount0</span>(liq, pa, pb):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> pa <span style=color:#f92672>&gt;</span> pb:
</span></span><span style=display:flex><span>        pa, pb <span style=color:#f92672>=</span> pb, pa
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> int(liq <span style=color:#f92672>*</span> q96 <span style=color:#f92672>*</span> (pb <span style=color:#f92672>-</span> pa) <span style=color:#f92672>/</span> pa <span style=color:#f92672>/</span> pb)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>calc_amount1</span>(liq, pa, pb):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> pa <span style=color:#f92672>&gt;</span> pb:
</span></span><span style=display:flex><span>        pa, pb <span style=color:#f92672>=</span> pb, pa
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> int(liq <span style=color:#f92672>*</span> (pb <span style=color:#f92672>-</span> pa) <span style=color:#f92672>/</span> q96)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>amount0 <span style=color:#f92672>=</span> calc_amount0(liq, sqrtp_upp, sqrtp_cur)
</span></span><span style=display:flex><span>amount1 <span style=color:#f92672>=</span> calc_amount1(liq, sqrtp_low, sqrtp_cur)
</span></span><span style=display:flex><span>(amount0, amount1)
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;</span> (<span style=color:#ae81ff>998976618347425408</span>, <span style=color:#ae81ff>5000000000000000000000</span>)
</span></span></code></pre></div><p>As you can see, the number are close to the amounts we want to provide, but ETH is slightly smaller.</p></blockquote><blockquote><p><strong>Hint</strong>: use <code>cast --from-wei AMOUNT</code> to convert from wei to ether, e.g.:<br><code>cast --from-wei 998976618347425280</code> will give you <code>0.998976618347425280</code>.</p></blockquote></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#calculating-liquidity>Calculating liquidity</a><ul><li><a href=#price-range-calculation>Price Range Calculation</a></li><li><a href=#token-amounts-calculation>Token Amounts Calculation</a></li><li><a href=#liquidity-amount-calculation>Liquidity Amount Calculation</a></li><li><a href=#token-amounts-calculation-again>Token Amounts Calculation, Again</a></li></ul></li></ul></nav></div></aside></main></body></html>