<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); }    \[ \]  Providing Liquidity #  Enough of theory, let&rsquo;s start coding!
Create a new folder (mine is called uniswapv3-code), and run forge init --vscode in it–this will initialize a Forge project."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="Providing Liquidity"><meta property="og:description" content="function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); }    \[ \]  Providing Liquidity #  Enough of theory, let&rsquo;s start coding!
Create a new folder (mine is called uniswapv3-code), and run forge init --vscode in it–this will initialize a Forge project."><meta property="og:type" content="article"><meta property="og:url" content="https://uniswapv3book.com/docs/milestone_1/providing-liquidity/"><meta property="article:section" content="docs"><title>Providing Liquidity | Uniswap V3 Book 中文版</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.82c5dbd23447cee0b4c2aa3ed08ce0961faa40e1fa370eee4f8c9f02e0d46b5f.css integrity="sha256-gsXb0jRHzuC0wqo+0Izglh+qQOH6Nw7uT4yfAuDUa18=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.d6d681726de96ede9e63fe231234d265e4c7c58fdfe525c8c321a5f740071758.js integrity="sha256-1taBcm3pbt6eY/4jEjTSZeTHxY/f5SXIwyGl90AHF1g=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Uniswap V3 Book 中文版</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>Milestone 0. 简介</span><ul><li><a href=/docs/introduction/introduction-to-markets/>交易市场简介</a></li><li><a href=/docs/introduction/constant-function-market-maker/>恒定函数做市商(CFMM)</a></li><li><a href=/docs/introduction/uniswap-v3/>Uniswap V3</a></li><li><a href=/docs/introduction/dev-environment/>Development Environment</a></li></ul></li><li class=book-section-flat><span>Milestone 1. First Swap</span><ul><li><a href=/docs/milestone_1/introduction/>Introduction</a></li><li><a href=/docs/milestone_1/calculating-liquidity/>Calculating Liquidity</a></li><li><a href=/docs/milestone_1/providing-liquidity/ class=active>Providing Liquidity</a></li><li><a href=/docs/milestone_1/first-swap/>First Swap</a></li><li><a href=/docs/milestone_1/manager-contract/>Manager Contract</a></li><li><a href=/docs/milestone_1/deployment/>Deployment</a></li><li><a href=/docs/milestone_1/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 2. Second Swap</span><ul><li><a href=/docs/milestone_2/introduction/>Introduction</a></li><li><a href=/docs/milestone_2/output-amount-calculation/>Output Amount Calculation</a></li><li><a href=/docs/milestone_2/math-in-solidity/>Math in Solidity</a></li><li><a href=/docs/milestone_2/tick-bitmap-index/>Tick Bitmap Index</a></li><li><a href=/docs/milestone_2/generalize-minting/>Generalize Minting</a></li><li><a href=/docs/milestone_2/generalize-swapping/>Generalize Swapping</a></li><li><a href=/docs/milestone_2/quoter-contract/>Quoter Contract</a></li><li><a href=/docs/milestone_2/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 3. Cross-tick Swaps</span><ul><li><a href=/docs/milestone_3/introduction/>Introduction</a></li><li><a href=/docs/milestone_3/different-ranges/>Different Price Ranges</a></li><li><a href=/docs/milestone_3/cross-tick-swaps/>Cross-Tick Swaps</a></li><li><a href=/docs/milestone_3/slippage-protection/>Slippage Protection</a></li><li><a href=/docs/milestone_3/liquidity-calculation/>Liquidity Calculation</a></li><li><a href=/docs/milestone_3/more-on-fixed-point-numbers/>A Little Bit More on Fixed-point Numbers</a></li><li><a href=/docs/milestone_3/flash-loans/>Flash Loans</a></li><li><a href=/docs/milestone_3/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 4. Multi-pool Swaps</span><ul><li><a href=/docs/milestone_4/introduction/>Introduction</a></li><li><a href=/docs/milestone_4/factory-contract/>Factory Contract</a></li><li><a href=/docs/milestone_4/path/>Swap Path</a></li><li><a href=/docs/milestone_4/multi-pool-swaps/>Multi-pool Swaps</a></li><li><a href=/docs/milestone_4/user-interface/>User Interface</a></li><li><a href=/docs/milestone_4/tick-rounding/>Tick Rounding</a></li></ul></li><li class=book-section-flat><span>Milestone 5. Fees and Price Oracle</span><ul><li><a href=/docs/milestone_5/introduction/>Introduction</a></li><li><a href=/docs/milestone_5/swap-fees/>Swap Fees</a></li><li><a href=/docs/milestone_5/flash-loan-fees/>Flash Loan Fees</a></li><li><a href=/docs/milestone_5/protocol-fees/>Protocol Fees</a></li><li><a href=/docs/milestone_5/price-oracle/>Price Oracle</a></li><li><a href=/docs/milestone_5/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 6: NFT positions</span><ul><li><a href=/docs/milestone_6/introduction/>Introduction</a></li><li><a href=/docs/milestone_6/erc721-overview/>ERC721 Overview</a></li><li><a href=/docs/milestone_6/nft-manager/>NFT Manager</a></li><li><a href=/docs/milestone_6/nft-renderer/>NFT Renderer</a></li></ul></li><li class=book-section-flat><span>补充资料</span><ul><li><a href=/docs/reference/dictionary/>中英名词对照</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Providing Liquidity</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#providing-liquidity>Providing Liquidity</a><ul><li><a href=#pool-contract>Pool Contract</a></li><li><a href=#minting>Minting</a></li><li><a href=#testing>Testing</a><ul><li><a href=#test-tokens>Test Tokens</a></li><li><a href=#minting-1>Minting</a></li><li><a href=#failures>Failures</a></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><link rel=stylesheet href=/katex/katex.min.css><script>function renderKatex(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})}</script><script defer src=/katex/katex.min.js></script>
<script defer src=/katex/auto-render.min.js onload=renderKatex(document.body)></script><span>
\[ \]</span><h1 id=providing-liquidity>Providing Liquidity
<a class=anchor href=#providing-liquidity>#</a></h1><p>Enough of theory, let&rsquo;s start coding!</p><p>Create a new folder (mine is called <code>uniswapv3-code</code>), and run <code>forge init --vscode</code> in it–this will initialize a Forge
project. The <code>--vscode</code> flag tells Forge to configure the Solidity extension for Forge projects.</p><p>Next, remove the default contract and its test:</p><ul><li><code>script/Contract.s.sol</code></li><li><code>src/Contract.sol</code></li><li><code>test/Contract.t.sol</code></li></ul><p>And that&rsquo;s it! Let&rsquo;s create our first contract!</p><h2 id=pool-contract>Pool Contract
<a class=anchor href=#pool-contract>#</a></h2><p>As you&rsquo;ve learned from the introduction, Uniswap deploys multiple Pool contracts, each of which is an exchange market of
a pair of tokens. Uniswap groups all its contract into two categories:</p><ul><li>core contracts,</li><li>and periphery contracts.</li></ul><p>Core contracts are, as the name implies, the contracts that implement core logic. These are minimal, user-<strong>un</strong>friendly,
low-level contracts. Their purpose is to do one thing and do it as reliably and securely as possible. In Uniswap V3,
there are 2 such contracts:</p><ol><li>Pool contract, which implements the core logic of a decentralized exchange.</li><li>Factory contract, which serves as a registry of Pool contracts and a contract that makes deployment of pools easier.</li></ol><p>We&rsquo;ll begin with the pool contract, which implements 99% of the core functionality of Uniswap.</p><p>Create <code>src/UniswapV3Pool.sol</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>pragma solidity</span> <span style=color:#f92672>^</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>8</span>.<span style=color:#ae81ff>14</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>contract</span> <span style=color:#a6e22e>UniswapV3Pool</span> {}
</span></span></code></pre></div><p>Let&rsquo;s think about what data the contract will store:</p><ol><li>Since every pool contract is an exchange market of two tokens, we need to track the two token addresses. And these
addresses will be static, set once and forever during pool deployment (thus, they will be immutable).</li><li>Each pool contract is a set of liquidity positions. We&rsquo;ll store them in a mapping, where keys are unique position
identifiers and values are structs holding information about positions.</li><li>Each pool contract will also need to maintain a ticks registry–this will be a mapping with keys being tick indexes and
values being structs storing information about ticks.</li><li>Since the tick range is limited, we need to store the limits in the contract, as constants.</li><li>Recall that pool contracts store the amount of liquidity, $L$. So we&rsquo;ll need to have a variable for it.</li><li>Finally, we need to track the current price and the related tick. We&rsquo;ll store them in one storage slot to optimize
gas consumption: these variables will be often read and written together, so it makes sense to benefit from <a href=https://docs.soliditylang.org/en/v0.8.17/internals/layout_in_storage.html>the state
variables packing feature of Solidity</a>.</li></ol><p>All in all, this is what we begin with:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#75715e>// src/lib/Tick.sol
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>library</span> Tick {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Info</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bool</span> initialized;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint128</span> liquidity;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// src/lib/Position.sol
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>library</span> Position {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Info</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint128</span> liquidity;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// src/UniswapV3Pool.sol
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>contract</span> <span style=color:#a6e22e>UniswapV3Pool</span> {
</span></span><span style=display:flex><span>    <span style=color:#f92672>using</span> Tick <span style=color:#66d9ef>for</span> <span style=color:#66d9ef>mapping</span>(<span style=color:#66d9ef>int24</span> <span style=color:#f92672>=&gt;</span> Tick.Info);
</span></span><span style=display:flex><span>    <span style=color:#f92672>using</span> Position <span style=color:#66d9ef>for</span> <span style=color:#66d9ef>mapping</span>(<span style=color:#66d9ef>bytes32</span> <span style=color:#f92672>=&gt;</span> Position.Info);
</span></span><span style=display:flex><span>    <span style=color:#f92672>using</span> Position <span style=color:#66d9ef>for</span> Position.Info;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int24</span> <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>constant</span> MIN_TICK <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>887272</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int24</span> <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>constant</span> MAX_TICK <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>MIN_TICK;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Pool tokens, immutable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>address</span> <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>immutable</span> token0;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>address</span> <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>immutable</span> token1;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Packing variables that are read together
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Slot0</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Current sqrt(P)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>uint160</span> sqrtPriceX96;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Current tick
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int24</span> tick;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    Slot0 <span style=color:#66d9ef>public</span> slot0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Amount of liquidity, L.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>uint128</span> <span style=color:#66d9ef>public</span> liquidity;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Ticks info
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>mapping</span>(<span style=color:#66d9ef>int24</span> <span style=color:#f92672>=&gt;</span> Tick.Info) <span style=color:#66d9ef>public</span> ticks;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Positions info
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>mapping</span>(<span style=color:#66d9ef>bytes32</span> <span style=color:#f92672>=&gt;</span> Position.Info) <span style=color:#66d9ef>public</span> positions;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ...
</span></span></code></pre></div><p>Uniswap V3 uses many helper contracts and <code>Tick</code> and <code>Position</code> are two of them. <code>using A for B</code> is a feature of Solidity
that lets you extend type <code>B</code> with functions from library contract <code>A</code>. This simplifies managing complex data structures.</p><blockquote><p>For brevity, I&rsquo;ll omit detailed explanation of Solidity syntax and features. Solidity has <a href=https://docs.soliditylang.org/en/latest/>great documentation</a>,
don&rsquo;t hesitate referring to it if something is not clear!</p></blockquote><p>We&rsquo;ll then initialize some of the variables in the constructor:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>    <span style=color:#66d9ef>constructor</span>(
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>address</span> token0_,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>address</span> token1_,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint160</span> sqrtPriceX96,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int24</span> tick
</span></span><span style=display:flex><span>    ) {
</span></span><span style=display:flex><span>        token0 <span style=color:#f92672>=</span> token0_;
</span></span><span style=display:flex><span>        token1 <span style=color:#f92672>=</span> token1_;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        slot0 <span style=color:#f92672>=</span> Slot0({sqrtPriceX96<span style=color:#f92672>:</span> sqrtPriceX96, tick<span style=color:#f92672>:</span> tick});
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Here, we&rsquo;re setting the token address immutables and setting the current price and tick–we don&rsquo;t need to provide liquidity
for the latter.</p><p>This is our starting point, and our goal in this chapter is to make our first swap using pre-calculated and hard coded
values.</p><h2 id=minting>Minting
<a class=anchor href=#minting>#</a></h2><p>The process of providing liquidity in Uniswap V2 is called <em>minting</em>. The reason is that the V2 pool contract mints
tokens (LP-tokens) in exchange for liquidity. V3 doesn&rsquo;t do that, but it still uses the same name for the function. Let&rsquo;s
use it as well:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>mint</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>address</span> owner,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int24</span> lowerTick,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int24</span> upperTick,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint128</span> amount
</span></span><span style=display:flex><span>) <span style=color:#66d9ef>external</span> <span style=color:#66d9ef>returns</span> (<span style=color:#66d9ef>uint256</span> amount0, <span style=color:#66d9ef>uint256</span> amount1) {
</span></span><span style=display:flex><span>    ...
</span></span></code></pre></div><p>Our <code>mint</code> function will take:</p><ol><li>Owner&rsquo;s address, to track the owner of the liquidity.</li><li>Upper and lower ticks, to set the bounds of a price range.</li><li>The amount of liquidity we want to provide.</li></ol><blockquote><p>Notice that user specifies $L$, not actual token amounts. This is not very convenient of course, but recall that the
Pool contract is a core contract–it&rsquo;s not intended to be user-friendly because it should implement only the core logic.
In a later chapter, we&rsquo;ll make a helper contract that will convert token amounts to $L$ before calling <code>Pool.mint</code>.</p></blockquote><p>Let&rsquo;s outline a quick plan of how minting will work:</p><ol><li>a user specifies a price range and an amount of liquidity;</li><li>the contract updates the <code>ticks</code> and <code>positions</code> mappings;</li><li>the contract calculates token amounts the user must send (we&rsquo;ll pre-calculate and hard code them);</li><li>the contract takes tokens from the user and verifies that correct amounts were set.</li></ol><p>Let&rsquo;s begin with checking the ticks:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>if</span> (
</span></span><span style=display:flex><span>    lowerTick <span style=color:#f92672>&gt;=</span> upperTick <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>    lowerTick <span style=color:#f92672>&lt;</span> MIN_TICK <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>    upperTick <span style=color:#f92672>&gt;</span> MAX_TICK
</span></span><span style=display:flex><span>) revert InvalidTickRange();
</span></span></code></pre></div><p>And ensuring that some amount of liquidity is provided:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>if</span> (amount <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) revert ZeroLiquidity();
</span></span></code></pre></div><p>Then, add a tick and a position:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>ticks.update(lowerTick, amount);
</span></span><span style=display:flex><span>ticks.update(upperTick, amount);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Position.Info <span style=color:#66d9ef>storage</span> position <span style=color:#f92672>=</span> positions.get(
</span></span><span style=display:flex><span>    owner,
</span></span><span style=display:flex><span>    lowerTick,
</span></span><span style=display:flex><span>    upperTick
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>position.update(amount);
</span></span></code></pre></div><p>The <code>ticks.update</code> function is:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#75715e>// src/lib/Tick.sol
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>update</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>mapping</span>(<span style=color:#66d9ef>int24</span> <span style=color:#f92672>=&gt;</span> Tick.Info) <span style=color:#66d9ef>storage</span> self,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int24</span> tick,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint128</span> liquidityDelta
</span></span><span style=display:flex><span>) <span style=color:#66d9ef>internal</span> {
</span></span><span style=display:flex><span>    Tick.Info <span style=color:#66d9ef>storage</span> tickInfo <span style=color:#f92672>=</span> self[tick];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint128</span> liquidityBefore <span style=color:#f92672>=</span> tickInfo.liquidity;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint128</span> liquidityAfter <span style=color:#f92672>=</span> liquidityBefore <span style=color:#f92672>+</span> liquidityDelta;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (liquidityBefore <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        tickInfo.initialized <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    tickInfo.liquidity <span style=color:#f92672>=</span> liquidityAfter;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It initialized a tick if it had 0 liquidity and adds new liquidity to it. As you can see, we&rsquo;re calling this
function on both lower and upper ticks, thus liquidity is added to both of them.</p><p>The <code>position.update</code> function is:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#75715e>// src/libs/Position.sol
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>update</span>(Info <span style=color:#66d9ef>storage</span> self, <span style=color:#66d9ef>uint128</span> liquidityDelta) <span style=color:#66d9ef>internal</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint128</span> liquidityBefore <span style=color:#f92672>=</span> self.liquidity;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint128</span> liquidityAfter <span style=color:#f92672>=</span> liquidityBefore <span style=color:#f92672>+</span> liquidityDelta;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    self.liquidity <span style=color:#f92672>=</span> liquidityAfter;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Similar to the tick update function, it adds liquidity to a specific position. And to get a position we call:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#75715e>// src/libs/Position.sol
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>...
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>get</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>mapping</span>(<span style=color:#66d9ef>bytes32</span> <span style=color:#f92672>=&gt;</span> Info) <span style=color:#66d9ef>storage</span> self,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>address</span> owner,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int24</span> lowerTick,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int24</span> upperTick
</span></span><span style=display:flex><span>) <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>view</span> <span style=color:#66d9ef>returns</span> (Position.Info <span style=color:#66d9ef>storage</span> position) {
</span></span><span style=display:flex><span>    position <span style=color:#f92672>=</span> self[
</span></span><span style=display:flex><span>        keccak256(abi.encodePacked(owner, lowerTick, upperTick))
</span></span><span style=display:flex><span>    ];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>Each position is uniquely identified by three keys: owner address, lower tick index, and upper tick index.
We hash the three to make storing of data cheaper: when hashed, every key will take 32 bytes, instead of 96 bytes when
<code>owner</code>, <code>lowerTick</code>, and <code>upperTick</code> are separate keys.</p><blockquote><p>If we use three keys, we need three mappings. Each key would be stored separately and would take 32 bytes since Solidity
stores values in 32-byte slots (when packing is not applied).</p></blockquote><p>Next, continuing with minting, we need to calculate the amounts that the user must deposit. Luckily, we have already figured
out the formulas and calculated the exact amounts in the previous part. So, we&rsquo;re going to hard code them:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>amount0 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>998976618347425280</span> <span style=color:#66d9ef>ether</span>;
</span></span><span style=display:flex><span>amount1 <span style=color:#f92672>=</span> <span style=color:#ae81ff>5000</span> <span style=color:#66d9ef>ether</span>;
</span></span></code></pre></div><blockquote><p>We&rsquo;ll replace these with actual calculations in a later chapter.</p></blockquote><p>Now, we&rsquo;re ready to take tokens from the user. This is done via a callback:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>uint256</span> balance0Before;
</span></span><span style=display:flex><span><span style=color:#66d9ef>uint256</span> balance1Before;
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (amount0 <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) balance0Before <span style=color:#f92672>=</span> balance0();
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (amount1 <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) balance1Before <span style=color:#f92672>=</span> balance1();
</span></span><span style=display:flex><span>IUniswapV3MintCallback(msg.sender).uniswapV3MintCallback(
</span></span><span style=display:flex><span>    amount0,
</span></span><span style=display:flex><span>    amount1
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (amount0 <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> balance0Before <span style=color:#f92672>+</span> amount0 <span style=color:#f92672>&gt;</span> balance0())
</span></span><span style=display:flex><span>    revert InsufficientInputAmount();
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (amount1 <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> balance1Before <span style=color:#f92672>+</span> amount1 <span style=color:#f92672>&gt;</span> balance1())
</span></span><span style=display:flex><span>    revert InsufficientInputAmount();
</span></span></code></pre></div><p>First, we record current token balances. Then we call <code>uniswapV3MintCallback</code> method on the caller–this is the callback.
It&rsquo;s expected that the caller (whoever calls <code>mint</code>) is a contract because non-contract addresses cannot implement
functions in Ethereum. Using a callback here, while not being user-friendly at all, let&rsquo;s the contract calculate
token amounts using its current state–this is critical because we cannot trust users.</p><p>The caller is expected to implement <code>uniswapV3MintCallback</code> and transfer tokens to the Pool contract in this function.
After calling the callback function, we continue with checking whether the Pool contract balances have changed or not:
we require them to increase by at least <code>amount0</code> and <code>amount1</code> respectively–this would mean the caller has transferred
tokens to the pool.</p><p>Finally, we&rsquo;re firing a <code>Mint</code> event:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>emit Mint(msg.sender, owner, lowerTick, upperTick, amount, amount0, amount1);
</span></span></code></pre></div><p>Events is how contract data is indexed in Ethereum for later search. It&rsquo;s a good practice to fire an event whenever
contract&rsquo;s state is changed to let blockchain explorer know when this happened. Events also carry useful information.
In our case it&rsquo;s: caller&rsquo;s address, liquidity position owner&rsquo;s address, upper and lower ticks, new liquidity, and token
amounts. This information will be stored as a log, and anyone else will be able to collect all contract events and
reproduce activity of the contract without traversing and analyzing all blocks and transactions.</p><p>And we&rsquo;re done! Phew! Now, let&rsquo;s test minting.</p><h2 id=testing>Testing
<a class=anchor href=#testing>#</a></h2><p>At this point we don&rsquo;t know if everything works correctly. Before deploying our contract anywhere we&rsquo;re going to write
a bunch of tests to ensure the contract works correctly. Luckily to us, Forge is a great testing framework and it&rsquo;ll
make testing a breeze.</p><p>Create a new test file:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#75715e>// test/UniswapV3Pool.t.sol
</span></span></span><span style=display:flex><span><span style=color:#75715e>// SPDX-License-Identifier: UNLICENSED
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>pragma solidity</span> <span style=color:#f92672>^</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>8</span>.<span style=color:#ae81ff>14</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;forge-std/Test.sol&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>contract</span> <span style=color:#a6e22e>UniswapV3PoolTest</span> <span style=color:#66d9ef>is</span> Test {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>setUp</span>() <span style=color:#66d9ef>public</span> {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>testExample</span>() <span style=color:#66d9ef>public</span> {
</span></span><span style=display:flex><span>        assertTrue(<span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Let&rsquo;s run it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ forge test
</span></span><span style=display:flex><span>Running <span style=color:#ae81ff>1</span> test <span style=color:#66d9ef>for</span> test/UniswapV3Pool.t.sol:UniswapV3PoolTest
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>PASS<span style=color:#f92672>]</span> testExample<span style=color:#f92672>()</span> <span style=color:#f92672>(</span>gas: 279<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Test result: ok. <span style=color:#ae81ff>1</span> passed; <span style=color:#ae81ff>0</span> failed; finished in 5.07ms
</span></span></code></pre></div><p>It passes! Of course it is! So far, our test only checks that <code>true</code> is <code>true</code>!</p><p>Test contract are just contract that inherit from <code>forge-std/Test.sol</code>. This contract is a set of testing utilities, we&rsquo;ll
get acquainted with them step by step. If you don&rsquo;t want to wait, open <code>lib/forge-std/src/Test.sol</code> and skim through it.</p><p>Test contracts follow a specific convention:</p><ol><li><code>setUp</code> function is used to set up test cases. In each test cases, we want to have a configured environment, like
deployed contracts, minted tokens, initialized pools–we&rsquo;ll do all this in <code>setUp</code>.</li><li>Every test case starts with <code>test</code> prefix, e.g. <code>testMint()</code>. This will let Forge distinguish test cases from helper
functions (we can also have any function we want).</li></ol><p>Let&rsquo;s now actually test minting.</p><h3 id=test-tokens>Test Tokens
<a class=anchor href=#test-tokens>#</a></h3><p>To test minting we need tokens. This is not a problem because we can deploy any contract in tests! Moreover, Forge can
install open-source contracts as dependencies. Specifically, we need an ERC20 contract with minting functionality. We&rsquo;ll
use the ERC20 contract from <a href=https://github.com/Rari-Capital/solmate>Solmate</a>, a collection of gas-optimized contracts,
and make an ERC20 contract that inherits from the Solmate contract and exposes minting (it&rsquo;s public by default).</p><p>Let&rsquo;s install <code>solmate</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ forge install rari-capital/solmate
</span></span></code></pre></div><p>Then, let&rsquo;s create <code>ERC20Mintable.sol</code> contract in <code>test</code> folder (we&rsquo;ll use the contract only in tests):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#75715e>// SPDX-License-Identifier: UNLICENSED
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>pragma solidity</span> <span style=color:#f92672>^</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>8</span>.<span style=color:#ae81ff>14</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;solmate/tokens/ERC20.sol&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>contract</span> <span style=color:#a6e22e>ERC20Mintable</span> <span style=color:#66d9ef>is</span> ERC20 {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>constructor</span>(
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>string</span> <span style=color:#66d9ef>memory</span> _name,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>string</span> <span style=color:#66d9ef>memory</span> _symbol,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint8</span> _decimals
</span></span><span style=display:flex><span>    ) ERC20(_name, _symbol, _decimals) {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>mint</span>(<span style=color:#66d9ef>address</span> to, <span style=color:#66d9ef>uint256</span> amount) <span style=color:#66d9ef>public</span> {
</span></span><span style=display:flex><span>        _mint(to, amount);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Our <code>ERC20Mintable</code> inherits all functionality from <code>solmate/tokens/ERC20.sol</code> and we additionally implement public <code>mint</code>
method which will allow us to mint any number of tokens.</p><h3 id=minting-1>Minting
<a class=anchor href=#minting-1>#</a></h3><p>Now, we&rsquo;re ready to test minting.</p><p>First, let&rsquo;s deploy all the required contracts:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#75715e>// test/UniswapV3Pool.t.sol
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>...
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;./ERC20Mintable.sol&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;../src/UniswapV3Pool.sol&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>contract</span> <span style=color:#a6e22e>UniswapV3PoolTest</span> <span style=color:#66d9ef>is</span> Test {
</span></span><span style=display:flex><span>    ERC20Mintable token0;
</span></span><span style=display:flex><span>    ERC20Mintable token1;
</span></span><span style=display:flex><span>    UniswapV3Pool pool;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>setUp</span>() <span style=color:#66d9ef>public</span> {
</span></span><span style=display:flex><span>        token0 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ERC20Mintable(<span style=color:#e6db74>&#34;Ether&#34;</span>, <span style=color:#e6db74>&#34;ETH&#34;</span>, <span style=color:#ae81ff>18</span>);
</span></span><span style=display:flex><span>        token1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ERC20Mintable(<span style=color:#e6db74>&#34;USDC&#34;</span>, <span style=color:#e6db74>&#34;USDC&#34;</span>, <span style=color:#ae81ff>18</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ...
</span></span></code></pre></div><p>In the <code>setUp</code> function, we deploy tokens but not pools! This is because all our test cases will use the same tokens but
each of them will have a unique pool.</p><p>To make setting up of pools cleaner and simpler, we&rsquo;ll do this in a separate function, <code>setupTestCase</code>, that takes a set of
test case parameters. In our first test case, we&rsquo;ll test successful liquidity minting. This is what the test case
parameters look like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>testMintSuccess</span>() <span style=color:#66d9ef>public</span> {
</span></span><span style=display:flex><span>    TestCaseParams <span style=color:#66d9ef>memory</span> params <span style=color:#f92672>=</span> TestCaseParams({
</span></span><span style=display:flex><span>        wethBalance<span style=color:#f92672>:</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>ether</span>,
</span></span><span style=display:flex><span>        usdcBalance<span style=color:#f92672>:</span> <span style=color:#ae81ff>5000</span> <span style=color:#66d9ef>ether</span>,
</span></span><span style=display:flex><span>        currentTick<span style=color:#f92672>:</span> <span style=color:#ae81ff>85176</span>,
</span></span><span style=display:flex><span>        lowerTick<span style=color:#f92672>:</span> <span style=color:#ae81ff>84222</span>,
</span></span><span style=display:flex><span>        upperTick<span style=color:#f92672>:</span> <span style=color:#ae81ff>86129</span>,
</span></span><span style=display:flex><span>        liquidity<span style=color:#f92672>:</span> <span style=color:#ae81ff>1517882343751509868544</span>,
</span></span><span style=display:flex><span>        currentSqrtP<span style=color:#f92672>:</span> <span style=color:#ae81ff>5602277097478614198912276234240</span>,
</span></span><span style=display:flex><span>        shouldTransferInCallback<span style=color:#f92672>:</span> <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>        mintLiqudity<span style=color:#f92672>:</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    });
</span></span></code></pre></div><ol><li>We&rsquo;re planning to deposit 1 ETH and 5000 USDC into the pool.</li><li>We want the current tick to be 85176, and lower and upper ticks being 84222 and 86129 respectively (we calculated these
values in the previous chapter).</li><li>We&rsquo;re specifying the precalculated liquidity and current $\sqrt{P}$.</li><li>We also want to deposit liquidity (<code>mintLiquidity</code> parameter) and transfer tokens when requested by the pool contract
(<code>shouldTransferInCallback</code>). We don&rsquo;t want to do this in each test case, so we want have the flags.</li></ol><p>Next, we&rsquo;re calling <code>setupTestCase</code> with the above parameters:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>setupTestCase</span>(TestCaseParams <span style=color:#66d9ef>memory</span> params)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>internal</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>returns</span> (<span style=color:#66d9ef>uint256</span> poolBalance0, <span style=color:#66d9ef>uint256</span> poolBalance1)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    token0.mint(<span style=color:#66d9ef>address</span>(this), params.wethBalance);
</span></span><span style=display:flex><span>    token1.mint(<span style=color:#66d9ef>address</span>(this), params.usdcBalance);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    pool <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> UniswapV3Pool(
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>address</span>(token0),
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>address</span>(token1),
</span></span><span style=display:flex><span>        params.currentSqrtP,
</span></span><span style=display:flex><span>        params.currentTick
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (params.mintLiqudity) {
</span></span><span style=display:flex><span>        (poolBalance0, poolBalance1) <span style=color:#f92672>=</span> pool.mint(
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>address</span>(this),
</span></span><span style=display:flex><span>            params.lowerTick,
</span></span><span style=display:flex><span>            params.upperTick,
</span></span><span style=display:flex><span>            params.liquidity
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    shouldTransferInCallback <span style=color:#f92672>=</span> params.shouldTransferInCallback;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In this function, we&rsquo;re minting tokens and deploying a pool. Also, when the <code>mintLiquidity</code> flag is set, we mint liquidity
in the pool. At the end, we&rsquo;re setting the <code>shouldTransferInCallback</code> flag for it to be read in the mint callback:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>uniswapV3MintCallback</span>(<span style=color:#66d9ef>uint256</span> amount0, <span style=color:#66d9ef>uint256</span> amount1) <span style=color:#66d9ef>public</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (shouldTransferInCallback) {
</span></span><span style=display:flex><span>        token0.transfer(msg.sender, amount0);
</span></span><span style=display:flex><span>        token1.transfer(msg.sender, amount1);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It&rsquo;s the test contract that will provide liquidity and will call the <code>mint</code> function on the pool, there&rsquo;re no users. The
test contract will act as a user, thus it can implement the mint callback function.</p><p>Setting up test cases like that is not mandatory, you can do it however feels most comfortable to you. Test contracts are
just contracts.</p><p>In <code>testMintSuccess</code>, we want to test that the pool contract:</p><ol><li>takes the correct amounts of tokens from us;</li><li>creates a position with correct key and liquidity;</li><li>initializes the upper and lower ticks we&rsquo;ve specified;</li><li>has correct $\sqrt{P}$ and $L$.</li></ol><p>Let&rsquo;s do this.</p><p>Minting happens in <code>setupTestCase</code>, so we don&rsquo;t need to do this again. The function also returns the amounts we have
provided, so let&rsquo;s check them:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>(<span style=color:#66d9ef>uint256</span> poolBalance0, <span style=color:#66d9ef>uint256</span> poolBalance1) <span style=color:#f92672>=</span> setupTestCase(params);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>uint256</span> expectedAmount0 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>998976618347425280</span> <span style=color:#66d9ef>ether</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>uint256</span> expectedAmount1 <span style=color:#f92672>=</span> <span style=color:#ae81ff>5000</span> <span style=color:#66d9ef>ether</span>;
</span></span><span style=display:flex><span>assertEq(
</span></span><span style=display:flex><span>    poolBalance0,
</span></span><span style=display:flex><span>    expectedAmount0,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;incorrect token0 deposited amount&#34;</span>
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>assertEq(
</span></span><span style=display:flex><span>    poolBalance1,
</span></span><span style=display:flex><span>    expectedAmount1,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;incorrect token1 deposited amount&#34;</span>
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>We expect specific pre-calculated amounts. And we can also check that these amounts were actually transferred to the pool:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>assertEq(token0.balanceOf(<span style=color:#66d9ef>address</span>(pool)), expectedAmount0);
</span></span><span style=display:flex><span>assertEq(token1.balanceOf(<span style=color:#66d9ef>address</span>(pool)), expectedAmount1);
</span></span></code></pre></div><p>Next, we need to check the position the pool created for us. Remember that the key in <code>positions</code> mapping is a hash? We
need to calculate it manually and then get our position from the contract:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>bytes32</span> positionKey <span style=color:#f92672>=</span> keccak256(
</span></span><span style=display:flex><span>    abi.encodePacked(<span style=color:#66d9ef>address</span>(this), params.lowerTick, params.upperTick)
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>uint128</span> posLiquidity <span style=color:#f92672>=</span> pool.positions(positionKey);
</span></span><span style=display:flex><span>assertEq(posLiquidity, params.liquidity);
</span></span></code></pre></div><blockquote><p>Since <code>Position.Info</code> is a <a href=https://docs.soliditylang.org/en/latest/types.html#structs>struct</a>, it gets destructured
when fetched: each field gets assigned to a separate variable.</p></blockquote><p>Next come the ticks. Again, it&rsquo;s straightforward:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>(<span style=color:#66d9ef>bool</span> tickInitialized, <span style=color:#66d9ef>uint128</span> tickLiquidity) <span style=color:#f92672>=</span> pool.ticks(
</span></span><span style=display:flex><span>    params.lowerTick
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>assertTrue(tickInitialized);
</span></span><span style=display:flex><span>assertEq(tickLiquidity, params.liquidity);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(tickInitialized, tickLiquidity) <span style=color:#f92672>=</span> pool.ticks(params.upperTick);
</span></span><span style=display:flex><span>assertTrue(tickInitialized);
</span></span><span style=display:flex><span>assertEq(tickLiquidity, params.liquidity);
</span></span></code></pre></div><p>And finally, $\sqrt{P}$ and $L$:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>(<span style=color:#66d9ef>uint160</span> sqrtPriceX96, <span style=color:#66d9ef>int24</span> tick) <span style=color:#f92672>=</span> pool.slot0();
</span></span><span style=display:flex><span>assertEq(
</span></span><span style=display:flex><span>    sqrtPriceX96,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>5602277097478614198912276234240</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;invalid current sqrtP&#34;</span>
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>assertEq(tick, <span style=color:#ae81ff>85176</span>, <span style=color:#e6db74>&#34;invalid current tick&#34;</span>);
</span></span><span style=display:flex><span>assertEq(
</span></span><span style=display:flex><span>    pool.liquidity(),
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>1517882343751509868544</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;invalid current liquidity&#34;</span>
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>As you can see, writing tests in Solidity is not hard!</p><h3 id=failures>Failures
<a class=anchor href=#failures>#</a></h3><p>Of course, testing only successful scenarios is not enough. We also need to test failing cases. What can go wrong when
providing liquidity? Here are a couple of hints:</p><ol><li>Upper and lower ticks are too big or too small.</li><li>Zero liquidity is provided.</li><li>Liquidity provider doesn&rsquo;t have enough of tokens.</li></ol><p>I&rsquo;ll leave it for you to implement these scenarios! Feel free peeking at <a href=https://github.com/Jeiwan/uniswapv3-code/blob/milestone_1/test/UniswapV3Pool.t.sol>the code in the repo</a>.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#providing-liquidity>Providing Liquidity</a><ul><li><a href=#pool-contract>Pool Contract</a></li><li><a href=#minting>Minting</a></li><li><a href=#testing>Testing</a><ul><li><a href=#test-tokens>Test Tokens</a></li><li><a href=#minting-1>Minting</a></li><li><a href=#failures>Failures</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>