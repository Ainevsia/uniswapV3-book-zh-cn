<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); }    \[ \]  First Swap #  Now that we have liquidity, we can make our first swap!
Calculating Swap Amounts #  First step, of course, is to figure out how to calculate swap amounts."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="First Swap"><meta property="og:description" content="function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); }    \[ \]  First Swap #  Now that we have liquidity, we can make our first swap!
Calculating Swap Amounts #  First step, of course, is to figure out how to calculate swap amounts."><meta property="og:type" content="article"><meta property="og:url" content="https://uniswapv3book.com/docs/milestone_1/first-swap/"><meta property="article:section" content="docs"><title>First Swap | Uniswap V3 Book 中文版</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.82c5dbd23447cee0b4c2aa3ed08ce0961faa40e1fa370eee4f8c9f02e0d46b5f.css integrity="sha256-gsXb0jRHzuC0wqo+0Izglh+qQOH6Nw7uT4yfAuDUa18=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.d6b0217789cab12411fda11381b98a7b8564b6410ec290ed237c4738da0a1f38.js integrity="sha256-1rAhd4nKsSQR/aETgbmKe4VktkEOwpDtI3xHONoKHzg=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Uniswap V3 Book 中文版</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>Milestone 0. 简介</span><ul><li><a href=/docs/introduction/introduction-to-markets/>交易市场简介</a></li><li><a href=/docs/introduction/constant-function-market-maker/>恒定函数做市商(CFMM)</a></li><li><a href=/docs/introduction/uniswap-v3/>Uniswap V3</a></li><li><a href=/docs/introduction/dev-environment/>开发环境</a></li></ul></li><li class=book-section-flat><span>Milestone 1. First Swap</span><ul><li><a href=/docs/milestone_1/introduction/>Introduction</a></li><li><a href=/docs/milestone_1/calculating-liquidity/>Calculating Liquidity</a></li><li><a href=/docs/milestone_1/providing-liquidity/>Providing Liquidity</a></li><li><a href=/docs/milestone_1/first-swap/ class=active>First Swap</a></li><li><a href=/docs/milestone_1/manager-contract/>Manager Contract</a></li><li><a href=/docs/milestone_1/deployment/>Deployment</a></li><li><a href=/docs/milestone_1/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 2. Second Swap</span><ul><li><a href=/docs/milestone_2/introduction/>Introduction</a></li><li><a href=/docs/milestone_2/output-amount-calculation/>Output Amount Calculation</a></li><li><a href=/docs/milestone_2/math-in-solidity/>Math in Solidity</a></li><li><a href=/docs/milestone_2/tick-bitmap-index/>Tick Bitmap Index</a></li><li><a href=/docs/milestone_2/generalize-minting/>Generalize Minting</a></li><li><a href=/docs/milestone_2/generalize-swapping/>Generalize Swapping</a></li><li><a href=/docs/milestone_2/quoter-contract/>Quoter Contract</a></li><li><a href=/docs/milestone_2/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 3. Cross-tick Swaps</span><ul><li><a href=/docs/milestone_3/introduction/>Introduction</a></li><li><a href=/docs/milestone_3/different-ranges/>Different Price Ranges</a></li><li><a href=/docs/milestone_3/cross-tick-swaps/>Cross-Tick Swaps</a></li><li><a href=/docs/milestone_3/slippage-protection/>Slippage Protection</a></li><li><a href=/docs/milestone_3/liquidity-calculation/>Liquidity Calculation</a></li><li><a href=/docs/milestone_3/more-on-fixed-point-numbers/>A Little Bit More on Fixed-point Numbers</a></li><li><a href=/docs/milestone_3/flash-loans/>Flash Loans</a></li><li><a href=/docs/milestone_3/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 4. Multi-pool Swaps</span><ul><li><a href=/docs/milestone_4/introduction/>Introduction</a></li><li><a href=/docs/milestone_4/factory-contract/>Factory Contract</a></li><li><a href=/docs/milestone_4/path/>Swap Path</a></li><li><a href=/docs/milestone_4/multi-pool-swaps/>Multi-pool Swaps</a></li><li><a href=/docs/milestone_4/user-interface/>User Interface</a></li><li><a href=/docs/milestone_4/tick-rounding/>Tick Rounding</a></li></ul></li><li class=book-section-flat><span>Milestone 5. Fees and Price Oracle</span><ul><li><a href=/docs/milestone_5/introduction/>Introduction</a></li><li><a href=/docs/milestone_5/swap-fees/>Swap Fees</a></li><li><a href=/docs/milestone_5/flash-loan-fees/>Flash Loan Fees</a></li><li><a href=/docs/milestone_5/protocol-fees/>Protocol Fees</a></li><li><a href=/docs/milestone_5/price-oracle/>Price Oracle</a></li><li><a href=/docs/milestone_5/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 6: NFT positions</span><ul><li><a href=/docs/milestone_6/introduction/>Introduction</a></li><li><a href=/docs/milestone_6/erc721-overview/>ERC721 Overview</a></li><li><a href=/docs/milestone_6/nft-manager/>NFT Manager</a></li><li><a href=/docs/milestone_6/nft-renderer/>NFT Renderer</a></li></ul></li><li class=book-section-flat><span>补充资料</span><ul><li><a href=/docs/reference/dictionary/>中英名词对照</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>First Swap</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#first-swap>First Swap</a><ul><li><a href=#calculating-swap-amounts>Calculating Swap Amounts</a></li><li><a href=#implementing-a-swap>Implementing a Swap</a></li><li><a href=#testing-swapping>Testing Swapping</a></li><li><a href=#homework>Homework</a></li></ul></li></ul></nav></aside></header><article class=markdown><link rel=stylesheet href=/katex/katex.min.css><script>function renderKatex(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})}</script><script defer src=/katex/katex.min.js></script>
<script defer src=/katex/auto-render.min.js onload=renderKatex(document.body)></script><span>
\[ \]</span><h1 id=first-swap>First Swap
<a class=anchor href=#first-swap>#</a></h1><p>Now that we have liquidity, we can make our first swap!</p><h2 id=calculating-swap-amounts>Calculating Swap Amounts
<a class=anchor href=#calculating-swap-amounts>#</a></h2><p>First step, of course, is to figure out how to calculate swap amounts. And, again, let&rsquo;s pick and hardcode some amount
of USDC we&rsquo;re going to trade in for ETH. Let it be 42! We&rsquo;re going to buy ETH for 42 USDC.</p><p>After deciding how many tokens we want to sell, we need to calculate how many tokens we&rsquo;ll get in exchange. In Uniswap V2,
we would&rsquo;ve used current pool reserves, but in Uniswap V3 we have $L$ and $\sqrt{P}$ and we know the fact that, when
swapping within a price range, only $\sqrt{P}$ changes and $L$ remains unchanged (Uniswap V3 acts exactly as V2 when
swapping is done only within one price range). We also know that:
$$L = \frac{\Delta y}{\Delta \sqrt{P}}$$</p><p>And&mldr; we know $\Delta y$! This is the 42 USDC we&rsquo;re going to trade in! Thus, we can find how selling 42 USDC will affect
the current $\sqrt{P}$ given the $L$:</p><p>$$\Delta \sqrt{P} = \frac{\Delta y}{L}$$</p><p>In Uniswap V3, we choose <strong>the price we want our trade to lead to</strong> (recall that swapping changes the current price, i.e.
it moves the current price along the curve). Knowing the target price, the contract will calculate the amount of input
token it needs to take from us and the respective amount of output token it&rsquo;ll give us.</p><p>Let&rsquo;s plug in our numbers into the above formula:</p><p>$$\Delta \sqrt{P} = \frac{42 \enspace USDC}{1517882343751509868544} = 2192253463713690532467206957$$</p><p>After adding this to the current $\sqrt{P}$, we&rsquo;ll get the target price:</p><p>$$\sqrt{P_{target}} = \sqrt{P_{current}} + \Delta \sqrt{P}$$</p><p>$$\sqrt{P_{target}} = 5604469350942327889444743441197$$</p><blockquote><p>To calculate the target price in Python:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>amount_in <span style=color:#f92672>=</span> <span style=color:#ae81ff>42</span> <span style=color:#f92672>*</span> eth
</span></span><span style=display:flex><span>price_diff <span style=color:#f92672>=</span> (amount_in <span style=color:#f92672>*</span> q96) <span style=color:#f92672>//</span> liq
</span></span><span style=display:flex><span>price_next <span style=color:#f92672>=</span> sqrtp_cur <span style=color:#f92672>+</span> price_diff
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;New price:&#34;</span>, (price_next <span style=color:#f92672>/</span> q96) <span style=color:#f92672>**</span> <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;New sqrtP:&#34;</span>, price_next)
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;New tick:&#34;</span>, price_to_tick((price_next <span style=color:#f92672>/</span> q96) <span style=color:#f92672>**</span> <span style=color:#ae81ff>2</span>))
</span></span><span style=display:flex><span><span style=color:#75715e># New price: 5003.913912782393</span>
</span></span><span style=display:flex><span><span style=color:#75715e># New sqrtP: 5604469350942327889444743441197</span>
</span></span><span style=display:flex><span><span style=color:#75715e># New tick: 85184</span>
</span></span></code></pre></div></blockquote><p>After finding the target price, we can calculate token amounts using the amounts calculation functions from a previous
chapter:</p><p>$$ x = \frac{L(\sqrt{p_b}-\sqrt{p_a})}{\sqrt{p_b}\sqrt{p_a}}$$
$$ y = L(\sqrt{p_b}-\sqrt{p_a}) $$</p><blockquote><p>In Python:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>amount_in <span style=color:#f92672>=</span> calc_amount1(liq, price_next, sqrtp_cur)
</span></span><span style=display:flex><span>amount_out <span style=color:#f92672>=</span> calc_amount0(liq, price_next, sqrtp_cur)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;USDC in:&#34;</span>, amount_in <span style=color:#f92672>/</span> eth)
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;ETH out:&#34;</span>, amount_out <span style=color:#f92672>/</span> eth)
</span></span><span style=display:flex><span><span style=color:#75715e># USDC in: 42.0</span>
</span></span><span style=display:flex><span><span style=color:#75715e># ETH out: 0.008396714242162444</span>
</span></span></code></pre></div></blockquote><p>To verify the amounts, let&rsquo;s recall another formula:</p><p>$$\Delta x = \Delta \frac{1}{\sqrt{P}} L$$</p><p>Using this formula, we can find the amount of ETH we&rsquo;re buying, $\Delta x$, knowing the price change,
$\Delta\frac{1}{\sqrt{P}}$, and liquidity $L$. Be careful though: $\Delta \frac{1}{\sqrt{P}}$ is not
$\frac{1}{\Delta \sqrt{P}}$! The former is the change of the price of ETH, and it can be found using this expression:</p><p>$$\Delta \frac{1}{\sqrt{P}} = \frac{1}{\sqrt{P_{target}}} - \frac{1}{\sqrt{P_{current}}}$$</p><p>Luckily, we already know all the values, so we can plug them in right away (this might not fit on your screen!):</p><p>$$\Delta \frac{1}{\sqrt{P}} = \frac{1}{5604469350942327889444743441197} - \frac{1}{5602277097478614198912276234240}$$</p><p>$$\Delta \frac{1}{\sqrt{P}} = -0.00000553186106731426$$</p><p>Now, let&rsquo;s find $\Delta x$:</p><p>$$\Delta x = -0.00000553186106731426 * 1517882343751509868544 = -8396714242162698 $$</p><p>Which is 0.008396714242162698 ETH, and it&rsquo;s very close to the amount we found above! Notice that this amount is negative
since we&rsquo;re removing it from the pool.</p><h2 id=implementing-a-swap>Implementing a Swap
<a class=anchor href=#implementing-a-swap>#</a></h2><p>Swapping is implemented in <code>swap</code> function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>swap</span>(<span style=color:#66d9ef>address</span> recipient)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>returns</span> (<span style=color:#66d9ef>int256</span> amount0, <span style=color:#66d9ef>int256</span> amount1)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    ...
</span></span></code></pre></div><p>At this moment, it only takes a recipient, who is a receiver of tokens.</p><p>First, we need to find the target price and tick, as well as calculate the token amounts. Again, we&rsquo;ll simply hard code
the values we calculated earlier to keep things as simple as possible:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#66d9ef>int24</span> nextTick <span style=color:#f92672>=</span> <span style=color:#ae81ff>85184</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>uint160</span> nextPrice <span style=color:#f92672>=</span> <span style=color:#ae81ff>5604469350942327889444743441197</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>amount0 <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>008396714242162444</span> <span style=color:#66d9ef>ether</span>;
</span></span><span style=display:flex><span>amount1 <span style=color:#f92672>=</span> <span style=color:#ae81ff>42</span> <span style=color:#66d9ef>ether</span>;
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>Next, we need to update the current tick and <code>sqrtP</code> since trading affects the current price:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>...
</span></span><span style=display:flex><span>(slot0.tick, slot0.sqrtPriceX96) <span style=color:#f92672>=</span> (nextTick, nextPrice);
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>Next, the contract sends tokens to the recipient and lets the caller transfer the input amount into the contract:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>...
</span></span><span style=display:flex><span>IERC20(token0).transfer(recipient, <span style=color:#66d9ef>uint256</span>(<span style=color:#f92672>-</span>amount0));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>uint256</span> balance1Before <span style=color:#f92672>=</span> balance1();
</span></span><span style=display:flex><span>IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(
</span></span><span style=display:flex><span>    amount0,
</span></span><span style=display:flex><span>    amount1
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (balance1Before <span style=color:#f92672>+</span> <span style=color:#66d9ef>uint256</span>(amount1) <span style=color:#f92672>&lt;</span> balance1())
</span></span><span style=display:flex><span>    revert InsufficientInputAmount();
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>Again, we&rsquo;re using a callback to pass the control to the caller and let it transfer the tokens. After that, we&rsquo;re checking
that pool&rsquo;s balance is correct and includes the input amount.</p><p>Finally, the contract emits a <code>Swap</code> event to make the swap discoverable. The event includes all the information about
the swap:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>...
</span></span><span style=display:flex><span>emit Swap(
</span></span><span style=display:flex><span>    msg.sender,
</span></span><span style=display:flex><span>    recipient,
</span></span><span style=display:flex><span>    amount0,
</span></span><span style=display:flex><span>    amount1,
</span></span><span style=display:flex><span>    slot0.sqrtPriceX96,
</span></span><span style=display:flex><span>    liquidity,
</span></span><span style=display:flex><span>    slot0.tick
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>And that&rsquo;s it! The function simply sends some amount of tokens to the specified recipient address and expects a certain
number of the other token in exchange. Throughout this book, the function will get much more complicated.</p><h2 id=testing-swapping>Testing Swapping
<a class=anchor href=#testing-swapping>#</a></h2><p>Now, we can test the swap function. In the same test file, create <code>testSwapBuyEth</code> function and set up the test case. This
test case uses the same parameters as <code>testMintSuccess</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>testSwapBuyEth</span>() <span style=color:#66d9ef>public</span> {
</span></span><span style=display:flex><span>    TestCaseParams <span style=color:#66d9ef>memory</span> params <span style=color:#f92672>=</span> TestCaseParams({
</span></span><span style=display:flex><span>        wethBalance<span style=color:#f92672>:</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>ether</span>,
</span></span><span style=display:flex><span>        usdcBalance<span style=color:#f92672>:</span> <span style=color:#ae81ff>5000</span> <span style=color:#66d9ef>ether</span>,
</span></span><span style=display:flex><span>        currentTick<span style=color:#f92672>:</span> <span style=color:#ae81ff>85176</span>,
</span></span><span style=display:flex><span>        lowerTick<span style=color:#f92672>:</span> <span style=color:#ae81ff>84222</span>,
</span></span><span style=display:flex><span>        upperTick<span style=color:#f92672>:</span> <span style=color:#ae81ff>86129</span>,
</span></span><span style=display:flex><span>        liquidity<span style=color:#f92672>:</span> <span style=color:#ae81ff>1517882343751509868544</span>,
</span></span><span style=display:flex><span>        currentSqrtP<span style=color:#f92672>:</span> <span style=color:#ae81ff>5602277097478614198912276234240</span>,
</span></span><span style=display:flex><span>        shouldTransferInCallback<span style=color:#f92672>:</span> <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>        mintLiqudity<span style=color:#f92672>:</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>uint256</span> poolBalance0, <span style=color:#66d9ef>uint256</span> poolBalance1) <span style=color:#f92672>=</span> setupTestCase(params);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ...
</span></span></code></pre></div><p>Next steps will be different, however.</p><blockquote><p>We&rsquo;re not going to test that liquidity has been correctly added to the pool since we tested this functionality in the
other test cases.</p></blockquote><p>To make the test swap, we need 42 USDC:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>token1.mint(<span style=color:#66d9ef>address</span>(this), <span style=color:#ae81ff>42</span> <span style=color:#66d9ef>ether</span>);
</span></span></code></pre></div><p>Before making the swap, we need to ensure we can transfer tokens to the pool contract when it requests them:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>uniswapV3SwapCallback</span>(<span style=color:#66d9ef>int256</span> amount0, <span style=color:#66d9ef>int256</span> amount1) <span style=color:#66d9ef>public</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (amount0 <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        token0.transfer(msg.sender, <span style=color:#66d9ef>uint256</span>(amount0));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (amount1 <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        token1.transfer(msg.sender, <span style=color:#66d9ef>uint256</span>(amount1));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Since amounts during a swap can be positive (the amount that&rsquo;s sent to the pool) and negative (the amount that&rsquo;s taken
from the pool), in the callback, we only want to send the positive amount, i.e. the amount we&rsquo;re trading in.</p><p>Now, we can call <code>swap</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>(<span style=color:#66d9ef>int256</span> amount0Delta, <span style=color:#66d9ef>int256</span> amount1Delta) <span style=color:#f92672>=</span> pool.swap(<span style=color:#66d9ef>address</span>(this));
</span></span></code></pre></div><p>The function returns token amounts used in the swap, and we can check them right away:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>assertEq(amount0Delta, <span style=color:#f92672>-</span><span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>008396714242162444</span> <span style=color:#66d9ef>ether</span>, <span style=color:#e6db74>&#34;invalid ETH out&#34;</span>);
</span></span><span style=display:flex><span>assertEq(amount1Delta, <span style=color:#ae81ff>42</span> <span style=color:#66d9ef>ether</span>, <span style=color:#e6db74>&#34;invalid USDC in&#34;</span>);
</span></span></code></pre></div><p>Then, we need to ensure that tokens were actually transferred from the caller:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>assertEq(
</span></span><span style=display:flex><span>    token0.balanceOf(<span style=color:#66d9ef>address</span>(this)),
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span>(userBalance0Before <span style=color:#f92672>-</span> amount0Delta),
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;invalid user ETH balance&#34;</span>
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>assertEq(
</span></span><span style=display:flex><span>    token1.balanceOf(<span style=color:#66d9ef>address</span>(this)),
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;invalid user USDC balance&#34;</span>
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>And sent to the pool contract:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>assertEq(
</span></span><span style=display:flex><span>    token0.balanceOf(<span style=color:#66d9ef>address</span>(pool)),
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span>(<span style=color:#66d9ef>int256</span>(poolBalance0) <span style=color:#f92672>+</span> amount0Delta),
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;invalid pool ETH balance&#34;</span>
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>assertEq(
</span></span><span style=display:flex><span>    token1.balanceOf(<span style=color:#66d9ef>address</span>(pool)),
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span>(<span style=color:#66d9ef>int256</span>(poolBalance1) <span style=color:#f92672>+</span> amount1Delta),
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;invalid pool USDC balance&#34;</span>
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>Finally, we&rsquo;re checking that the pool state was updated correctly:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>(<span style=color:#66d9ef>uint160</span> sqrtPriceX96, <span style=color:#66d9ef>int24</span> tick) <span style=color:#f92672>=</span> pool.slot0();
</span></span><span style=display:flex><span>assertEq(
</span></span><span style=display:flex><span>    sqrtPriceX96,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>5604469350942327889444743441197</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;invalid current sqrtP&#34;</span>
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>assertEq(tick, <span style=color:#ae81ff>85184</span>, <span style=color:#e6db74>&#34;invalid current tick&#34;</span>);
</span></span><span style=display:flex><span>assertEq(
</span></span><span style=display:flex><span>    pool.liquidity(),
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>1517882343751509868544</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;invalid current liquidity&#34;</span>
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>Notice that swapping doesn&rsquo;t change the current liquidity–in a later chapter, we&rsquo;ll see when it does change it.</p><h2 id=homework>Homework
<a class=anchor href=#homework>#</a></h2><p>Write a test that fails with <code>InsufficientInputAmount</code> error. Keep in mind that there&rsquo;s a hidden bug 🙂</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#first-swap>First Swap</a><ul><li><a href=#calculating-swap-amounts>Calculating Swap Amounts</a></li><li><a href=#implementing-a-swap>Implementing a Swap</a></li><li><a href=#testing-swapping>Testing Swapping</a></li><li><a href=#homework>Homework</a></li></ul></li></ul></nav></div></aside></main></body></html>