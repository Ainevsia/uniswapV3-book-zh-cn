<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Introduction on Uniswap V3 Book 中文版</title>
    <link>https://uniswapv3book.com/</link>
    <description>Recent content in Introduction on Uniswap V3 Book 中文版</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language><atom:link href="https://uniswapv3book.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introduction</title>
      <link>https://uniswapv3book.com/docs/milestone_4/introduction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_4/introduction/</guid>
      <description>Multi-pool Swaps # After implementing cross-tick swaps, we&amp;rsquo;ve got really close to real Uniswap V3 swaps. One significant limitation of our implementation is that it allows only swaps within a pool–if there&amp;rsquo;s no pool for a pair of tokens, then swapping between these tokens is not possible. This is not so in Uniswap since it allows multi-pool swaps. In this chapter, we&amp;rsquo;re going to add multi-pool swaps to our implementation.</description>
    </item>
    
    <item>
      <title>Introduction</title>
      <link>https://uniswapv3book.com/docs/milestone_5/introduction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_5/introduction/</guid>
      <description>Fees and Price Oracle # In this milestone, we&amp;rsquo;re going to add two new features to our Uniswap implementation. They share one similarity: they work on top of what we have already built–that&amp;rsquo;s why we&amp;rsquo;ve delayed them until this milestone. However, they&amp;rsquo;re not equally important.
We&amp;rsquo;re going to add swap fees and a price oracle:
Swap fees is a crucial mechanism of the DEX design we&amp;rsquo;re implementing. They&amp;rsquo;re the glue that makes things stick together.</description>
    </item>
    
    <item>
      <title>Introduction</title>
      <link>https://uniswapv3book.com/docs/milestone_6/introduction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_6/introduction/</guid>
      <description>\[ \] NFT Positions # This is the cherry on the cake of this book. In this milestone, we&amp;rsquo;re going to learn how Uniswap contract can be extended and integrated into third-party protocols. This possibility is a direct consequence of having core contracts with only crucial functions, which allows to integrate them into other contracts without the need of adding new features to core contracts.
A bonus feature of Uniswap V3 was the ability to turn liquidity positions into NFT tokens.</description>
    </item>
    
    <item>
      <title>中英名词对照</title>
      <link>https://uniswapv3book.com/docs/reference/dictionary/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/reference/dictionary/</guid>
      <description> 中文 英文简称 全称 去中心化交易所 DEX Decentralized Exchange 中心化交易所 CEX Centralized Exchange 流动性 liquidity liquidity 流动性提供者 LP Liquidity Provider 自动做市商 AMM Automated Market Maker 恒定函数做市商 CFMM Constant Function Market Maker </description>
    </item>
    
    <item>
      <title>交易市场简介</title>
      <link>https://uniswapv3book.com/docs/introduction/introduction-to-markets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/introduction/introduction-to-markets/</guid>
      <description>交易市场简介 # 中心化交易所(CEX)如何工作 # 在本书中，我们将会搭建一个运行在以太坊(Ethereum)上的去中心化交易所(DEX)。DEX的设计模式非常复杂多样，因此我们先来考虑中心化交易所的设计。中心化交易所(CEX)的核心为订单簿(order book)，存储了用户的所有买单和卖单。订单簿中的每一笔订单都包含了订单成交的价格以及成交数量。
交易能够正常进行的保障是流动性(liquidity)，也即整个市场中所有可获得的资产数目。假设你希望购买一个衣柜但是没有人售卖，即为没有流动性；如果你希望卖出一个衣柜但是没有人愿意购买，即为市场有流动性但是没有买方。没有流动性，就无法在市场中进行买卖。
在CEX中，流动性存放在订单簿中。如果某个用户提交了一个卖单，他就为市场提供了流动性；如果某人提交了一个买单，他们希望市场有流动性，否则交易就无法进行。
如果市场没有流动性，但是仍然希望进行交易，就需要做市商(market maker)。做市商是向市场提供流动性的，拥有大量各种资产的公司或个人。通过提供流动性，做市商能够从交易中获取利润。
去中心化交易所(DEX)如何工作 # 毫无疑问，去中心化的交易也需要流动性，并且也需要做市商向市场提供多种资产的流动性。然而，在DEX中这个过程无法被中心化地处理，我们需要一种去中心化的做市商方案。相关解决方案非常多样化，而本书将主要关注Uniswap提供的方案。
自动做市商(AMM) # 链上交易市场的历史 一文提到了一种称作自动做市商(Automated Market Maker)的思路。正如其名，这种算法能够自动化完成像做市商一样的工作。更进一步，这种算法是去中心化且无需许可的，也即：
没有被任何单个中心化机构控制 所有资产并不存储在同一地方 任何人在任何地点都能使用 什么是自动做市商AMM？ # 一个AMM是一套定义如何管理流动性的智能合约。每个单独的交易对（例如ETH/USDC）都是一个单独的智能合约，存储了ETH和USDC的资产并且撮合交易，在这个合约中我们可以将ETH兑换成USDC或者将USDC兑换成ETH。
在AMM中，一个核心思想为池子(pooling)：每个合约都是一个存储流动性的池子，允许不同的用户（包括其他合约）在其中进行某种方式的交易。在AMM中有两种角色，*流动性提供者(LP)*以及交易者；这两者通过流动性池进行交互，交互的方式由合约进行规定且不可更改。
这种方法与CEX的关键区别在于： 智能合约是完全自动化的并且不受任何人控制。没有经理，没有系统管理员，没有特权用户，一切都没有。这里只有LP和交易者，任何人都可以担任这两种角色（也可以同时），并且所有的算法都是公开的、程序规定的、不可更改的。
在后面的篇章，我们将更进一步了解Uniswap是如何实现AMM的。
注意在后文中，pool和pair两个词可能会被交替使用，因为一个Uniswap的流动性池即一对token</description>
    </item>
    
    <item>
      <title>简介</title>
      <link>https://uniswapv3book.com/docs/milestone_1/introduction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_1/introduction/</guid>
      <description>\[ \] 第一笔交易 # 在本章中，我们将会搭建一个流动性池合约，能够接受用户的流动性并且在某个价格区间内做交易。为了尽可能简化，我们仅在一个价格区间内提供流动性，并且仅允许单向的交易。另外，为了更好地理解其中的数学原理，我们将手动计算其中用到的数学参数，暂不使用Solidity的数学库进行计算。
我们本章中要搭建的模型如下：
这是一个ETH/USDC的池子合约。ETH是资产$x$，USDC是资产$y$。 现货价格将被设置为一个ETH对5000USDC 我们提供流动性的价格区间为一个ETH对4545-5500USDC 我们将会从池子中购买ETH，并且保证价格在上述价格区间内。 模型的图像大致如下：
在开始代码部分之前，我们首先来手动计算模型中用到的所有数学参数。为了简单起见，作者将使用Python来进行计算而不是Solidity，因为Solidity在数学计算上有很多细微之处需要考虑。也就是说，我们将会把所有的参数硬编码进池子合约里。这会让我们获得一个最小可用的产品。
本章中所有用到的python计算都在unimath.py。
本章的完整代码可以参考这个github分支</description>
    </item>
    
    <item>
      <title>简介</title>
      <link>https://uniswapv3book.com/docs/milestone_2/introduction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_2/introduction/</guid>
      <description>第二笔交易 # OK，现在才是真正的开始。到目前为止，我们的实现看起来过于手动并且静态。我们手动计算了所有参数，硬编码了各种数量，来让学习曲线不那么陡峭；现在我们准备要让它真正地自动化工作了。我们将会实现第二笔交易，这次的交易是相反的方向：卖出ETH来获得USDC。为了达到这个目的，我们需要大幅度改进我们目前的合约：
我们需要在Solidity中实现数学运算。但是，由于Solidity仅支持整数除法，在Solidity中实现数学运算会比较困难。我们将使用第三方库来完成这部分 我们需要让用户能够选择交易的方向，并且池子合约需要支持双向的交易。我们将会改进合约，离跨价格区间的交易更进一步，而我们将在下一个milestone真正实现它。 最后，我们需要更新我们的UI来实现双向的交易以及获取金额的计算。这需要我们实现另一个合约，报价合约(Quoter)。 在本章节的最后，我们将会获得一个几乎和真正DEX类似的app！
让我们开始吧
本章节的所有代码可以在这个Github branch找到
本章会对我们之前实现的合约进行大量的更新。 在这里你可以看到与上一个milestone的所有代码差别</description>
    </item>
    
    <item>
      <title>简介</title>
      <link>https://uniswapv3book.com/docs/milestone_3/introduction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_3/introduction/</guid>
      <description>跨tick交易 # 我们现在已经完成了Uniswap V3实现的很大一部分，并且已经很接近原版了！然而，我们的实现仅仅支持在同一个价格区间内的交易——这也是我们在这一个milestone中来改进的点。
在这个milestone中，我们会：
更新mint函数，使得能够在不同的价格区间提供流动性 更新swap函数，使得在当前价格区间流动性不足时能够跨价格区间交易 学习如何在智能合约中计算流动性 在mint和swap函数中实现花店控制 更新前端用户界面，使得能够在不同价格区间添加流动性 增加对于定点数运算的一些了解 在这个milestone中，我们将彻底完成swap这个Uniswap中最核心的功能！
让我们开始吧。
本章的完整代码可以参考这个Github分支
这个milestone也对于已有的合约做了许多修改，你可以在这里看到在上一个milestone基础上进行的改动
如果你关于本章有任何问题，欢迎在本章的Github Discussion提问和交流！</description>
    </item>
    
    <item>
      <title>ERC721 Overview</title>
      <link>https://uniswapv3book.com/docs/milestone_6/erc721-overview/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_6/erc721-overview/</guid>
      <description>ERC721 Overview # Let&amp;rsquo;s begin with an overview of EIP-721, the standard that defines NFT contracts.
ERC721 is a variant of ERC20. The main difference between them is that ERC721 tokens are non-fungible, that is: one token is not identical to another. To distinguish ERC721 tokens, each of them has a unique ID, which is almost always the counter at which a token was minted. ERC721 tokens also have an extended concept of ownership: owner of each token is tracked and stored in the contract.</description>
    </item>
    
    <item>
      <title>Factory Contract</title>
      <link>https://uniswapv3book.com/docs/milestone_4/factory-contract/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_4/factory-contract/</guid>
      <description>Factory Contract # Uniswap is designed in a way that assumes many discrete Pool contracts, with each pool handling swaps of one token pair. This looks problematic when we want to swap between two tokens that don&amp;rsquo;t have a pool–is there&amp;rsquo;s no pool, no swaps are possible. However, we can still do intermediate swaps: first swap to a token that has pairs with either of the tokens and then swap this token to the target token.</description>
    </item>
    
    <item>
      <title>Swap Fees</title>
      <link>https://uniswapv3book.com/docs/milestone_5/swap-fees/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_5/swap-fees/</guid>
      <description>\[ \] Swap Fees # As I mentioned in the introduction, swap fees is a core mechanism of Uniswap. Liquidity providers need to get paid for the liquidity they provide, otherwise they&amp;rsquo;ll just use it somewhere else. To incentivize them, trades pay a small fee during each swap. These fees then distributed among all liquidity providers pro rata (proportionally to their share in total pool liquidity).
To better understand the mechanism of fees collection and distribution, let&amp;rsquo;s see how they work.</description>
    </item>
    
    <item>
      <title>不同价格区间</title>
      <link>https://uniswapv3book.com/docs/milestone_3/different-ranges/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_3/different-ranges/</guid>
      <description>\[ \] 不同价格区间 # 在我们之前的实现中，我们仅仅创建包含现价的价格区间：
// src/UniswapV3Pool.sol function mint( ... amount0 = Math.calcAmount0Delta( slot0_.sqrtPriceX96, TickMath.getSqrtRatioAtTick(upperTick), amount ); amount1 = Math.calcAmount1Delta( slot0_.sqrtPriceX96, TickMath.getSqrtRatioAtTick(lowerTick), amount ); liquidity += uint128(amount); ... } 从这段代码中你也可以看到，我们总是会更新流动性tracker（跟踪现在可用的流动性，即在现价时候可用的流动性）。
然而，在现实中，也可以创建低于或高于现价的价格区间。Uniswap V3的设计允许LP提供当前不可用的流动性。这些流动性只有当现价进入这些“休眠”的流动性取件时才会被“注入”。
以下是几种可能存在的价格区间情况：
活跃价格区间，也即包含现价的价格区间 低于现价的价格区间，该价格区间的上界tick低于现价tick 高于现价的价格区间，该价格区间的下界tick高于现价tick 限价单 # 一个有趣的事实是：非活跃的流动性（所在区间不包含现价）可以被看做是限价单(limit orders)。
在交易中，限价单是一种当价格突破用户设定的某个点的时候才会被执行的订单。例如，你希望放一个限价单，当ETH价格低于$1000的时候买入一个ETH。类似地，你可以使用限价单来出售资产。在Uniswap V3中，你可以通过在非活跃价格区间提供流动性来达到类似的目的。让我们来看一下它如何工作：
如果你在低于或高于现价的位置提供流动性（整个价格区间都低于/高于现价），那么你提供的流动性将完全由一种资产组成——两种资产中较便宜的那一种。在我们的例子中，我们的池子是把ETH作为 token $x$，把USDC作为 token $y$ ，我们的价格定义为：
$$P = \frac{y}{x}$$
如果我们把流动性放置在低于现价的区间，那么流动性将只会由USDC组成，因为当我们添加流动性的时候USDC的价格低于现价。类似地，如果我们高于现价的区间提供流动性，那么流动性将完全由ETH组成，因为ETH的价格低于现价。
回顾一下我们在简介中的图表：
如果我们购买这个区间中所有可用的ETH，这个区间内将只会由另一种token组成，USDC，并且价格将会沿着曲线移动到最右边。这个价格，也即 $\frac{y}{x}$，会升高。如果有一个价格区间在当前区间的右边，它将需要提供ETH的流动性，并且仅包含ETH：它需要为接下来的交易提供ETH。如果我们持续购买并且拉高价格，我们可能会继续“耗尽”下一个价格区间，也即买走它所有的ETH并卖出USDC。同样，这个区间会以全部是USDC而中止，现价移出这个区间。
类似地，如果我们购买USDC，我们会使得价格向左移动并且从池子中移出USDC。下一个价格区间会仅包含USDC代币来满足需求，并且类似地，如果我们继续买光这个区间的所有USDC，它也会以仅包含ETH而中止。
注意到一个有趣的点：当跨越整个价格区间时，其中的流动性从一种token交易为另外一种。并且如果我们设置一个相当窄的价格区间，价格会快速越过整个区间，我们就得到了一个限价单！例如，如果我们想在某个低价点购入ETH，我们可以在一个低价区间提供仅包含USDC的流动性，等待价格越过这个区间。在这之后，我们就可以移出流动性，所有的USDC都转换成了ETH！
希望这个例子没有让你感到困惑，我觉得这是一个理解价格区间动态变化的很好的例子。
更新mint函数 # 为了支持上面提到的各种价格区间，我们需要知道现价究竟是低于、位于，还是高于用户提供的价格区间，并且计算相应的token数量。如果价格区间高于现价，我们希望它的流动性仅仅由 token $x$ 组成：
// src/UniswapV3Pool.sol function mint( ... if (slot0_.</description>
    </item>
    
    <item>
      <title>恒定函数做市商(CFMM)</title>
      <link>https://uniswapv3book.com/docs/introduction/constant-function-market-maker/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/introduction/constant-function-market-maker/</guid>
      <description>\[ \] 恒定函数做市商 (Constant Function Market Makers) # 本章节主要讲述了Uniswap V2白皮书中的内容. 理解其中的数学原理能帮助你更好地构建像Uniswap这样的应用, 不过假设你没有理解本章全部内容也没有关系
正如我们在上一节中提到的那样，AMM的构建有许多不同的方法。我们将主要关注与构建一种特定的AMM：恒定函数做市商（有时也被称为恒定乘积做市商）。尽管名字听起来很复杂，但是它的核心数学原理只是一个非常简单的公式：
$$x * y = k$$
仅此而已，这就是AMM.
$x$ 和 $y$ 是池子合约所拥有的两种资产的数目。$k$ 是它们的乘积，我们暂时不考虑它的实际值等于多少。
为什么只有两种资产x和y？ 每个Uniswap的池子仅包含两种token。我们使用x和y来表示一个池子中的两种资产，其中x代表第一个token，y代表第二个token。两种token的顺序并不重要。
恒定函数做市商的原理是：在每次交易后，k必须保持不变。当用户进行交易，他们通常将一种类型的token放入池子（也即他们打算卖出的token），并且将另一种类型的token移出池子（也即打算购买的token）。这笔交易会改变池子中两种资产的数量，而上述原理表示，两种资产数目的乘积必须保持不变。我们之后还会在本书中看到许多次这个原理，这就是Uniswap的核心机制。
交易函数 # 现在我们知道了什么是池子以及交易的原理，接下来我们写一下交易发生时的公式：
$$(x + r\Delta x)(y - \Delta y) = k$$
一个池子包含一定数量的token 0 ($x$)和一定数量的token 1 ($y$) 当我们用token 0购买token 1的时候，一些token 0被放入池子 ($\Delta x$) 这个池子将给我们一定数量的token 1作为交换 ($\Delta y$) 池子也会从我们付出的token 0中收取一定数量的手续费 ($r$) 池子中token 0的数量发生了变化 ($x + r \Delta x$)， token 1的数量也发生了变化 ($y - \Delta y$) 二者的乘积保持不变，仍然为 $k$ 我们使用token 0和token 1这样的表述是因为代码中就是如此命名的。在现在，两个token的顺序并不关键</description>
    </item>
    
    <item>
      <title>计算流动性</title>
      <link>https://uniswapv3book.com/docs/milestone_1/calculating-liquidity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_1/calculating-liquidity/</guid>
      <description>\[ \] 计算流动性 # 没有流动性就无法进行交易，因此为了能够完成我们的第一笔交易，我们首先需要向池子中添加一些流动性。为了向池子合约添加流动性，我们需要知道：
一个价格区间，即LP希望他的流动性仅在这个区间上提供和被利用 提供流动性的数量，也即提供的两种代币的数量，我们需要将它们转入池子合约。 在本节中，我们会手动计算上述变量的值；在后续章节中，我们会在合约中对此进行实现。首先我们来考虑价格区间
价格区间计算 # 回忆一下上一章所讲，在Uniswap V3中，整个价格区间被划分成了ticks：每个tick对应一个价格，以及有一个编号。在我们的第一个实现中，我们的现货价格设置为1ETH对5000USDC。购买ETH会移除池子中的一部分ETH，从而使得价格变得高于5000USDC。我们希望在一个包含此价格的区间中提供流动性，并且要确保最终的价格落在这个区间内。（跨区间的交易将会在后续章节提到）。
我们需要找到3个tick：
对应现货价格的tick（1ETH-5000USDC） 提供流动性的价格区间上下界对应的tick。在这里，下界为4545u，上界为5500u。 （译者注：4545u，$4545，4545USDC均代表相同含义，在本书中可能会混合使用）
从之前的章节中我们知道下述公式：
$$\sqrt{P} = \sqrt{\frac{y}{x}}$$
由于我们把ETH作为资产$x$，USDC作为资产$y$，每个tick对应的值为：
$$\sqrt{P_c} = \sqrt{\frac{5000}{1}} = \sqrt{5000} \approx 70.71$$
$$\sqrt{P_l} = \sqrt{\frac{4545}{1}} \approx 67.42$$
$$\sqrt{P_u} = \sqrt{\frac{5500}{1}} \approx 74.16$$
在这里，$P_c$代表现货价格，$P_l$代表区间下界，$P_u$代表区间上界。
接下来，我们可以计算价格对应的ticks。使用下面公式：
$$\sqrt{P(i)}=1.0001^{\frac{i}{2}}$$
我们可以得到关于$i$的公式：
$$i = log_{\sqrt{1.0001}} \sqrt{P(i)}$$
公式中的两个根号实际上是可以消去的，但由于我们会使用$\sqrt{p}$进行计算，我们选择保留根号
这几个对应的tick分别为:
现货tick: $i_c = log_{\sqrt{1.0001}} 70.71 = 85176$ 下界tick: $i_l = log_{\sqrt{1.0001}} 67.42 = 84222$ 上界tick: $i_u = log_{\sqrt{1.0001}} 74.16 = 86129$ 计算过程使用的是Python：</description>
    </item>
    
    <item>
      <title>输出金额计算</title>
      <link>https://uniswapv3book.com/docs/milestone_2/output-amount-calculation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_2/output-amount-calculation/</guid>
      <description>\[ \] 输出金额计算 # 我们的Uniswap数学公式中还缺最后一个组成部分：计算卖出 ETH (即 token $x$ )时获得的资产数量。在前一章中，我们有一个类似的公式计算购买ETH(购买 token $x$)的场景：
$$\Delta \sqrt{P} = \frac{\Delta y}{L}$$
这个公式计算卖出token $y$时的价格变化。我们把这个差价加到现价上面，来得到目标价格：
$$\sqrt{P_{target}} = \sqrt{P_{current}} + \Delta \sqrt{P}$$
现在，我们需要一个类似的公式来计算卖出 token $x$（在本案例中为 ETH）买入 token $y$（在本案例中为 USDC）时的目标价格（在本案例中为卖出 ETH）。
回忆一下，token $x$ 的变化可以如下计算：
$$\Delta x = \Delta \frac{1}{\sqrt{P}}L$$
从上面公式，我们可以推导出目标价格：
$$\Delta x = (\frac{1}{\sqrt{P_{target}}} - \frac{1}{\sqrt{P_{current}}}) L$$ $$= \frac{L}{\sqrt{P_{target}}} - \frac{L}{\sqrt{P_{current}}}$$
$$\ \sqrt{P_{target}} = \frac{\sqrt{P}L}{\Delta x \sqrt{P} + L}$$
知道了目标价格，我们就能够用前一章类似的方式计算出输出的金额
更新一下对应的Python脚本
# Swap ETH for USDC amount_in = 0.</description>
    </item>
    
    <item>
      <title>Cross-Tick Swaps</title>
      <link>https://uniswapv3book.com/docs/milestone_3/cross-tick-swaps/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_3/cross-tick-swaps/</guid>
      <description>\[ \] Cross-Tick Swaps # Cross-tick swaps is probably the most advanced feature of Uniswap V3. Luckily, we have already implemented almost everything we need to make cross-tick swaps. Let&amp;rsquo;s see how cross-tick swaps work before implementing them.
How Cross-Tick Swaps Work # A common Uniswap V3 pool is a pool with many overlapping (and outstanding) price ranges. Each pool tracks current $\sqrt{P}$ and tick. When users swap tokens they move current price and tick to the left or to the right, depending on swap direction.</description>
    </item>
    
    <item>
      <title>Flash Loan Fees</title>
      <link>https://uniswapv3book.com/docs/milestone_5/flash-loan-fees/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_5/flash-loan-fees/</guid>
      <description>Flash Loan Fees # In a previous chapter we implemented flash loans and made them free. However, Uniswap collects swap fees on flash loans, and we&amp;rsquo;re going to add this to our implementation: the amounts repaid by flash loan borrowers must include a fee.
Here&amp;rsquo;s what the updated flash function looks like:
function flash( uint256 amount0, uint256 amount1, bytes calldata data ) public { uint256 fee0 = Math.mulDivRoundingUp(amount0, fee, 1e6); uint256 fee1 = Math.</description>
    </item>
    
    <item>
      <title>NFT Manager</title>
      <link>https://uniswapv3book.com/docs/milestone_6/nft-manager/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_6/nft-manager/</guid>
      <description>\[ \] NFT Manager Contract # Obviously, we&amp;rsquo;re not going to add NFT-related functionality to the pool contract–we need a separate contract that will merge NFTs and liquidity positions. Recall that, while working on our implementation, we built the UniswapV3Manager contract to facilitate interaction with pool contracts (to make some calculations simpler and to enable multi-pool swaps). This contract was a good demonstration of how core Uniswap contracts can be extended.</description>
    </item>
    
    <item>
      <title>Solidity中的数学运算</title>
      <link>https://uniswapv3book.com/docs/milestone_2/math-in-solidity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_2/math-in-solidity/</guid>
      <description>\[ \] Solidity中的数学运算 # 由于Solidity不支持浮点数，在其中的运算会有些复杂。Solidity拥有整数(integer)和无符号整数(unsigned integer)类型，这并不足够让我们实现复杂的数学运算。
另一个困难之处在于gas消耗：一个算法越复杂，它消耗的gas就越多。因此，如果我们需要比较高级的数学运算（例如exp, ln, sqrt），我们会希望它们尽可能节省gas。
还有一个很大的问题是溢出。当进行uint256类型的乘法时，有溢出的风险：结果的数据可能会超出256位。
所有的上述困难都让我们不得不使用那些实现了高级数学运算并进行了gas优化的第三方库。如果库里面没有我们需要的算法，我们就需要自己来实现，这将会是一个很困难的任务。
重用数学库 # 在我们的Uniswap V3实现中，我们会使用两个第三方数学库：
PRBMath，一个包含了复杂的定点数运算的库。我们会使用其中的mulDiv函数来处理乘除法过程中可能的溢出 TickMath，来自原始的Uniswap V3仓库。这个合约实现了两个函数，getSqrtRatioAtTick 和 getTickAtSqrtRatio，功能是在tick和$\sqrt{P}$之间相互转换。 我们先关注第二个库。在我们的合约中，我们需要将tick转换成对应的$\sqrt{P}$，或者反过来。对应的公式为：
$$\sqrt{P(i)} = \sqrt{1.0001^i} = 1.0001^{\frac{i}{2}}$$
$$i = log_{\sqrt{1.0001}}\sqrt{P(i)}$$
这些是非常复杂的数学运算（至少在Solidity中是这样）并且它们需要很高的精度，因为我们不希望取整的问题干扰我们的价格计算。为了能实现更高的精度和gas优化，我们需要特定的实现。
如果你看一下getSqrtRatioAtTick和getTickAtSqrtRatio的代码，你会发现它们非常复杂：其中有大量的magic number（像0xfffcb933bd6fad37aa2d162d1a594001这样），乘法以及位运算。在当前阶段，我们不会试图分析这些代码或者尝试重新实现它们，因为这会是另一个不同的且复杂的主题。我们在这里仅仅使用它们。在后续的章节中，我们可能会深入探讨这部分代码。</description>
    </item>
    
    <item>
      <title>Swap Path</title>
      <link>https://uniswapv3book.com/docs/milestone_4/path/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_4/path/</guid>
      <description>Swap Path # Let&amp;rsquo;s imagine that we have only these pools: WETH/USDC, USDC/USDT, WBTC/USDT. If we want to swap WETH for WBTC, we&amp;rsquo;ll need to make multiple swaps (WETH→USDC→USDT→WBTC) since there&amp;rsquo;s no WETH/WBTC pool. We can do this manually or we can improve our contracts to handle such chained, or multi-pool, swaps. Of course, we&amp;rsquo;ll do the latter!
When doing multi-pool swaps, we&amp;rsquo;re sending output of a previous swap to the input of the next one.</description>
    </item>
    
    <item>
      <title>Uniswap V3</title>
      <link>https://uniswapv3book.com/docs/introduction/uniswap-v3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/introduction/uniswap-v3/</guid>
      <description>\[ \] Uniswap V3简介 # 本章节主要讲述了Uniswap V3白皮书中的内容。同样，假设你没有理解本章的所有概念也没有关系，我们在后面章节直接看代码可能会更清晰。
为了更好地理解Uniswap V3的创新之处在哪里，我们首先来看Uniswap V2的缺点有哪些。
Uniswap V2使用AMM机制实现了一个通用的交易市场。然而，并不是所有的交易对都是平等的，交易对可以根据价格的波动性分为以下两类
价格波动性为中等或高的代币对。这一类包含绝大多数的代币，因为绝大多数代币并没有锚定(pegged to)到某些东西，因此其价格随着市场波动而波动。 价格波动性低的代币对。这一类包含了有锚定的代币，主要为稳定币：USDT/USDC，USDC/DAI，USDT/DAI等等。也包括ETH/stETH，ETH/rETH（一些wrapped ETH）等类型。 这些类对于我们称作“流动性池配置”的概念有不同的要求。最主要的区别在于，锚定代币对需要非常高的流动性来降低大额交易对其的影响。USDC与USDT的价格必须保持在1附近，无论我要买卖多大数目的代币。由于Uniswap V2的通用AMM算法对于稳定币交易并没有很好的适配，其他的AMM（主要是Curve）则在稳定币交易中更加流行。
导致这个问题出现的原因在于，Uniswap V2池子的流动性是分布在无穷区域上的-即池子允许在任何价格的交易发生，从0到正无穷：
这听起来不是一个坏事，但事实上它导致了资本利用效率的不足。一个资产的历史价格通常是在某个区间内的，不管这个区间是大还是小。比如，ETH的历史价格大致在$0.75 到 $4,800 这个区间（数据来源CoinMarketCap）。在今天（2022年6月，1个ETH的现货价格是$1800，没有人会愿意用$5000购买一个ETH，所以在这个点提供流动性是毫无用处的。因此，在远离当前价格区间的、永远不会达到的某个点上提供流动性是毫无意义的
当然，我们都相信ETH的价格某天会达到$10000 （译者注：仅代表原作者观点）
集中流动性 # Uniswap V3引入了 集中流动性(concentrated liquidity) 的概念：LP可以选择他们希望在哪个价格区间提供流动性。这个机制通过将更多的流动性提供在一个相对狭窄的价格区间，从而大大提高了资本利用效率；这也使Uniswap的使用场景更加多样化：它现在可以对于不同价格波动性的池子进行不同的配置。这就是V3相对于V2的提升点。
简单地来说，一个Uniswap V3的交易对是许多个Uniswap V2的交易对。V2与V3的区别是，在V3中，一个交易对有许多的价格区间，而每个价格区间内都有有限数量的资产。从零到正无穷的整个价格区间被划分成了许多个小的价格区间，每一个区间中都有一定数量的流动性。而更关键的点在于，在每个小的价格区间中，工作机制与Uniswap V2一样。这也是为什么说一个Uniswap V3的池子就是许多个V2的池子。
下面，我们来对这种机制进行可视化。我们并不是重新选择一个有限的曲线，而是我们把它在价格$a$ 与价格$b$ 之间的部分截取出来，认为它们是曲线的边界。更进一步，我们把曲线进行平移使得边界点落在坐标轴上，于是得到了下图：
它看起来或许有点孤单， 因此Uniswap V3有许多的价格区间——这样它们就不会感到孤单了 🙂
正如我们在前一章中讲到的那样，交易token使得价格在曲线上移动，而价格区间限制了价格点的移动。当价格移动到曲线的一端时，我们说这个池子被耗尽了：其中一种代币的资产变成了0，无法再购买这种代币（当然，仅仅指在这个价格区间内）
假设起始价格在上面途中曲线的中间点。为了到达点$a$，我们需要购买池子里所有的$y$来使得池子里的$x$最大化；为了到达点$b$，我们需要买光池子里的$x$从而使$y$最大化。在这两个点，池子里都只剩一种token。
一个有趣的点：根据这个原理，可以利用V3的价格区间来挂限价单
如果当前价格区间池子被耗尽将会发生什么？价格点会滑动到下一个价格区间。如果下一个价格区间不存在，这笔交易就会以部分成交而结束——我们将在本书后面的部分看到其如何实现。
下面一图展示了USDC/ETH池子的流动性分布:
可以看到，大量流动性集中在现在价格的附近，而较远的价格区间中的流动性较少——这是因为LP更希望提高它们的资产利用效率。当然，整个区间也不是无穷的，在图片右侧也显示了其上界。
Uniswap V3的数学原理 # 在数学原理上，V3是基于V2的：它们使用了相同的底层公式，但实际上V3使用的是可以被称作增强版。
为了处理价格区间之间的转换，简化流动性管理，以及避免取整出现问题，V3使用了下面这些新的标识：
$$L = \sqrt{xy}$$
$$\sqrt{P} = \sqrt{\frac{y}{x}}$$
$L$ 被称作 流动性数量。池子中的流动性是两种token资产数量的组合。我们知道按照公式，两种代币数量乘积为$k$，因此我们可以用 $\sqrt{xy}$ 来衡量池子流动性。$L$ 实际上是 $x$ 和 $y$ 的几何平均数。</description>
    </item>
    
    <item>
      <title>提供流动性</title>
      <link>https://uniswapv3book.com/docs/milestone_1/providing-liquidity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_1/providing-liquidity/</guid>
      <description>\[ \] 提供流动性 # 有了这些理论，我们现在可以开始写代码了！
新建一个文件夹，cd进去运行forge init --vscode-来初始化一个Forge项目。加上--vscode会让Forge配置vscode的Solidity插件。 删除其中的合约和测试文件：
script/Contract.s.sol src/Contract.sol test/Contract.t.sol 现在，我们可以开始写我们的第一个合约了~
池子合约 # 正如我们在简介中提到的那样，Uniswap部署了多个池子合约，每一个都是负责一对token的交易。Uniswap的所有合约被分为以下两类：
核心合约(core contracts) 外部合约(periphery contracts) 正如其名，核心合约实现了核心的逻辑。这些合约是最小的，对用户不友好的，底层的合约。这些合约都只做一件事并且保证这件事尽可能地安全。在Uniswap V3中，核心合约包含以下两个：
池子(Pool)合约，实现了去中心化交易的核心逻辑 工厂(Factory)合约，作为池子合约的注册入口，使得部署池子合约更加简单。 我们将会从池子合约开始，这部分实现了Uniswap 99%的核心功能。
创建 src/UniswapV3Pool.sol:
pragma solidity ^0.8.14; contract UniswapV3Pool {} 让我们想一下这个合约需要存储哪些数据：
由于每个合约都是一对token的交易市场，我们需要存储两个token的地址。这些地址是静态的，仅设置一次并且保持不变的。(因此，这些变量需要被设置为immutable) 每个池子合约包含了一系列的流动性位置，我们需要用一个mapping来存储这些信息，key代表不同位置，value是包含这些位置相关的信息。 每个池子合约都包含一些tick的信息，需要一个mapping来存储tick的编号与对应的信息 tick的范围是固定的，这些范围在合约中存为常数 需要存储池子流动性的数量$L$ 最后，我们还需要跟踪现在的价格和对应的tock。我们将会把他们存储在一个slot中来节省gas费：因为这些变量会被频繁读写，所以我们需要充分考虑Solidity变量在存储中的分布特点 总之，合约大概存储了以下这些信息：
// src/lib/Tick.sol library Tick { struct Info { bool initialized; uint128 liquidity; } ... } // src/lib/Position.sol library Position { struct Info { uint128 liquidity; } ... } // src/UniswapV3Pool.</description>
    </item>
    
    <item>
      <title>Multi-pool Swaps</title>
      <link>https://uniswapv3book.com/docs/milestone_4/multi-pool-swaps/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_4/multi-pool-swaps/</guid>
      <description>Multi-pool Swaps # We&amp;rsquo;re now proceeding to the core of this milestone–implementing multi-pool swaps in our contracts. We won&amp;rsquo;t touch Pool contract in this milestone because it&amp;rsquo;s a core contract that should implement only core features. Multi-pool swaps is a utility feature, and we&amp;rsquo;ll implement it in Manager and Quoter contracts.
Updating Manager Contract # Single-pool and Multi-pool Swaps # In our current implementation, swap function in Manager contract supports only single-pool swaps and takes pool address in parameters:</description>
    </item>
    
    <item>
      <title>NFT Renderer</title>
      <link>https://uniswapv3book.com/docs/milestone_6/nft-renderer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_6/nft-renderer/</guid>
      <description>NFT Renderer # Now we need to build an NFT renderer: a library that will handle calls to tokenURI in the NFT manager contract. It will render JSON metadata and an SVG for each minted token. As we discussed earlier, we&amp;rsquo;ll use the data URI format, which requires base64 encoding–this means we&amp;rsquo;ll need a base64 encoder in Solidity. But first, let&amp;rsquo;s look at what our tokens will look like.</description>
    </item>
    
    <item>
      <title>Protocol Fees</title>
      <link>https://uniswapv3book.com/docs/milestone_5/protocol-fees/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_5/protocol-fees/</guid>
      <description>\[ \] Protocol Fees # While working on the Uniswap implementation, you&amp;rsquo;ve probably asked yourself, &amp;ldquo;How does Uniswap make money?&amp;rdquo; Well, it doesn&amp;rsquo;t (at least as of September 2022).
In the implementation we&amp;rsquo;ve built so far, traders pay liquidity providers for providing liquidity, and Uniswap Labs, as the company that developed the DEX, is not part of this process. Neither traders, nor liquidity providers pay Uniswap Labs for using the Uniswap DEX.</description>
    </item>
    
    <item>
      <title>Slippage Protection</title>
      <link>https://uniswapv3book.com/docs/milestone_3/slippage-protection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_3/slippage-protection/</guid>
      <description>\[ \] Slippage Protection # Slippage is a very important issued in decentralized exchanges. Slippage simply means the difference between the price that you see on the screen when initialing a transaction and the actual price the swap is executed at. This difference appears because there&amp;rsquo;s a short (and sometimes long, depending on network congestion and gas costs) delay between when you send a transaction and when it gets mined.</description>
    </item>
    
    <item>
      <title>Tick Bitmap Index</title>
      <link>https://uniswapv3book.com/docs/milestone_2/tick-bitmap-index/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_2/tick-bitmap-index/</guid>
      <description>\[ \] Tick Bitmap Index # (译者注：由于bitmap也是数据结构中的常见名词，所以在此不做翻译)
作为我们开始动态交易的第一步，我们需要建立一个ticks的索引。在前一个milestone中，我们手动计算并硬编码了目标位置的tick：
function swap(address recipient, bytes calldata data) public returns (int256 amount0, int256 amount1) { int24 nextTick = 85184; ... } 当流动性在不同的价格区间中时，我们很难简单地计算出目标tick。事实上，我们需要根据不同区间中的流动性来找到它。因此，我们需要对于所有拥有流动性的tick建立一个索引，之后使用这个索引来寻找tick直到“填满”当前交易所需的流动性。在本小节中，我们将会实现一个这样的索引。
Bitmap # Bitmap是一个用压缩的方式提供数据索引的常用数据结构。一个bitmap实际上就是一个0和1构成的数组，其中的每一位的位置和元素内容都代表某种外部的信息。每个元素可以是0或者1，可以被看做是一个flag：当值为0的时候，flag没有设置；当值为1的时候，flag被设置。这个方法受欢迎的原因是整个数组可以作为二进制被存在一个数字中。
例如，数组111101001101001就是数字31337。这个数字需要两个字节来存储（0x7a69），两字节能够存储16个flag（1字节=8位）。
Uniswap V3 使用这个技术来存储关于tick初始化的信息，也即哪个tick有流动性。当flag设置为(1)，对应的tick有流动性；当flag设置为(0)，对应的tick没有被初始化。让我们来看一下如何实现。
TickBitmap合约 # 在池子合约中，tick index存储为一个状态变量：
contract UniswapV3Pool { using TickBitmap for mapping(int16 =&amp;gt; uint256); mapping(int16 =&amp;gt; uint256) public tickBitmap; ... } 这里的存储方式是一个mapping，key的类型是int16，value的类型是uint256。想象一个无穷的0/1数组：
数组中每个元素都对应一个tick。为了更好地在数组中寻址，我们把数组按照字的大小划分：每个子数组为256位。为了找到数组中某个tick的位置，我们使用如下函数：
function position(int24 tick) private pure returns (int16 wordPos, uint8 bitPos) { wordPos = int16(tick &amp;gt;&amp;gt; 8); bitPos = uint8(uint24(tick % 256)); } 即：我们首先找到对应的字所在的位置，然后再找到字中的位的位置。&amp;gt;&amp;gt;8即除以256。除以256的商为字的位置，余数为位的位置。</description>
    </item>
    
    <item>
      <title>开发环境</title>
      <link>https://uniswapv3book.com/docs/introduction/dev-environment/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/introduction/dev-environment/</guid>
      <description>开发环境 # 本书中，我们会搭建两个应用：
链上：一套部署在以太坊上的智能合约 链下：一个与智能合约交互的前端应用 尽管本书把前端应用作为其中一部分，但不是我们的主要关注点。我们搭建前端仅仅为了展示智能合约是如何集成到前端应用中的。因为，前端部分是可选读内容，但在本书代码仓库中也提供者这部分的代码
以太坊简介 # 以太坊是一个允许任何人在上面运行应用的区块链。它与一个传统云服务的主要区别在于：
维持这个应用不需要付费，部署应用需要付费 应用代码是不可变的，在其部署后你没有办法再进行修改 用户调用你的应用需要花费gas（手续费） 为了更好地理解这些区别，我们来看一下以太坊的构建。
以太坊的核心（其他区块链也是同理）是一个数据库。这个数据库中最有价值的数据是账户状态。以太坊中的每个账户包含一个地址，以及以下数据：
余额：账户的以太坊(ether)余额 代码：部署在这个地址上的智能合约的字节码 存储：智能合约存储数据的空间 nonce：一个用来防止重放攻击的整数序号 （译者注：Ethereum和ether的中文译名均为以太坊，读者注意区分。Ethereum指的是这条区块链，ether指的是该链上的原生代币）
以太坊的主要任务是安全地维护这些数据，防止未经授权的更改。
同时，以太坊也是一个网络，网络中的每个计算机都独立地构建和维持这些状态。网络的主要目标是能够去中心化地访问数据库：没有任何单个权威机构可以单方面修改任何数据。这是通过叫做*共识(consensus)*的机制来实现的，即网络中节点遵守的一系列规则。如果有节点违反了规则，它将会被从这个网络中排除。
有趣的是，区块链也可以使用MSQL！只是可能会存在一定的性能问题。以太坊中使用的是LevelDB，一个高效的KV数据库。
每个以太坊节点运行EVM，以太坊虚拟机。虚拟机是一个能够执行其他程序的程序，EVM则是执行智能合约程序的程序。用户通过交易(transactions)与合约交互，除了能够简单的发送ether，交易也能够调用智能合约，需要传输的数据包括：
一个合约函数的签名 函数参数 交易被打包进区块，区块被矿工挖出。网络中的每个节点都可以验证每一个区块中的每一笔交易。
某种意义上来说，智能合约与JSON APIs有一定类似，区别就是你调用的是智能合约函数。与API的后端类似，智能合约也执行程序逻辑，并且也可能更改智能合约中存储的数据。与API不同的是，你需要发送一笔交易来改变区块链的状态，并且你需要为每一笔交易付费。
最后，以太坊节点也实现了一套JSON-RPC API。我们可以通过这个API与节点进行交互：获取账户余额、估算gas费、获取区块和交易、发送交易、执行不上链的智能合约调用（仅能读数据）。在这里你可以获得一个可用端点的列表。
交易也是通过这个API发送的, 参见 eth_sendTransaction.
本地开发环境 # 我们将要搭建智能合约并且在以太坊上运行它们，这意味着我们需要一个节点。在本地测试和运行合约也需要一个节点。曾经这使得智能合约开发十分麻烦，因为在一个真实节点上运行大量的测试会十分缓慢。不过现在已经有了很多快速简洁的解决方案。例如Truffle 和 Hardhat。不过这些工具的问题在于我们需要用JavaScript来写测试以及与区块链的交互，这事因为Truffle和Hardhat都运行了一个本地节点，并且使用JavaScript的Web3库来与节点交互。
我们将会选择一个新的框架，Foundry。
Foundry # Foundry是一套用于以太坊应用开发的工具包。我们将会使用以下这些工具：
Forge，一个Solidity的测试框架. Anvil，一个本地以太坊节点。我们将会用它来部署我们的合约，并且与前端app交互。 Cast, 一个非常好用的CLI工具。 Forge使智能合约开发更加容易。当使用Forge开发时，我们不需要运行一个本地节点来进行测试；Forge会在其内置的EVM上运行测试，大大加快了速度，不再需要给节点发送交易和挖出区块。除此以外，Forge还能够使用Solidity编写测试！Forge也内置了机制方便我们模拟区块链的各种状态：修改某个账户余额，从其他地址执行合约，把合约部署在任意地址等等。
然而，我们仍然需要一个本地节点来部署合约。在这里我们将会使用Anvil。前端应用可以使用JavaScript的Web3库来与以太坊节点进行交互。
Ethers.js # Ethers.js 是一个与Ethereum交互的JavaScript库. 这是Dapp开发中使用的两个最流行的JS库之一(另一个是web3.js)。这些库让我们可以使用JSON-API与以太坊节点交互，并且也有各种功能丰富的函数来帮助开发者更容易地开发应用。
MetaMask # MetaMask是一个浏览器中的以太坊钱包。它是一个浏览器插件，可以安全地创建和存储私钥。Metamask也是最常用的以太坊钱包应用，我们将使用它来与我们的本地运行的节点进行交互。
React # React 是前端开发中使用的一个著名的JS库. 本书并不要求会React，我们将会提供一个模板。、
准备开发环境 # 创建一个新的文件夹，并在其中运行 forge init ：
$ mkdir uniswapv3clone $ cd uniswapv3clone $ forge init 如果你使用Visual Studio Code进行开发，可以在forge init 中加入 --vscode 这个flas：forge init --vscode。Forge会在初始化时对于VSCode进行特别设置。</description>
    </item>
    
    <item>
      <title>第一笔交易</title>
      <link>https://uniswapv3book.com/docs/milestone_1/first-swap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_1/first-swap/</guid>
      <description>\[ \] 第一笔交易 # 现在我们已经有了流动性，我们可以进行我们的第一笔交易了！
计算交易数量 # 首先，我们需要知道如何计算交易出入的数量。同样，我们在这小节中也会硬编码我们希望交易的USDC数额，这里我们选择42，也即花费42USDC购买ETH
在决定了我们希望投入的资金量之后，我们需要计算我们会获得多少token。在Uniswap V2中，我们会使用现在池子的资产数量来计算，但是在V3中我们有$L$和$\sqrt{P}$，并且我们知道在交易过程中，$L$保持不变而只有$\sqrt{P}$发生变化（当在同一区间内进行交易时，V3的表现和V2一致）。我们还知道如下公式：
$$L = \frac{\Delta y}{\Delta \sqrt{P}}$$
并且，在这里我们知道了$\Delta y$！它正是我们希望投入的42USDC。因此，我们可以根据公式得出投入的 42USDC 会对价格造成多少影响：
$$\Delta \sqrt{P} = \frac{\Delta y}{L}$$
在V3中，我们选择我们希望交易导致的价格变动（回忆一下，交易使得现价沿着曲线移动）。知道了目标价格(target price)，合约可以计算出投入token的数量和输出token的数量。
我们将数字代入上述公式：
$$\Delta \sqrt{P} = \frac{42 \enspace USDC}{1517882343751509868544} = 2192253463713690532467206957$$
把差价加到现在的$\sqrt{P}$，我们就能得到目标价格：
$$\sqrt{P_{target}} = \sqrt{P_{current}} + \Delta \sqrt{P}$$
$$\sqrt{P_{target}} = 5604469350942327889444743441197$$
在Python中进行相应计算:
amount_in = 42 * eth price_diff = (amount_in * q96) // liq price_next = sqrtp_cur + price_diff print(&amp;#34;New price:&amp;#34;, (price_next / q96) ** 2) print(&amp;#34;New sqrtP:&amp;#34;, price_next) print(&amp;#34;New tick:&amp;#34;, price_to_tick((price_next / q96) ** 2)) # New price: 5003.</description>
    </item>
    
    <item>
      <title>Liquidity Calculation</title>
      <link>https://uniswapv3book.com/docs/milestone_3/liquidity-calculation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_3/liquidity-calculation/</guid>
      <description>\[ \] Liquidity Calculation # Of the whole math of Uniswap V3, what we haven&amp;rsquo;t yet implemented in Solidity is liquidity calculation. In the Python script, we have these functions:
def liquidity0(amount, pa, pb): if pa &amp;gt; pb: pa, pb = pb, pa return (amount * (pa * pb) / q96) / (pb - pa) def liquidity1(amount, pa, pb): if pa &amp;gt; pb: pa, pb = pb, pa return amount * q96 / (pb - pa) Let&amp;rsquo;s implement them in Solidity so we could calculate liquidity in the Manager.</description>
    </item>
    
    <item>
      <title>Price Oracle</title>
      <link>https://uniswapv3book.com/docs/milestone_5/price-oracle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_5/price-oracle/</guid>
      <description>\[ \] Price Oracle # The final mechanism we&amp;rsquo;re going to add to our DEX is a price oracle. Even though it&amp;rsquo;s not essential to a DEX (there are DEXes that don&amp;rsquo;t implement a price oracle), it&amp;rsquo;s still an important feature of Uniswap and something that&amp;rsquo;s interesting to learn about.
What is Price Oracle? # Price oracle is a mechanism that provides asset prices to blockchain. Since blockchains are isolated ecosystems, there&amp;rsquo;s no direct way of querying external data, e.</description>
    </item>
    
    <item>
      <title>User Interface</title>
      <link>https://uniswapv3book.com/docs/milestone_4/user-interface/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_4/user-interface/</guid>
      <description>User Interface # After introducing swap paths, we can significantly simplify the internals of our web app. First of all, every swap now uses a path since path doesn&amp;rsquo;t have to contain multiple pools. Second, it&amp;rsquo;s now easier to change the direction of swap: we can simply reverse the path. And, thanks to the unified pool address generation via CREATE2 and unique salts, we no longer need to store pool addresses and care about tokens order.</description>
    </item>
    
    <item>
      <title>管理合约</title>
      <link>https://uniswapv3book.com/docs/milestone_1/manager-contract/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_1/manager-contract/</guid>
      <description>管理合约(Manager Contract) # 在部署我们的池子合约之前，仍然有一个问题需要解决。我们之前提到过，Uniswap V3合约由两部分构成：
核心合约(core contracts)实现了最核心的功能，不提供用户友好的交互接口 外围合约(periphery contracts)为核心合约实现了用户友好的接口 池子合约是核心合约，它并不需要用户友好或者实现灵活功能。它需要调用者进行所有的计算并且提供合适的参数。同时，它也没有使用ERC20的transferFrom函数来从调用者处转账，而是使用了两个callback函数：
uniswapV3MintCallback，当铸造流动性的时候被调用 uniswapV3SwapCallback，当交易token的时候被调用 在我们的测试中，我们在测试合约中实现了这些函数。由于只有合约才能实现callback函数，池子合约并不能直接被普通用户(EOA)调用。这对核心合约是没问题的，但是我们接下来会解决它🙂。
我们下一步的目标是将这个池子合约部署在一个本地的区块链上，并且使用一个前端应用与其交互。因此我们需要创建一个合约，能够让非合约的地址也与池子进行交互。让我们来实现吧！
工作流程 # 下面我们描述了管理合约的功能：
为了铸造流动性，我们需要approve对应的token给管理合约。 我们会调用管理合约的mint函数来铸造流动性，参数为铸造需要的参数以及池子的合约地址 管理合约会调用池子的mint函数，并且会实现uniswapV3MintCallback。由于我们之前的approve，管理合约会从我们的账户中把token转到池子合约 为了交易token，我们也需要approve对应的token 我们会调用管理合约的swap函数，并且与mint过程类似，它会调用池子合约的对应函数。管理者合约会把我们的token转到赤字中，池子进行对应的交易，然后把得到的token发回给我们。 综上，管理合约主要作为用户和池子之间的中介来运行。
向callback传递数据 # 在实现管理合约之前，我们还需要更新我们的池子合约。
管理者合约需要能够与任何一个流动性池适配，并且能够允许任何地址调用它。为了达到这一点，我们需要对callback进行升级：我们需要将池子的地址和用户的地址作为参数传递。下面是我们对于uniswapV3MintCallback的之前的实现（测试合约中的）：
function uniswapV3MintCallback(uint256 amount0, uint256 amount1) public { if (transferInMintCallback) { token0.transfer(msg.sender, amount0); token1.transfer(msg.sender, amount1); } } 关键点：
这个函数转移的token是属于这个测试合约的——而我们希望使用transferFrom来从管理合约的调用者出转出token 这个函数需要知道token0和token1，但这两个变量会随着不同池子而变化。 想法：我们需要改变callback的参数，来将用户和池子的合约地址传进去
接下来看一下swap的callback：
function uniswapV3SwapCallback(int256 amount0, int256 amount1) public { if (amount0 &amp;gt; 0 &amp;amp;&amp;amp; transferInSwapCallback) { token0.transfer(msg.sender, uint256(amount0)); } if (amount1 &amp;gt; 0 &amp;amp;&amp;amp; transferInSwapCallback) { token1.</description>
    </item>
    
    <item>
      <title>通用mint</title>
      <link>https://uniswapv3book.com/docs/milestone_2/generalize-minting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_2/generalize-minting/</guid>
      <description>\[ \] 通用mint # 现在，我们可以更新mint函数来直接在Solidity中进行计算而不需要手动计算并硬编码了。
初始化tick与更新 # 还记得在mint函数中，我们更新TickInfo这个mapping来存储tick中可用的流动性信息。现在，我们将会使用新的bitmap索引来进行这一步——我们之后会用这个新的索引来在交易中寻找下一个可用tick。
首先，我们需要更新Tick.update函数：
// src/lib/Tick.sol function update( mapping(int24 =&amp;gt; Tick.Info) storage self, int24 tick, uint128 liquidityDelta ) internal returns (bool flipped) { ... flipped = (liquidityAfter == 0) != (liquidityBefore == 0); ... } 现在，它会返回一个flipped flag，当流动性被添加到一个空的tick或整个tick的流动性被耗尽时为true。
接下来，在mint函数中，我们更新bitmao索引：
// src/UniswapV3Pool.sol ... bool flippedLower = ticks.update(lowerTick, amount); bool flippedUpper = ticks.update(upperTick, amount); if (flippedLower) { tickBitmap.flipTick(lowerTick, 1); } if (flippedUpper) { tickBitmap.flipTick(upperTick, 1); } ... 再次说明，在Milestone 4之前，TickSpacing参数的值会始终为1.</description>
    </item>
    
    <item>
      <title>A Little Bit More on Fixed-point Numbers</title>
      <link>https://uniswapv3book.com/docs/milestone_3/more-on-fixed-point-numbers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_3/more-on-fixed-point-numbers/</guid>
      <description>\[ \] A Little Bit More on Fixed-point Numbers # In this bonus chapter, I&amp;rsquo;d like to show you how to convert prices to ticks in Solidity. We don&amp;rsquo;t need to do this in the main contracts, but it&amp;rsquo;s helpful to have such function in tests so we don&amp;rsquo;t hardcode ticks and could write something like tick(5000)–this makes code easier to read because it&amp;rsquo;s more convenient for us to think in prices, not tick indexes.</description>
    </item>
    
    <item>
      <title>Tick Rounding</title>
      <link>https://uniswapv3book.com/docs/milestone_4/tick-rounding/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_4/tick-rounding/</guid>
      <description>\[ \] Tick Rounding # Let&amp;rsquo;s review some other changes we need to make to support different tick spacings.
Tick spacing greater than 1 won&amp;rsquo;t allow users to select arbitrary price ranges: tick indexes must be multiples of a tick spacing. For example, for tick spacing 60 we can have ticks: 0, 60, 120, 180, etc. Thus, when user picks a range, we need to &amp;ldquo;round&amp;rdquo; it so its boundaries are multiples of pool&amp;rsquo;s tick spacing.</description>
    </item>
    
    <item>
      <title>User Interface</title>
      <link>https://uniswapv3book.com/docs/milestone_5/user-interface/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_5/user-interface/</guid>
      <description>User Interface # In this milestone, we&amp;rsquo;ve added the ability to remove liquidity from a pool and collect accumulated fees. Thus, we need to reflect these changes in the user interface to allow users to remove liquidity.
Fetching Positions # To let user choose how much liquidity to remove, we first need to fetch user&amp;rsquo;s positions from a pool. To makes this easier, we can add a helper function to the Manager contract, which will return user position in a specific pool:</description>
    </item>
    
    <item>
      <title>通用swap</title>
      <link>https://uniswapv3book.com/docs/milestone_2/generalize-swapping/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_2/generalize-swapping/</guid>
      <description>\[ \] 通用swap # 本节将会是这个milestone中最难的一个部分。在更新代码之前，我们首先需要知道Uniswap V3中的swap是如何工作的。
我们可以把一笔交易看作是满足一个订单：一个用户提交了一个订单，需要从池子中购买一定数量的某种token。池子会使用可用的流动性来将投入的token数量“转换”成输出的token数量。如果在当前价格区间中没有足够的流动性，它将会尝试在其他价格区间中寻找流动性（使用我们前一节实现的函数）。
现在，我们要实现swap函数内部的逻辑，但仍然保证交易可以在当前价格区间内完成——跨tick的交易将会在下一个milestone中实现。
function swap( address recipient, bool zeroForOne, uint256 amountSpecified, bytes calldata data ) public returns (int256 amount0, int256 amount1) { ... 在swap函数中，我们新增了两个参数：zeroForOne 和 amountSpecified。zeroForOne 是用来控制交易方向的 flag：当设置为true，是用 token0 兑换 token1；false则相反。例如，如果token0 是ETH，token1 是USDC，将 zeroForOne 设置为true意味着用 USDC 购买 ETH。amountSpecified 是用户希望卖出的token数量。
填满订单 # 由于在Uniswap V3中，流动性存储在不同的价格区间中，池子合约需要找到“填满当前订单”所需要的所有流动性。这个操作是通过沿着某个方向遍历所有初始化的tick来实现的。
在继续之前，我们需要定义两个新的结构体：
struct SwapState { uint256 amountSpecifiedRemaining; uint256 amountCalculated; uint160 sqrtPriceX96; int24 tick; } struct StepState { uint160 sqrtPriceStartX96; int24 nextTick; uint160 sqrtPriceNextX96; uint256 amountIn; uint256 amountOut; } SwapState 维护了当前swap的状态。amoutSpecifiedRemaining 跟踪了还需要从池子中获取的token数量：当这个数量为0时，这笔订单就被填满了。amountCalculated 是由合约计算出的输出数量。sqrtPriceX96 和 tick 是交易结束后的价格和tick。</description>
    </item>
    
    <item>
      <title>部署合约</title>
      <link>https://uniswapv3book.com/docs/milestone_1/deployment/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_1/deployment/</guid>
      <description>\[ \] 部署 # 我们的第一版合约已经完成了。现在，让我们来看看如何把它部署在一个本地以太坊网络上，方便我们之后用前端app交互。
选择本地网络 # 智能合约的开发需要运行一个本地的网络来在开发过程中进行部署和测试。这样的网络需要具有以下特点：
真实的区块链。它必须是一个真实的区块链网络而不是一个模拟器，我们希望我们的合约如果能够在这样的网络上正常工作那也一定能在主网上正常工作 速度。我们希望我们的交易能够快速被执行，这样我们能快速迭代。 以太币。为了支付gas费，我们需要一些eth，因此我们希望这个网络能够允许我们生成任意数量的eth cheat code。除了提供标准的API，我们还希望这个网络能让我们做更多的事，例如：在任何地址上部署合约，以任何地址执行交易，直接修改合约状态等等。 今天，有许多的工具能够提供这样的功能：
Truffle套件中的Ganache Hardhat，一套智能合约开发环境，除了包含本地网络节点以外还有很多有用的工具 Foundry中的Anvil 所有这些解决方案都能够满足我们的需求。尽管如此，项目现在都逐渐从Ganache（最早的解决方案）迁移到Hardhat（目前使用最广的方案），而Foundry也成为开发者的新宠。Foundry也是上述三个方案中唯一使用Solidity来编写测试的框架（其他框架都使用JavaScript）。除此以外，Foundry还允许使用Solidity来编写部署脚本。因此，由于我们想在各处都使用Solidity，我们会使用 Anvil 来运行一个本地区块链，并且使用Solidity编写部署脚本。
运行本地区块链 # Anvil不需要进行配置，我们可以直接在命令行运行：
$ anvil _ _ (_) | | __ _ _ __ __ __ _ | | / _` | | &amp;#39;_ \ \ \ / / | | | | | (_| | | | | | \ V / | | | | \__,_| |_| |_| \_/ |_| |_| 0.</description>
    </item>
    
    <item>
      <title>Flash Loans</title>
      <link>https://uniswapv3book.com/docs/milestone_3/flash-loans/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_3/flash-loans/</guid>
      <description>Flash Loans # Both Uniswap V2 and V3 implement flash loans: unlimited and uncollateralized loans that must be repaid in the same transaction. Pools basically give users arbitrary amounts of tokens that they request, but, by the end of the call, the amounts must be repaid, with a small fee on top.
The fact that flash loans must be repaid in the same transaction means that flash loans cannot be taken by regular users: as a user, you cannot program custom logic in transactions.</description>
    </item>
    
    <item>
      <title>报价合约</title>
      <link>https://uniswapv3book.com/docs/milestone_2/quoter-contract/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_2/quoter-contract/</guid>
      <description>报价合约 # 为了让我们的池子合约能够集成到前端，我们需要一种方式能够在交易之前就计算出对应的数量。用户会输入它们希望卖出的token数量，然后就能计算并且展示出它们会获得的token数量。我们将通过报价合约来实现这一功能。
由于Uniswap V3中的流动性是分散在多个价格区间中的，我们不能够仅仅通过一个公式计算出对应数量（像在Uniswap V2中那样）。Uniswap V3的设计需要我们用一种不同的方法：为了获得交易数量，我们初始化一个真正的交易，并且在callback函数中打断它，获取到之前计算出的对应数量。也就是，我们将会模拟一笔真实的交易来计算输出数量！
我们会创建这样一个辅助合约：
contract UniswapV3Quoter { struct QuoteParams { address pool; uint256 amountIn; bool zeroForOne; } function quote(QuoteParams memory params) public returns ( uint256 amountOut, uint160 sqrtPriceX96After, int24 tickAfter ) { ... Quoter 合约仅实现了一个public的函数——quote。Quoter是一个对于所有池子的通用合约，因此它将池子地址作为一个参数。其他参数（amountIn 和 zeroForOne）都是模拟swap需要的参数。
try IUniswapV3Pool(params.pool).swap( address(this), params.zeroForOne, params.amountIn, abi.encode(params.pool) ) {} catch (bytes memory reason) { return abi.decode(reason, (uint256, uint160, int24)); } 这个函数唯一实现的功能是调用池子合约的 swap 函数。这个调用应当revert（即抛出异常）——我们将会在callback中实现这一点。当revert发生的时候，对应的reason会解码并且返回。quote永远不会revert。注意到，在data字段，我们仅仅传入和合约的地址——因为在callback函数中，我们需要用它来获取对应池子的slot0。
function uniswapV3SwapCallback( int256 amount0Delta, int256 amount1Delta, bytes memory data ) external view { address pool = abi.</description>
    </item>
    
    <item>
      <title>用户界面</title>
      <link>https://uniswapv3book.com/docs/milestone_1/user-interface/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_1/user-interface/</guid>
      <description>\[ \] 用户界面 # 现在，我们可以进行这个milestone的最后一步了——搭建一个UI！
由于搭建前端app并不是本书的主要目的，本书将不会讲解如何从头搭建一个这样的前端，而是展示如何使用MetaMask与智能合约进行交互。
如果你希望自己尝试这个app，在本地运行它，你可以在代码仓库中的 ui文件夹找到对应代码。这就是一个简单的React应用，本地运行只需要在App.js中设置合约地址，然后运行yarn start。
相关工具一览 # 什么是MetaMask？ # MetaMask是一个浏览器插件的以太坊钱包。它能够创建和存储私钥、展示账户余额、允许链接到不同网络、发送和接受以太或其他token——钱包能做的所有事情几乎都可以在其中实现。
除此之外，MetaMask还能够作为signer和provider来运行。作为provider，它链接到一个以太坊节点，并且提供一个接口来使用对应节点的JSON-RPC API。作为一个signer，它提供了一个能够进行安全交易签名的接口，因此能够使用钱包中的私钥来签名任意交易。 （译者注：signer和provider都是js库中的常用名词，因此在这里不作翻译） 常用库 # 事实上，MetaMask也并没有提供那么多的功能：它仅仅是能够管理账户和发送交易。我们需要其他一些库来使得与合约的交互更加容易，并且能更轻松地解析EVM相关的数据。
这样的库有很多，其中最流行的两个是 web3.js 和 ethers.js。选择哪一个取决于你的个人喜好。对本书作者来说，选择 Ethers.js 因为其与合约交互的接口更加清晰
工作流 # 现在，让我们看一下如何使用 MetaMask + Ethers.js 来实现交互。
连接到本地节点 # 为了能够发送交易和获取区块链数据，MetaMask链接到一个以太坊节点。为了与我们的合约交互，我们需要钱包链接到本地的Anvil节点。打开MetaMask，点击网络列表——添加网络，增加一个网络，RPC URL为http://localhost:8545。钱包将会自动检测对应的chain ID（在Anvil中为31331）.
链接到本地节点之后，我们需要导入一个私钥。在MetaMask中，点击地址列表——导入账户，把之前选择的地址对应的私钥粘贴在这里。然后进入资产列表，导入两种token的地址。现在你可以在MetaMask上看到两种token的余额了。
MetaMask实际上有一些bug。一个我经常遇到的bug是，当它连接到本地节点时，它通常会缓存链状态。因此每次重启节点的时候，你有可能会看到旧的余额和状态。解决方法是：打开高级设置，点击“重置账户”。每次重启节点后你可能都需要进行这个步骤。
链接到MetaMask # 并不是每一个网站都能够访问到你在MetaMask中的地址。一个网站首先需要链接到MetaMask。当一个新的网站想要连接MetaMask时，你会看到一个弹窗来请求许可。
前端连接MetaMask的方式如下：
// ui/src/contexts/MetaMask.js const connect = () =&amp;gt; { if (typeof (window.ethereum) === &amp;#39;undefined&amp;#39;) { return setStatus(&amp;#39;not_installed&amp;#39;); } Promise.all([ window.ethereum.request({ method: &amp;#39;eth_requestAccounts&amp;#39; }), window.ethereum.request({ method: &amp;#39;eth_chainId&amp;#39; }), ]).</description>
    </item>
    
    <item>
      <title>User Interface</title>
      <link>https://uniswapv3book.com/docs/milestone_3/user-interface/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_3/user-interface/</guid>
      <description>\[ \] User Interface # We&amp;rsquo;re now ready to update the UI with the changes we made in this milestone. We&amp;rsquo;ll add two new features:
Add Liquidity dialog window; slippage tolerance in swapping. Add Liquidity Dialog # This change will finally remove hard coded liquidity amounts from our code and will allow use to add liquidity at arbitrary ranges.
The dialog is a simple component with a couple of inputs.</description>
    </item>
    
    <item>
      <title>用户界面</title>
      <link>https://uniswapv3book.com/docs/milestone_2/user-interface/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_2/user-interface/</guid>
      <description>用户界面 # 现在，我们可以让我们的web应用看起来更像一个真正的DEX了。我们可以移除那些硬编码的数额，并且允许用户输入任意的数量。同样，我们还可以让用户在任意一个方向交易，所以我们需要一个按钮来改变交易方向。在更新之后，swap 的表单长这样：
&amp;lt;form className=&amp;#34;SwapForm&amp;#34;&amp;gt; &amp;lt;SwapInput amount={zeroForOne ? amount0 : amount1} disabled={!enabled || loading} readOnly={false} setAmount={setAmount_(zeroForOne ? setAmount0 : setAmount1, zeroForOne)} token={zeroForOne ? pair[0] : pair[1]} /&amp;gt; &amp;lt;ChangeDirectionButton zeroForOne={zeroForOne} setZeroForOne={setZeroForOne} disabled={!enabled || loading} /&amp;gt; &amp;lt;SwapInput amount={zeroForOne ? amount1 : amount0} disabled={!enabled || loading} readOnly={true} token={zeroForOne ? pair[1] : pair[0]} /&amp;gt; &amp;lt;button className=&amp;#39;swap&amp;#39; disabled={!enabled || loading} onClick={swap_}&amp;gt;Swap&amp;lt;/button&amp;gt; &amp;lt;/form&amp;gt; 每个输入都根据交易方向赋值给一个变量，交易方向由 zeroForOne 这个状态来控制。下面的输入空间总是只读的，因为这部分的数字是由报价合约计算出来。
setAmount_ 函数做了两件事：更新上面输入框中的值，调用报价合约来计算下面输入框中的值
const updateAmountOut = debounce((amount) =&amp;gt; { if (amount === 0 || amount === &amp;#34;0&amp;#34;) { return; } setLoading(true); quoter.</description>
    </item>
    
  </channel>
</rss>
