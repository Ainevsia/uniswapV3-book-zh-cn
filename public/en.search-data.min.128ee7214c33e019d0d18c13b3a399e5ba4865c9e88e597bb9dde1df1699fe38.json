[{"id":0,"href":"/docs/milestone_4/introduction/","title":"Introduction","section":"Milestone 4. Multi-pool Swaps","content":" Multi-pool Swaps # After implementing cross-tick swaps, we\u0026rsquo;ve got really close to real Uniswap V3 swaps. One significant limitation of our implementation is that it allows only swaps within a pool–if there\u0026rsquo;s no pool for a pair of tokens, then swapping between these tokens is not possible. This is not so in Uniswap since it allows multi-pool swaps. In this chapter, we\u0026rsquo;re going to add multi-pool swaps to our implementation.\nHere\u0026rsquo;s the plan:\nfirst, we\u0026rsquo;ll learn about and implement Factory contract; then, we\u0026rsquo;ll see how chained or multi-pool swaps work and implement Path library; then, we\u0026rsquo;ll update the front-end app to support multi-pool swaps; we\u0026rsquo;ll implement a basic router that finds a path between two tokens; along the way, we\u0026rsquo;ll also learn about tick spacing which is a way of optimizing swaps. After finishing this chapter, our implementation will be able to handle multi-pool swaps, for example, swapping WBTC for WETH via different stablecoins: WETH → USDC → USDT → WBTC.\nLet\u0026rsquo;s begin!\nYou\u0026rsquo;ll find the complete code of this chapter in this Github branch.\nThis milestone introduces a lot of code changes in existing contracts. Here you can see all changes since the last milestone\nIf you have any questions feel free asking them in the GitHub Discussion of this milestone!\n"},{"id":1,"href":"/docs/milestone_5/introduction/","title":"Introduction","section":"Milestone 5. Fees and Price Oracle","content":" Fees and Price Oracle # In this milestone, we\u0026rsquo;re going to add two new features to our Uniswap implementation. They share one similarity: they work on top of what we have already built–that\u0026rsquo;s why we\u0026rsquo;ve delayed them until this milestone. However, they\u0026rsquo;re not equally important.\nWe\u0026rsquo;re going to add swap fees and a price oracle:\nSwap fees is a crucial mechanism of the DEX design we\u0026rsquo;re implementing. They\u0026rsquo;re the glue that makes things stick together. Swap fees incentivize liquidity providers to provide liquidity, and no trades are possible without liquidity, as we have already learned. A price oracle, on the other hand, is an optional utility function of a DEX. A DEX, while conducting trades, can also function as a price oracle–that is, provide token prices to other services. This doesn\u0026rsquo;t affect actual swaps but provides a useful service to other on-chain applications. Alright, let\u0026rsquo;s get building!\nYou\u0026rsquo;ll find the complete code of this chapter in this Github branch.\nThis milestone introduces a lot of code changes in existing contracts. Here you can see all changes since the last milestone\nIf you have any questions feel free asking them in the GitHub Discussion of this milestone!\n"},{"id":2,"href":"/docs/milestone_6/introduction/","title":"Introduction","section":"Milestone 6: NFT positions","content":" \\[ \\] NFT Positions # This is the cherry on the cake of this book. In this milestone, we\u0026rsquo;re going to learn how Uniswap contract can be extended and integrated into third-party protocols. This possibility is a direct consequence of having core contracts with only crucial functions, which allows to integrate them into other contracts without the need of adding new features to core contracts.\nA bonus feature of Uniswap V3 was the ability to turn liquidity positions into NFT tokens. Here\u0026rsquo;s an example of one such NFT tokens:\nIt shows token symbols, pool fee, position ID, lower and upper ticks, token addresses, and the segment of the curve the position is provided at.\nYou can see all Uniswap V3 NFT positions in this OpenSea collection.\nIn this milestone, we\u0026rsquo;re going to add NFT-tokenization of liquidity positions!\nLet\u0026rsquo;s go!\nYou\u0026rsquo;ll find the complete code of this chapter in this Github branch.\nThis milestone introduces a lot of code changes in existing contracts. Here you can see all changes since the last milestone\nIf you have any questions feel free asking them in the GitHub Discussion of this milestone!\n"},{"id":3,"href":"/docs/reference/dictionary/","title":"中英名词对照","section":"补充资料","content":" 中文 英文简称 全称 去中心化交易所 DEX Decentralized Exchange 中心化交易所 CEX Centralized Exchange 流动性 liquidity liquidity 流动性提供者 LP Liquidity Provider 自动做市商 AMM Automated Market Maker 恒定函数做市商 CFMM Constant Function Market Maker "},{"id":4,"href":"/docs/introduction/introduction-to-markets/","title":"交易市场简介","section":"Milestone 0. 简介","content":" 交易市场简介 # 中心化交易所(CEX)如何工作 # 在本书中，我们将会搭建一个运行在以太坊(Ethereum)上的去中心化交易所(DEX)。DEX的设计模式非常复杂多样，因此我们先来考虑中心化交易所的设计。中心化交易所(CEX)的核心为订单簿(order book)，存储了用户的所有买单和卖单。订单簿中的每一笔订单都包含了订单成交的价格以及成交数量。\n交易能够正常进行的保障是流动性(liquidity)，也即整个市场中所有可获得的资产数目。假设你希望购买一个衣柜但是没有人售卖，即为没有流动性；如果你希望卖出一个衣柜但是没有人愿意购买，即为市场有流动性但是没有买方。没有流动性，就无法在市场中进行买卖。\n在CEX中，流动性存放在订单簿中。如果某个用户提交了一个卖单，他就为市场提供了流动性；如果某人提交了一个买单，他们希望市场有流动性，否则交易就无法进行。\n如果市场没有流动性，但是仍然希望进行交易，就需要做市商(market maker)。做市商是向市场提供流动性的，拥有大量各种资产的公司或个人。通过提供流动性，做市商能够从交易中获取利润。\n去中心化交易所(DEX)如何工作 # 毫无疑问，去中心化的交易也需要流动性，并且也需要做市商向市场提供多种资产的流动性。然而，在DEX中这个过程无法被中心化地处理，我们需要一种去中心化的做市商方案。相关解决方案非常多样化，而本书将主要关注Uniswap提供的方案。\n自动做市商(AMM) # 链上交易市场的历史 一文提到了一种称作自动做市商(Automated Market Maker)的思路。正如其名，这种算法能够自动化完成像做市商一样的工作。更进一步，这种算法是去中心化且无需许可的，也即：\n没有被任何单个中心化机构控制 所有资产并不存储在同一地方 任何人在任何地点都能使用 什么是自动做市商AMM？ # 一个AMM是一套定义如何管理流动性的智能合约。每个单独的交易对（例如ETH/USDC）都是一个单独的智能合约，存储了ETH和USDC的资产并且撮合交易，在这个合约中我们可以将ETH兑换成USDC或者将USDC兑换成ETH。\n在AMM中，一个核心思想为池子(pooling)：每个合约都是一个存储流动性的池子，允许不同的用户（包括其他合约）在其中进行某种方式的交易。在AMM中有两种角色，*流动性提供者(LP)*以及交易者；这两者通过流动性池进行交互，交互的方式由合约进行规定且不可更改。\n这种方法与CEX的关键区别在于： 智能合约是完全自动化的并且不受任何人控制。没有经理，没有系统管理员，没有特权用户，一切都没有。这里只有LP和交易者，任何人都可以担任这两种角色（也可以同时），并且所有的算法都是公开的、程序规定的、不可更改的。\n在后面的篇章，我们将更进一步了解Uniswap是如何实现AMM的。\n注意在后文中，pool和pair两个词可能会被交替使用，因为一个Uniswap的流动性池即一对token\n"},{"id":5,"href":"/docs/milestone_1/introduction/","title":"简介","section":"Milestone 1. 第一笔交易","content":" \\[ \\] 第一笔交易 # 在本章中，我们将会搭建一个流动性池合约，能够接受用户的流动性并且在某个价格区间内做交易。为了尽可能简化，我们仅在一个价格区间内提供流动性，并且仅允许单向的交易。另外，为了更好地理解其中的数学原理，我们将手动计算其中用到的数学参数，暂不使用Solidity的数学库进行计算。\n我们本章中要搭建的模型如下：\n这是一个ETH/USDC的池子合约。ETH是资产$x$，USDC是资产$y$。 现货价格将被设置为一个ETH对5000USDC 我们提供流动性的价格区间为一个ETH对4545-5500USDC 我们将会从池子中购买ETH，并且保证价格在上述价格区间内。 模型的图像大致如下：\n在开始代码部分之前，我们首先来手动计算模型中用到的所有数学参数。为了简单起见，作者将使用Python来进行计算而不是Solidity，因为Solidity在数学计算上有很多细微之处需要考虑。也就是说，我们将会把所有的参数硬编码进池子合约里。这会让我们获得一个最小可用的产品。\n本章中所有用到的python计算都在unimath.py。\n本章的完整代码可以参考这个github分支\n"},{"id":6,"href":"/docs/milestone_2/introduction/","title":"简介","section":"Milestone 2. 第二笔交易","content":" 第二笔交易 # OK，现在才是真正的开始。到目前为止，我们的实现看起来过于手动并且静态。我们手动计算了所有参数，硬编码了各种数量，来让学习曲线不那么陡峭；现在我们准备要让它真正地自动化工作了。我们将会实现第二笔交易，这次的交易是相反的方向：卖出ETH来获得USDC。为了达到这个目的，我们需要大幅度改进我们目前的合约：\n我们需要在Solidity中实现数学运算。但是，由于Solidity仅支持整数除法，在Solidity中实现数学运算会比较困难。我们将使用第三方库来完成这部分 我们需要让用户能够选择交易的方向，并且池子合约需要支持双向的交易。我们将会改进合约，离跨价格区间的交易更进一步，而我们将在下一个milestone真正实现它。 最后，我们需要更新我们的UI来实现双向的交易以及获取金额的计算。这需要我们实现另一个合约，报价合约(Quoter)。 在本章节的最后，我们将会获得一个几乎和真正DEX类似的app！\n让我们开始吧\n本章节的所有代码可以在这个Github branch找到\n本章会对我们之前实现的合约进行大量的更新。 在这里你可以看到与上一个milestone的所有代码差别\n"},{"id":7,"href":"/docs/milestone_3/introduction/","title":"简介","section":"Milestone 3. 跨tick交易","content":" 跨tick交易 # 我们现在已经完成了Uniswap V3实现的很大一部分，并且已经很接近原版了！然而，我们的实现仅仅支持在同一个价格区间内的交易——这也是我们在这一个milestone中来改进的点。\n在这个milestone中，我们会：\n更新mint函数，使得能够在不同的价格区间提供流动性 更新swap函数，使得在当前价格区间流动性不足时能够跨价格区间交易 学习如何在智能合约中计算流动性 在mint和swap函数中实现花店控制 更新前端用户界面，使得能够在不同价格区间添加流动性 增加对于定点数运算的一些了解 在这个milestone中，我们将彻底完成swap这个Uniswap中最核心的功能！\n让我们开始吧。\n本章的完整代码可以参考这个Github分支\n这个milestone也对于已有的合约做了许多修改，你可以在这里看到在上一个milestone基础上进行的改动\n如果你关于本章有任何问题，欢迎在本章的Github Discussion提问和交流！\n"},{"id":8,"href":"/docs/milestone_6/erc721-overview/","title":"ERC721 Overview","section":"Milestone 6: NFT positions","content":" ERC721 Overview # Let\u0026rsquo;s begin with an overview of EIP-721, the standard that defines NFT contracts.\nERC721 is a variant of ERC20. The main difference between them is that ERC721 tokens are non-fungible, that is: one token is not identical to another. To distinguish ERC721 tokens, each of them has a unique ID, which is almost always the counter at which a token was minted. ERC721 tokens also have an extended concept of ownership: owner of each token is tracked and stored in the contract. This means that only distinct tokens, identified by token IDs, can be transferred (or approved for transfer).\nWhat Uniswap V3 liquidity positions and NFTs have in common is this non-fungibility: NFTS and liquidity positions are not interchangeable and are identified by unique IDs. It\u0026rsquo;s this similarity that will allow us to merge the two concepts.\nThe biggest difference between ERC20 and ERC721 is the tokenURI function in the latter. NFT tokens, which are implemented as ERC721 smart contracts, have linked assets that are stored externally, not on blockchain. To link token IDs to images (or sounds, or anything else) stored outside of blockchain, ERC721 defines the tokenURI function. The function is expected to return a link to a JSON file that defines NFT token metadata, e.g.:\n{ \u0026#34;name\u0026#34;: \u0026#34;Thor\u0026#39;s hammer\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Mjölnir, the legendary hammer of the Norse god of thunder.\u0026#34;, \u0026#34;image\u0026#34;: \u0026#34;https://game.example/item-id-8u5h2m.png\u0026#34;, \u0026#34;strength\u0026#34;: 20 } (This example is taken from the ERC721 documentation on OpenZeppelin)\nSuch JSON file defines: the name of a token, the description of a collection, the link to the image of a token, properties of a token.\nAlternatively, we may store JSON metadata and token images on-chain. This is very expensive of course (saving data on-chain is the most expensive operation in Ethereum), but we can make it cheaper if we store templates. All tokens within a collection have similar metadata (mostly identical but image links and properties are different for each token) and visuals. For the latter, we can use SVG, which is an HTML-like format, and HTML is a good templating language.\nWhen storing JSON metadata and SVG on-chain, the tokenURI function, instead of returning a link, would return JSON metadata directly, using the data URI scheme to encode it. SVG images would also be inlined, it won\u0026rsquo;t be necessary making external requests to download token metadata and image.\n"},{"id":9,"href":"/docs/milestone_4/factory-contract/","title":"Factory Contract","section":"Milestone 4. Multi-pool Swaps","content":" Factory Contract # Uniswap is designed in a way that assumes many discrete Pool contracts, with each pool handling swaps of one token pair. This looks problematic when we want to swap between two tokens that don\u0026rsquo;t have a pool–is there\u0026rsquo;s no pool, no swaps are possible. However, we can still do intermediate swaps: first swap to a token that has pairs with either of the tokens and then swap this token to the target token. This can also go deeper and have more intermediate tokens. However, doing this manually is cumbersome, and, luckily, we make can the process easier by implementing it in our smart contracts.\nFactory contract is a contract that serves multiple purposes:\nIt acts as a centralized registry of Pool contracts. Using a factory, you can find all deployed pools, their tokens, and addresses. It simplifies deployment of Pool contracts. EVM allows to deploy smart contracts from smart contracts–Factory uses this feature to make pools deployment a breeze. It makes pool addresses predictable and allows to compute them without making calls to the registry. This makes pools easily discoverable. Let\u0026rsquo;s build Factory contract! But before doing this, we need to learn something new.\nCREATE and CREATE2 Opcodes # EVM has two ways of deploying contracts: via CREATE or via CREATE2 opcode. The only difference between them is how new contract address is generated:\nCREATE uses deployer\u0026rsquo;s account nonce to generate a contract address (in pseudocode): KECCAK256(deployer.address, deployer.nonce) nonce is an account-specific counter of transactions. Using nonce in new contract address generation makes it hard to compute an address in other contracts or off-chain apps, mainly because, to find the nonce a contract was deployed at, one needs to scan historical account transactions. CREATE2 uses a custom salt to generate a contract address. This is just an arbitrary sequence of bytes chosen by a developer, which is used to make address generation deterministic (and reduces the chance of a collision). KECCAK256(deployer.address, salt, contractCodeHash) We need to know the difference because Factory uses CREATE2 when deploying Pool contracts so pools get unique and deterministic addresses that can be computed in other contracts and off-chain apps. Specifically, for salt, Factory computes a hash using these pool parameters:\nkeccak256(abi.encodePacked(token0, token1, tickSpacing)) token0 and token are the addresses of pool tokens, and tickSpacing is something we\u0026rsquo;re going to learn about next.\nTick Spacing # Recall the loop in swap function:\nwhile ( state.amountSpecifiedRemaining \u0026gt; 0 \u0026amp;\u0026amp; state.sqrtPriceX96 != sqrtPriceLimitX96 ) { ... (step.nextTick, ) = tickBitmap.nextInitializedTickWithinOneWord(...); (state.sqrtPriceX96, step.amountIn, step.amountOut) = SwapMath.computeSwapStep(...); ... } This loop finds initialized ticks that have some liquidity by iterating them in either of the directions. This iterating, however, is an expensive operation: if a tick is far away, the code would need to pass all the ticks between the current and the target one, which consumes gas. To make this loop more gas-efficient, Uniswap pools have tickSpacing setting, which sets, as the name suggest, the distance between ticks: the wider the distance, the more gas efficient swaps are.\nHowever, the wider a tick spacing the lower the precision. Low volatility pairs (e.g. stablecoin pairs) need higher precision because price movements are narrow in such pairs. Medium and high volatility pairs need lower precision since price movement are wide in such pairs. To handle this diversity, Uniswap allows to pick a tick spacing when a pair is deployed. Uniswap allows deployers to choose from these options: 10, 60, or 200. And we\u0026rsquo;ll have only 10 and 60 for simplicity.\nIn technical terms, tick indexes can only be multiples of tickSpacing: if tickSpacing is 10, only multiples of 10 will be valid as tick indexes (10, 20, 5000, 5010, but not 8, 12, 5001, etc.). However, and this is important, this doesn\u0026rsquo;t apply to the current price–it can still be any tick because we want it to be as precise as possible. tickSpacing is only applied to price ranges.\nThus, each pool is uniquely identified by this set of parameters:\ntoken0, token1, tickSpacing; And, yes, there can be pools with the same tokens but different tick spacings.\nFactory contract uses this set of parameters as a unique identifier of a pool and passes it as a salt to generate a new pool contract address.\nFrom now on, we\u0026rsquo;ll assume the tick spacing of 60 for all our pools, and we\u0026rsquo;ll use 10 for stablecoin pairs.\nFactory Implementation # In the constructor of Factory, we need to initialize supported tick spacings:\n// src/UniswapV3Factory.sol contract UniswapV3Factory is IUniswapV3PoolDeployer { mapping(uint24 =\u0026gt; bool) public tickSpacings; constructor() { tickSpacings[10] = true; tickSpacings[60] = true; } ... We could\u0026rsquo;ve made them constants, but we\u0026rsquo;ll need to have it as a mapping for a later milestone (tick spacings will have different swap fee amounts).\nFactory contract is a contract with only one function createPool. The function begins with necessary checks we need to make before creating a pool:\n// src/UniswapV3Factory.sol contract UniswapV3Factory is IUniswapV3PoolDeployer { PoolParameters public parameters; mapping(address =\u0026gt; mapping(address =\u0026gt; mapping(uint24 =\u0026gt; address))) public pools; ... function createPool( address tokenX, address tokenY, uint24 tickSpacing ) public returns (address pool) { if (tokenX == tokenY) revert TokensMustBeDifferent(); if (!tickSpacings[tickSpacing]) revert UnsupportedTickSpacing(); (tokenX, tokenY) = tokenX \u0026lt; tokenY ? (tokenX, tokenY) : (tokenY, tokenX); if (tokenX == address(0)) revert TokenXCannotBeZero(); if (pools[tokenX][tokenY][tickSpacing] != address(0)) revert PoolAlreadyExists(); ... Notice that this is first time when we\u0026rsquo;re sorting tokens:\n(tokenX, tokenY) = tokenX \u0026lt; tokenY ? (tokenX, tokenY) : (tokenY, tokenX); From now on, we\u0026rsquo;ll also expect pool token addresses to be sorted, i.e. token0 goes before token1 when sorted. We\u0026rsquo;ll enforce this to make salt (and pool addresses) computation consistent.\nThis change also affects how we deploy tokens in tests and the deployment script: we need to ensure that WETH is always token0 to make price calculations simpler in Solidity (otherwise, we\u0026rsquo;d need to use fractional prices, like 1/5000). If WETH is not token0 in your tests, change the order of token deployments.\nAfter that, we prepare pool parameters and deploy a pool:\nparameters = PoolParameters({ factory: address(this), token0: tokenX, token1: tokenY, tickSpacing: tickSpacing }); pool = address( new UniswapV3Pool{ salt: keccak256(abi.encodePacked(tokenX, tokenY, tickSpacing)) }() ); delete parameters; This piece looks weird because parameters is not used. Uniswap uses Inversion of Control to pass parameters to a pool during deployment. Let\u0026rsquo;s look at updated Pool contract constructor:\n// src/UniswapV3Pool.sol contract UniswapV3Pool is IUniswapV3Pool { ... constructor() { (factory, token0, token1, tickSpacing) = IUniswapV3PoolDeployer( msg.sender ).parameters(); } .. } Aha! Pool expects its deployer to implement IUniswapV3PoolDeployer interface (which only defines the parameters() getter) and calls it in the constructor during deployment to get the parameters. This is what the flow looks like:\nFactory: defines parameters state variable (implements IUniswapV3PoolDeployer) and sets it before deploying a pool. Factory: deploys a pool. Pool: in the constructor, calls parameters() function on its deployer and expects that pool parameters are returned. Factory: calls delete parameters; to clean up the slot of parameters state variable and to reduce gas consumption. This is a temporary state variable that has a value only during a call to createPool(). After a pool is created, we keep it in the pools mapping (so it can be found by its tokens) and emit an event:\npools[tokenX][tokenY][tickSpacing] = pool; pools[tokenY][tokenX][tickSpacing] = pool; emit PoolCreated(tokenX, tokenY, tickSpacing, pool); } Pool Initialization # As you have noticed from the code above, we no longer set sqrtPriceX96 and tick in Pool\u0026rsquo;s constructor–this is now done in a separate function, initialize, that needs to be called after pool is deployed:\n// src/UniswapV3Pool.sol function initialize(uint160 sqrtPriceX96) public { if (slot0.sqrtPriceX96 != 0) revert AlreadyInitialized(); int24 tick = TickMath.getTickAtSqrtRatio(sqrtPriceX96); slot0 = Slot0({sqrtPriceX96: sqrtPriceX96, tick: tick}); } So this is how we deploy pools now:\nUniswapV3Factory factory = new UniswapV3Factory(); UniswapV3Pool pool = UniswapV3Pool(factory.createPool(token0, token1, tickSpacing)); pool.initialize(sqrtP(currentPrice)); PoolAddress Library # Let\u0026rsquo;s now implement a library that will help us calculate pool contract addresses from other contracts. This library will have only one function, computeAddress:\n// src/lib/PoolAddress.sol library PoolAddress { function computeAddress( address factory, address token0, address token1, uint24 tickSpacing ) internal pure returns (address pool) { require(token0 \u0026lt; token1); ... The function needs to know pool parameters (they\u0026rsquo;re used to build a salt) and Factory contract address. It expects the tokens to be sorted, which we discussed above.\nNow, the core of the function:\npool = address( uint160( uint256( keccak256( abi.encodePacked( hex\u0026#34;ff\u0026#34;, factory, keccak256( abi.encodePacked(token0, token1, tickSpacing) ), keccak256(type(UniswapV3Pool).creationCode) ) ) ) ) ); This is what CREATE2 does under the hood to calculate new token address. Let\u0026rsquo;s unwind it:\nfirst, we calculate salt (abi.encodePacked(token0, token1, tickSpacing)) and hash it; then, we obtain Pool contract code (type(UniswapV3Pool).creationCode) and also hash it; then, we build a sequence of bytes that includes: 0xff, Factory contract address, hashed salt, and hashed Pool contract code; we then hash the sequence and convert it to an address. These steps implement contract address generation as it\u0026rsquo;s defined in EIP-1014, which is the EIP that added CREATE2 opcode. Let\u0026rsquo;s look closer at the values that constitute the hashed byte sequence:\n0xff, as defined in the EIP, is used to distinguish addresses generated by CREATE and CREATE2; factory is the address of the deployer, in our case a Factory contract; salt was discussed earlier–it uniquely identifies a pool; hashed contract code is needed to protect from collisions: different contracts can have the same salt, but their code hash will be different. So, according to this scheme, a contract address is a hash of the values that uniquely identify this contract, including its deployer, code, and unique parameters. We can use this function from anywhere to find out a pool address without making any external calls and without querying the factory.\nSimplified Interfaces of Manager and Quoter # In Manager and Quoter contracts, we no longer need to ask users for pool address! This makes interaction with the contracts easier because users don\u0026rsquo;t need to know pool addresses, they only need to know tokens. However, users also need to specify tick spacing because it\u0026rsquo;s included in pool\u0026rsquo;s salt.\nMoreover, we no longer need to ask users for the zeroForOne flag because we can now always figure it out thanks to tokens sorting. zeroForOne is true when \u0026ldquo;from token\u0026rdquo; is less than \u0026ldquo;to token\u0026rdquo;, since pool\u0026rsquo;s token0 is always less than token1. Likewise, zeroForOne is always false when \u0026ldquo;from token\u0026rdquo; is greater than \u0026ldquo;to token\u0026rdquo;.\nAddresses are hashes, and hashes are numbers, so we can say \u0026ldquo;less than\u0026rdquo; or \u0026ldquo;greater that\u0026rdquo; when comparing addresses.\n"},{"id":10,"href":"/docs/milestone_5/swap-fees/","title":"Swap Fees","section":"Milestone 5. Fees and Price Oracle","content":" \\[ \\] Swap Fees # As I mentioned in the introduction, swap fees is a core mechanism of Uniswap. Liquidity providers need to get paid for the liquidity they provide, otherwise they\u0026rsquo;ll just use it somewhere else. To incentivize them, trades pay a small fee during each swap. These fees then distributed among all liquidity providers pro rata (proportionally to their share in total pool liquidity).\nTo better understand the mechanism of fees collection and distribution, let\u0026rsquo;s see how they work.\nHow Swap Fees are Collected # Swap fees are collected only when a price range is engaged (used in trades). So we need to track the moments when price range boundaries get crossed. This is when a price range gets engaged and this is when we want to start collecting fees for it:\nwhen price is increasing and a tick is crossed from left to right; when price is decreasing and a tick is crossed from right to left. This is when a price range gets disengaged:\nwhen price is increasing and a tick is crossed from right to left; when price is decreasing and a tick is crossed from left to right. Besides knowing when a price range gets engaged/disengaged, we also want to keep track of how much fees each price range accumulated.\nTo make fees accounting simpler, Uniswap V3 tracks the global fees generated by 1 unit of liquidity. Price range fees are then calculated based on the global ones: fees accumulated outside of a price range are subtracted from the global fees. Fees accumulated outside of a price range are tracked when a tick is crossed (and ticks are crossed when swaps move the price; fees are collected during swaps). With this approach, we don\u0026rsquo;t need to update fees accumulated by each position on very swap–this allows to save a lot of gas and make interaction with pools cheaper.\nLet\u0026rsquo;s recap so we have a clear picture before moving on:\nFees are paid by users who swap tokens. A small amount is subtracted from input token and accumulated on pool\u0026rsquo;s balance. Each pool has feeGrowthGlobal0X128 and feeGrowthGlobal1X128 state variables that track total accumulated fees per unit of liquidity (that is, fee amount divided by pool\u0026rsquo;s liquidity). Notice that at this point actual positions are not updated to optimize gas usage. Ticks keep record of fees accumulated outside of them. When adding a new position and activating a tick (adding liquidity to a previously empty tick), the tick records how much fees were accumulated outside of it (by convention, we assume all fees were accumulated below the tick). Whenever a tick is activated, fees accumulated outside of the tick are updated as the difference between global fees accumulated outside of the tick and the fees accumulated outside of the tick since the last time it was crossed. Having ticks that know how much fees were accumulated outside of them will allow us to calculated how much fees were accumulated inside of a position (position is a range between two ticks). Knowing how much fees were accumulated inside a position will allow us to calculate the shares of fees liquidity providers are eligible for. If a position wasn\u0026rsquo;t involved in swapping, it\u0026rsquo;ll have zero fees accumulated inside of it and the liquidity providers who provided liquidity into this range will have no profits from it. Now, let\u0026rsquo;s see how to calculate fees accumulated by a position (step 6).\nCalculating Position Accumulated Fees # To calculated total fees accumulated by a position, we need to consider two cases: when current price is inside the position and when it\u0026rsquo;s outside of the position. In both cases, we subtract fees collected outside of the lower and the upper ticks of the position from fees collected globally. However, we calculate those fees differently depending on current price.\nWhen current price is inside the position, we subtract the fees that have been collected outside of ticks by this moment:\nWhen current price is outside of the position, we need to update fees collected by either upper or lower ticks before subtracting them from fees collecting globally. We update them only for the calculations and don\u0026rsquo;t overwrite them in ticks because the ticks don\u0026rsquo;t get crossed.\nThis is how we update fees collected outside of a tick:\n$$f_{o}(i) = f_{g} - f_{o}(i)$$\nFees collected outside of a tick ($f_{o}(i)$) is the difference between fees collected globally ($f_{g}$) and fees collected outside of the tick when it crossed last time. We kind of reset the counter when a tick is crossed.\nTo calculate fees collected inside a position:\n$$f_{r} = f_{g} - f_{b}(i_{l}) - f_{a}(i_{u})$$\nWe subtract fees collected below its lower tick ($f_{b}(i_{l})$) and above its upper tick ($f_{a}(i_{u})$) from fees collected globally from all price ranges ($f_{g}$). This is what we saw on the illustration above.\nNow, when current price is above the lower tick (i.e. the position is engaged), we don\u0026rsquo;t need to update fees accumulated below the lower tick and can simply take them from the lower tick. The same is true for fees collected outside of the upper tick when current price is below upper tick. In the two other cases, we need to consider updated fees:\nwhen taking fees collected below the lower tick and current price is also below the tick (the lower tick hasn\u0026rsquo;t been crossed recently); when taking fees above the upper tick and current price is also above the tick (the upper tick hasn\u0026rsquo;t been crossed recently). I hope this all is not too confusing. Luckily, we now know everything to start coding!\nAccruing Swap Fees # To keep it simple, we\u0026rsquo;ll add fees to our codebase step by step. And we\u0026rsquo;ll begin with accruing swap fees.\nAdding Required State Variables # First thing we need to do is to add the fee amount parameter to Pool–every pool will have a fixed and immutable fee configured during deployment. In the previous chapter, we added Factory contract that unified and simplified pools deployment. One of the required pool parameters was tick spacing. Now, we\u0026rsquo;re going to replace it with fee amount and we\u0026rsquo;ll tie fee amounts to tick spacing: the bigger the fee amount, the larger the tick spacing. This is so that low volatility pools (stablecoin ones) have lower fees.\nLet\u0026rsquo;s update Factory:\n// src/UniswapV3Factory.sol contract UniswapV3Factory is IUniswapV3PoolDeployer { ... mapping(uint24 =\u0026gt; uint24) public fees; // `tickSpacings` replaced by `fees` constructor() { fees[500] = 10; fees[3000] = 60; } function createPool( address tokenX, address tokenY, uint24 fee ) public returns (address pool) { ... parameters = PoolParameters({ factory: address(this), token0: tokenX, token1: tokenY, tickSpacing: fees[fee], fee: fee }); ... } } Fee amounts are hundredths of the basis point. That is, 1 fee unit is 0.0001%, 500 is 0.05%, and 3000 is 0.3%.\nNext step is to start accumulating fees in Pool. For that, we\u0026rsquo;ll add two global fee accumulator variables:\n// src/UniswapV3Pool.sol contract UniswapV3Pool is IUniswapV3Pool { ... uint24 public immutable fee; uint256 public feeGrowthGlobal0X128; uint256 public feeGrowthGlobal1X128; } The one with index 0 tracks fees accumulated in token0, the one with index 1 tracks fees accumulated in token1.\nCollecting Fees # Now we need to update SwapMath.computeSwapStep–this is where we calculate swap amounts and this is also where we\u0026rsquo;ll calculate and subtract swap fees. In the function, we replace all occurrences of amountRemaining with amountRemainingLessFee:\nuint256 amountRemainingLessFee = PRBMath.mulDiv( amountRemaining, 1e6 - fee, 1e6 ); Thus, we subtract the fee from input token amount and calculate output amount from a smaller input amount.\nThe function now also returns the fee amount collected during the step–it\u0026rsquo;s calculated differently depending on whether the upper limit of the range was reached or not:\nbool max = sqrtPriceNextX96 == sqrtPriceTargetX96; if (!max) { feeAmount = amountRemaining - amountIn; } else { feeAmount = Math.mulDivRoundingUp(amountIn, fee, 1e6 - fee); } When it\u0026rsquo;s not reached, the current price range has enough liquidity to fulfill the swap, thus we simply return the difference between the amount we needed to fulfill and the actual amount fulfilled. Notice that amountRemainingLessFee is not involved here since the actual final amount was calculated in amountIn (it\u0026rsquo;s calculated based on available liquidity).\nWhen the target price is reached, we cannot subtract fees from the entire amountRemaining because the current price range doesn\u0026rsquo;t have enough liquidity to fulfill the swap. Thus, fee amount is subtracted from the amount the current price range has fulfilled (amountIn).\nAfter SwapMath.computeSwapStep has returned, we need to update fees accumulated by the swap. Notice that there\u0026rsquo;s only one variable to track them because, when staring a swap, we already know the input token (during a swap, fees are collected in either token0 or token1, not both of them):\nSwapState memory state = SwapState({ ... feeGrowthGlobalX128: zeroForOne ? feeGrowthGlobal0X128 : feeGrowthGlobal1X128 }); (...) = SwapMath.computeSwapStep(...); state.feeGrowthGlobalX128 += PRBMath.mulDiv( step.feeAmount, FixedPoint128.Q128, state.liquidity ); This is where we adjust accrued fees by the amount of liquidity to later distribute fees among liquidity providers in a fair way.\nUpdating Fee Trackers in Ticks # Next, we need to update the fee trackers in a tick, if it was crossed during a swap (crossing a tick means we\u0026rsquo;re entering a new price range):\nif (state.sqrtPriceX96 == step.sqrtPriceNextX96) { int128 liquidityDelta = ticks.cross( step.nextTick, ( zeroForOne ? state.feeGrowthGlobalX128 : feeGrowthGlobal0X128 ), ( zeroForOne ? feeGrowthGlobal1X128 : state.feeGrowthGlobalX128 ) ); ... } Since we haven\u0026rsquo;t yet updated feeGrowthGlobal0X128/feeGrowthGlobal1X128 state variables at this moment, we pass state.feeGrowthGlobalX128 as either of the fee parameters depending on swap direction. cross function updates the fee trackers as we discussed above:\n// src/lib/Tick.sol function cross( mapping(int24 =\u0026gt; Tick.Info) storage self, int24 tick, uint256 feeGrowthGlobal0X128, uint256 feeGrowthGlobal1X128 ) internal returns (int128 liquidityDelta) { Tick.Info storage info = self[tick]; info.feeGrowthOutside0X128 = feeGrowthGlobal0X128 - info.feeGrowthOutside0X128; info.feeGrowthOutside1X128 = feeGrowthGlobal1X128 - info.feeGrowthOutside1X128; liquidityDelta = info.liquidityNet; } We haven\u0026rsquo;t added the initialization of feeGrowthOutside0X128/feeGrowthOutside1X128 variables–we\u0026rsquo;ll do this in a later step.\nUpdating Global Fee Trackers # And, finally, after the swap is fulfilled, we can update the global fee trackers:\nif (zeroForOne) { feeGrowthGlobal0X128 = state.feeGrowthGlobalX128; } else { feeGrowthGlobal1X128 = state.feeGrowthGlobalX128; } Again, during a swap, only one of them is updated because fees are taken from the input token, which is either of token0 or token1 depending on swap direction.\nThat\u0026rsquo;s it for swapping! Let\u0026rsquo;s now see what happens to fees when liquidity is added.\nFee Tracking in Positions Management # When adding or removing liquidity (we haven\u0026rsquo;t implemented the latter yet), we also need to initialize or update fees. Fees need to be tracked both in ticks (fees accumulated outside of ticks–the feeGrowthOutside variables we added just now) and positions (fees accumulated inside of positions). In case of positions, we also need to keep track of and update the amounts of tokens collected as fees–or in other words, we convert fees per liquidity to token amounts. The latter is needed so that when a liquidity provider removes liquidity, they get extra tokens collected as swap fees.\nLet\u0026rsquo;s do it step by step again.\nInitialization of Fee Trackers in Ticks # In Tick.update function, whenever a tick is initialized (adding liquidity to a previously empty tick), we initialize its fee trackers. However, we\u0026rsquo;re only doing so when the tick is below current price, i.e. when it\u0026rsquo;s inside of the current price range:\n// src/lib/Tick.sol function update( mapping(int24 =\u0026gt; Tick.Info) storage self, int24 tick, int24 currentTick, int128 liquidityDelta, uint256 feeGrowthGlobal0X128, uint256 feeGrowthGlobal1X128, bool upper ) internal returns (bool flipped) { ... if (liquidityBefore == 0) { // by convention, assume that all previous fees were collected below // the tick if (tick \u0026lt;= currentTick) { tickInfo.feeGrowthOutside0X128 = feeGrowthGlobal0X128; tickInfo.feeGrowthOutside1X128 = feeGrowthGlobal1X128; } tickInfo.initialized = true; } ... } If it\u0026rsquo;s not inside of the current price range, its fee trackers will be 0 and they\u0026rsquo;ll be update when the tick is crossed next time (see the cross function we updated above).\nUpdating Position Fees and Token Amounts # Next step is to calculate the fees and tokens accumulated by a position. Since a position is a range between two ticks, we\u0026rsquo;ll calculate these values using the fee trackers we added to ticks on the previous step. The next function might look messy, but it implements the exact price range fee formulas we saw earlier:\n// src/lib/Tick.sol function getFeeGrowthInside( mapping(int24 =\u0026gt; Tick.Info) storage self, int24 lowerTick_, int24 upperTick_, int24 currentTick, uint256 feeGrowthGlobal0X128, uint256 feeGrowthGlobal1X128 ) internal view returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) { Tick.Info storage lowerTick = self[lowerTick_]; Tick.Info storage upperTick = self[upperTick_]; uint256 feeGrowthBelow0X128; uint256 feeGrowthBelow1X128; if (currentTick \u0026gt;= lowerTick_) { feeGrowthBelow0X128 = lowerTick.feeGrowthOutside0X128; feeGrowthBelow1X128 = lowerTick.feeGrowthOutside1X128; } else { feeGrowthBelow0X128 = feeGrowthGlobal0X128 - lowerTick.feeGrowthOutside0X128; feeGrowthBelow1X128 = feeGrowthGlobal0X128 - lowerTick.feeGrowthOutside1X128; } uint256 feeGrowthAbove0X128; uint256 feeGrowthAbove1X128; if (currentTick \u0026lt; upperTick_) { feeGrowthAbove0X128 = upperTick.feeGrowthOutside0X128; feeGrowthAbove1X128 = upperTick.feeGrowthOutside1X128; } else { feeGrowthAbove0X128 = feeGrowthGlobal0X128 - upperTick.feeGrowthOutside0X128; feeGrowthAbove1X128 = feeGrowthGlobal0X128 - upperTick.feeGrowthOutside1X128; } feeGrowthInside0X128 = feeGrowthGlobal0X128 - feeGrowthBelow0X128 - feeGrowthAbove0X128; feeGrowthInside1X128 = feeGrowthGlobal1X128 - feeGrowthBelow1X128 - feeGrowthAbove1X128; } Here, we\u0026rsquo;re calculating fees accumulated between two ticks (inside a price range). For this, we first calculate fees accumulated below the lower tick and then fees calculated above the upper tick. In the end, we subtract those fees from the globally accumulated ones. This is the formula we saw earlier:\n$$f_{r} = f_{g} - f_{b}(i_{l}) - f_{a}(i_{u})$$\nWhen calculating fees collected above and below a tick, we do it differently depending on whether the price range is engaged or not (whether the current price is between the boundary ticks of the price range). When it\u0026rsquo;s engaged we simply use the current fee trackers of a tick; when it\u0026rsquo;s not engaged we need to take updated fee trackers of a tick–you can see these calculations in the two else branches in the code above.\nAfter finding the fees accumulated inside of a position, we\u0026rsquo;re ready to update fee and token amount trackers of the position:\n// src/lib/Position.sol function update( Info storage self, int128 liquidityDelta, uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128 ) internal { uint128 tokensOwed0 = uint128( PRBMath.mulDiv( feeGrowthInside0X128 - self.feeGrowthInside0LastX128, self.liquidity, FixedPoint128.Q128 ) ); uint128 tokensOwed1 = uint128( PRBMath.mulDiv( feeGrowthInside1X128 - self.feeGrowthInside1LastX128, self.liquidity, FixedPoint128.Q128 ) ); self.liquidity = LiquidityMath.addLiquidity( self.liquidity, liquidityDelta ); self.feeGrowthInside0LastX128 = feeGrowthInside0X128; self.feeGrowthInside1LastX128 = feeGrowthInside1X128; if (tokensOwed0 \u0026gt; 0 || tokensOwed1 \u0026gt; 0) { self.tokensOwed0 += tokensOwed0; self.tokensOwed1 += tokensOwed1; } } When calculating owed tokens, we multiply fees accumulated by the position by liquidity–the reverse of what we did during swapping. In the end, we update the fee trackers and add the token amounts to the previously tracked ones.\nNow, whenever a position is modified (during addition or removal of liquidity), we calculate fees collected by a position and update the position:\n// src/UniswapV3Pool.sol function mint(...) { ... bool flippedLower = ticks.update(params.lowerTick, ...); bool flippedUpper = ticks.update(params.upperTick, ...); ... (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) = ticks .getFeeGrowthInside( params.lowerTick, params.upperTick, slot0_.tick, feeGrowthGlobal0X128_, feeGrowthGlobal1X128_ ); position.update( params.liquidityDelta, feeGrowthInside0X128, feeGrowthInside1X128 ); ... } Removing Liquidity # We\u0026rsquo;re now ready to add the only core feature we haven\u0026rsquo;t implemented yet–removal of liquidity. As opposed to minting, we\u0026rsquo;ll call this function burn. This is the function that will let liquidity providers remove a fraction or whole liquidity from a position they previously added liquidity to. In addition to that, it\u0026rsquo;ll also calculate the fee tokens liquidity providers are eligible for. However, actual transferring of tokens will be done in a separate function–collect.\nBurning Liquidity # Burning liquidity is opposed to minting. Our current design and implementation makes it a hassle-free task: burning liquidity is simply minting with the negative sign. It\u0026rsquo;s like adding a negative amount of liquidity.\nTo implement burn, I needed to refactor the code and extract everything related to position management (updating ticks and position, and token amounts calculation) into _modifyPosition function, which is used by both mint and burn function.\nfunction burn( int24 lowerTick, int24 upperTick, uint128 amount ) public returns (uint256 amount0, uint256 amount1) { ( Position.Info storage position, int256 amount0Int, int256 amount1Int ) = _modifyPosition( ModifyPositionParams({ owner: msg.sender, lowerTick: lowerTick, upperTick: upperTick, liquidityDelta: -(int128(amount)) }) ); amount0 = uint256(-amount0Int); amount1 = uint256(-amount1Int); if (amount0 \u0026gt; 0 || amount1 \u0026gt; 0) { (position.tokensOwed0, position.tokensOwed1) = ( position.tokensOwed0 + uint128(amount0), position.tokensOwed1 + uint128(amount1) ); } emit Burn(msg.sender, lowerTick, upperTick, amount, amount0, amount1); } In burn function, we first update a position and remove some amount of liquidity from it. Then, we update the token amount owed by the position–they now include amounts accumulated via fees as well as amounts that were previously provided as liquidity. We can also see this as conversion of position liquidity into token amounts owed by the position– these amounts won\u0026rsquo;t be used as liquidity anymore and can be freely redeemed by calling the collect function:\nfunction collect( address recipient, int24 lowerTick, int24 upperTick, uint128 amount0Requested, uint128 amount1Requested ) public returns (uint128 amount0, uint128 amount1) { Position.Info memory position = positions.get( msg.sender, lowerTick, upperTick ); amount0 = amount0Requested \u0026gt; position.tokensOwed0 ? position.tokensOwed0 : amount0Requested; amount1 = amount1Requested \u0026gt; position.tokensOwed1 ? position.tokensOwed1 : amount1Requested; if (amount0 \u0026gt; 0) { position.tokensOwed0 -= amount0; IERC20(token0).transfer(recipient, amount0); } if (amount1 \u0026gt; 0) { position.tokensOwed1 -= amount1; IERC20(token1).transfer(recipient, amount1); } emit Collect( msg.sender, recipient, lowerTick, upperTick, amount0, amount1 ); } This function simply transfers tokens from a pool and ensures that only valid amounts can be transferred (one cannot transfer out more than they burned + fees they earned).\nThere\u0026rsquo;s also a way to collect fees only without burning liquidity: burn 0 amount of liquidity and then call collect. During burning, the position will be updated and token amounts it owes will be updated as well.\nAnd, that\u0026rsquo;s it! Our pool implementation is complete now!\n"},{"id":11,"href":"/docs/milestone_3/different-ranges/","title":"不同价格区间","section":"Milestone 3. 跨tick交易","content":" \\[ \\] 不同价格区间 # 在我们之前的实现中，我们仅仅创建包含现价的价格区间：\n// src/UniswapV3Pool.sol function mint( ... amount0 = Math.calcAmount0Delta( slot0_.sqrtPriceX96, TickMath.getSqrtRatioAtTick(upperTick), amount ); amount1 = Math.calcAmount1Delta( slot0_.sqrtPriceX96, TickMath.getSqrtRatioAtTick(lowerTick), amount ); liquidity += uint128(amount); ... } 从这段代码中你也可以看到，我们总是会更新流动性tracker（跟踪现在可用的流动性，即在现价时候可用的流动性）。\n然而，在现实中，也可以创建低于或高于现价的价格区间。Uniswap V3的设计允许LP提供当前不可用的流动性。这些流动性只有当现价进入这些“休眠”的流动性取件时才会被“注入”。\n以下是几种可能存在的价格区间情况：\n活跃价格区间，也即包含现价的价格区间 低于现价的价格区间，该价格区间的上界tick低于现价tick 高于现价的价格区间，该价格区间的下界tick高于现价tick 限价单 # 一个有趣的事实是：非活跃的流动性（所在区间不包含现价）可以被看做是限价单(limit orders)。\n在交易中，限价单是一种当价格突破用户设定的某个点的时候才会被执行的订单。例如，你希望放一个限价单，当ETH价格低于$1000的时候买入一个ETH。类似地，你可以使用限价单来出售资产。在Uniswap V3中，你可以通过在非活跃价格区间提供流动性来达到类似的目的。让我们来看一下它如何工作：\n如果你在低于或高于现价的位置提供流动性（整个价格区间都低于/高于现价），那么你提供的流动性将完全由一种资产组成——两种资产中较便宜的那一种。在我们的例子中，我们的池子是把ETH作为 token $x$，把USDC作为 token $y$ ，我们的价格定义为：\n$$P = \\frac{y}{x}$$\n如果我们把流动性放置在低于现价的区间，那么流动性将只会由USDC组成，因为当我们添加流动性的时候USDC的价格低于现价。类似地，如果我们高于现价的区间提供流动性，那么流动性将完全由ETH组成，因为ETH的价格低于现价。\n回顾一下我们在简介中的图表：\n如果我们购买这个区间中所有可用的ETH，这个区间内将只会由另一种token组成，USDC，并且价格将会沿着曲线移动到最右边。这个价格，也即 $\\frac{y}{x}$，会升高。如果有一个价格区间在当前区间的右边，它将需要提供ETH的流动性，并且仅包含ETH：它需要为接下来的交易提供ETH。如果我们持续购买并且拉高价格，我们可能会继续“耗尽”下一个价格区间，也即买走它所有的ETH并卖出USDC。同样，这个区间会以全部是USDC而中止，现价移出这个区间。\n类似地，如果我们购买USDC，我们会使得价格向左移动并且从池子中移出USDC。下一个价格区间会仅包含USDC代币来满足需求，并且类似地，如果我们继续买光这个区间的所有USDC，它也会以仅包含ETH而中止。\n注意到一个有趣的点：当跨越整个价格区间时，其中的流动性从一种token交易为另外一种。并且如果我们设置一个相当窄的价格区间，价格会快速越过整个区间，我们就得到了一个限价单！例如，如果我们想在某个低价点购入ETH，我们可以在一个低价区间提供仅包含USDC的流动性，等待价格越过这个区间。在这之后，我们就可以移出流动性，所有的USDC都转换成了ETH！\n希望这个例子没有让你感到困惑，我觉得这是一个理解价格区间动态变化的很好的例子。\n更新mint函数 # 为了支持上面提到的各种价格区间，我们需要知道现价究竟是低于、位于，还是高于用户提供的价格区间，并且计算相应的token数量。如果价格区间高于现价，我们希望它的流动性仅仅由 token $x$ 组成：\n// src/UniswapV3Pool.sol function mint( ... if (slot0_.tick \u0026lt; lowerTick) { amount0 = Math.calcAmount0Delta( TickMath.getSqrtRatioAtTick(lowerTick), TickMath.getSqrtRatioAtTick(upperTick), amount ); ... 当价格区间包含现价，我们希望两种 token 的价格与现价成比例（这是我们之前实现的部分）：\n} else if (slot0_.tick \u0026lt; upperTick) { amount0 = Math.calcAmount0Delta( slot0_.sqrtPriceX96, TickMath.getSqrtRatioAtTick(upperTick), amount ); amount1 = Math.calcAmount1Delta( slot0_.sqrtPriceX96, TickMath.getSqrtRatioAtTick(lowerTick), amount ); liquidity = LiquidityMath.addLiquidity(liquidity, int128(amount)); 注意到，这是唯一一个我们会更新liquidity 的场景，因为这个变量是跟踪现在可用的流动性数量。\n当价格区间低于现价，区间仅仅包含 token $y$：\n} else { amount1 = Math.calcAmount1Delta( TickMath.getSqrtRatioAtTick(lowerTick), TickMath.getSqrtRatioAtTick(upperTick), amount ); } 这就是mint的全部更新！\n"},{"id":12,"href":"/docs/introduction/constant-function-market-maker/","title":"恒定函数做市商(CFMM)","section":"Milestone 0. 简介","content":" \\[ \\] 恒定函数做市商 (Constant Function Market Makers) # 本章节主要讲述了Uniswap V2白皮书中的内容. 理解其中的数学原理能帮助你更好地构建像Uniswap这样的应用, 不过假设你没有理解本章全部内容也没有关系\n正如我们在上一节中提到的那样，AMM的构建有许多不同的方法。我们将主要关注与构建一种特定的AMM：恒定函数做市商（有时也被称为恒定乘积做市商）。尽管名字听起来很复杂，但是它的核心数学原理只是一个非常简单的公式：\n$$x * y = k$$\n仅此而已，这就是AMM.\n$x$ 和 $y$ 是池子合约所拥有的两种资产的数目。$k$ 是它们的乘积，我们暂时不考虑它的实际值等于多少。\n为什么只有两种资产x和y？ 每个Uniswap的池子仅包含两种token。我们使用x和y来表示一个池子中的两种资产，其中x代表第一个token，y代表第二个token。两种token的顺序并不重要。\n恒定函数做市商的原理是：在每次交易后，k必须保持不变。当用户进行交易，他们通常将一种类型的token放入池子（也即他们打算卖出的token），并且将另一种类型的token移出池子（也即打算购买的token）。这笔交易会改变池子中两种资产的数量，而上述原理表示，两种资产数目的乘积必须保持不变。我们之后还会在本书中看到许多次这个原理，这就是Uniswap的核心机制。\n交易函数 # 现在我们知道了什么是池子以及交易的原理，接下来我们写一下交易发生时的公式：\n$$(x + r\\Delta x)(y - \\Delta y) = k$$\n一个池子包含一定数量的token 0 ($x$)和一定数量的token 1 ($y$) 当我们用token 0购买token 1的时候，一些token 0被放入池子 ($\\Delta x$) 这个池子将给我们一定数量的token 1作为交换 ($\\Delta y$) 池子也会从我们付出的token 0中收取一定数量的手续费 ($r$) 池子中token 0的数量发生了变化 ($x + r \\Delta x$)， token 1的数量也发生了变化 ($y - \\Delta y$) 二者的乘积保持不变，仍然为 $k$ 我们使用token 0和token 1这样的表述是因为代码中就是如此命名的。在现在，两个token的顺序并不关键\n简单来说，我们给了池子一定数量的token 0，然后获得了一定数量的token 1。这个池子的工作就是给予我们正确数量的token 1，按照一个公平的价格。这会让我们得出以下结论：池子决定了交易的价格。\n价格 # 池子里token的价格是如何计算的？\n由于Uniswap不同的池子是不同的智能合约，同一个池子里的两种token互为计价标准进行定价。例如：在一个ETH/USDC的池子里，ETH的价格用USDC作为标定，而USDC的价格用ETH作为标定。假设一个ETH的价格是1000USDC，那么一个USDC的价格就是0.001ETH。每一个池子都是如此，不管token是否为稳定币（例如，ETH/BTC池）\n在现实世界中，价格是根据供求关系来决定的，对于AMM当然也是如此，现在，我们先不考虑需求方，只关注供给方。\n池子中token的价格是由token的供给量决定的，也即池子中拥有该token的资产数目。token的价格也由此决定：\n$$P_x = \\frac{y}{x}, \\quad P_y=\\frac{x}{y}$$\n其中 $P_x$ 和 $P_y$ 是一个token相对于另一个token的价格\n这个价格被称作 现货价格， 它反映了当前的市场价。然而，交易实际成交的价格却并不是这个价格。现在我们再重新把需求方纳入考虑：\n根据供求关系，高需求使价格增长，这也是我们应当在去中心化交易中满足的性质。我们希望当需求很高的时候价格会升高，并且我们能够用池子里的资产数量来衡量需求：你希望从池子中获取某个token的数量越多，价格变动就越剧烈。我们再重新考虑上面这个公式：\n$$(x + r\\Delta x)(y - \\Delta y) = xy$$\n从这个公式中，我们能够推导出关于 $\\Delta x$ 和 $\\Delta y$ 的式子，这也意味着我们能够通过交易付出的token数目来计算出获得的token数目，反之亦然：\n$$\\Delta y = \\frac{yr\\Delta x}{x + r\\Delta x}$$ $$\\Delta x = \\frac{x \\Delta y}{r(y - \\Delta y)}$$\n事实上，这些公式就能够让我们重新计算价格。我们能够从 $\\Delta y$ 公式中求出获得token数量（当我们希望卖出一定数量的token，即input amount为给定值），并且从 $\\Delta x$ 的公式中求出需要提供的token数量（当我们希望购买一定数量的token，即output amount为给定值）。注意到，这里的公式是资产之间的关系，同时也把交易的数目(第一个公式中的 $\\Delta x$ 和第二个公式中的 $\\Delta y$)加入了计算。这是同时考虑了供求双方的价格函数。更进一步，我们甚至并不需要去计算价格！（因为我们直接计算出了交易的结果）\n下面是从交易函数推导出上述价格函数的过程: $$(x + r\\Delta x)(y - \\Delta y) = xy$$\n$$y - \\Delta y = \\frac{xy}{x + r\\Delta x}$$\n$$-\\Delta y = \\frac{xy}{x + r\\Delta x} - y$$\n$$-\\Delta y = \\frac{xy - y({x + r\\Delta x})}{x + r\\Delta x}$$\n$$-\\Delta y = \\frac{xy - xy - y r \\Delta x}{x + r\\Delta x}$$\n$$-\\Delta y = \\frac{- y r \\Delta x}{x + r\\Delta x}$$\n$$\\Delta y = \\frac{y r \\Delta x}{x + r\\Delta x}$$ 以及: $$(x + r\\Delta x)(y - \\Delta y) = xy$$\n$$x + r\\Delta x = \\frac{xy}{y - \\Delta y}$$\n$$r\\Delta x = \\frac{xy}{y - \\Delta y} - x$$\n$$r\\Delta x = \\frac{xy - x(y - \\Delta y)}{y - \\Delta y}$$\n$$r\\Delta x = \\frac{xy - xy + x \\Delta y}{y - \\Delta y}$$\n$$r\\Delta x = \\frac{x \\Delta y}{y - \\Delta y}$$\n$$\\Delta x = \\frac{x \\Delta y}{r(y - \\Delta y)}$$\n曲线 # 上面的数学计算可能有些抽象和枯燥，下面我们来把恒定乘积函数进行可视化来更好地理解其工作原理\n恒定成绩函数的图像为二次双曲线：\n横纵轴分别表示池子中两种代币的数量。每一笔交易的起始点都是曲线上与当前两种代币比例相对应的点。为了计算交易获得的token数量，我们需要找到曲线上的一个新的点，其x坐标值为 $x+\\Delta x$，也即池子中现在token 0的数量加上我们卖出的数量。y轴上的变化量就是我们将会获得的token 1的数量。\n下面我们来看一个更加具体的例子:\n紫色的线是公式代表的双曲线，横纵坐标轴代表池子中代币资产的数目（注意到在一开始，两种代币的数量相等） 起始价格为1 我们卖出200个token 0，如果我们仅以现货价格计算，我们希望获得200个token 1。 然而，交易实际发生的价格是0.666，所以我们仅仅获得了133.333个token 1！ 这个例子来源于the Desmos chart，作者是Dan Robinson, Uniswap的创作者之一。 为了能够更直观地理解它是如何工作的，尝试自己构建不同的场景并且在图上画出来。尝试不同的资产数目，观察当$\\Delta x$ 远小于 $x$ 时获得代币的数量 （译者注：强烈推荐去玩一玩上面这个demo网站）\n一个很传奇的故事是，Uniswap就是在Desmos中发明出来的.\n我猜你或许在想，为什么要用这样的一个曲线？这个曲线看起来好像是在惩罚大额交易者。事实上，的确就是如此，并且这也是一个非常合适的性质！供求关系告诉我们，当需求很高的时候（假设供给保持不变），价格也同样很高；当需求低的时候，价格也仍然很低。这正是市场的工作原理。并且很神奇地是，这样一个恒定乘积函数恰好实现了这个机制！需求就是你希望购买token的数量，而供给就是池子中的资产。当你希望购买的数量占池子的一个很大比例，价格就会比你购买小数量时更高。这样一个简单的公式，恰恰保证了这么一个强大的机制！\n尽管Uniswap并不计算交易价格，我们仍然能够从曲线上看到它。惊奇的是，在一笔交易中我们有很多个价格：\n在交易前，有一个现货价格。这个价格等于池子中两种资产的比例，$y/x$ 或者 $x/y$，取决于你交易的方向。这个价格也是起始点切线的斜率。 在交易后，有一个新的现货价格，在曲线上另一个不同的点。这个价格是新的点的切线斜率。 这个交易的实际发生价格，是连接新旧点的这条线的斜率！ 这就是Uniswap里用到的全部数学！\n好吧，事实上这只是Uniswap V2的数学原理，而我们将要学习的是Uniswap V3。所以在下一章，我们将会看到Uniswap V3的机制有什么不同。\n"},{"id":13,"href":"/docs/milestone_1/calculating-liquidity/","title":"计算流动性","section":"Milestone 1. 第一笔交易","content":" \\[ \\] 计算流动性 # 没有流动性就无法进行交易，因此为了能够完成我们的第一笔交易，我们首先需要向池子中添加一些流动性。为了向池子合约添加流动性，我们需要知道：\n一个价格区间，即LP希望他的流动性仅在这个区间上提供和被利用 提供流动性的数量，也即提供的两种代币的数量，我们需要将它们转入池子合约。 在本节中，我们会手动计算上述变量的值；在后续章节中，我们会在合约中对此进行实现。首先我们来考虑价格区间\n价格区间计算 # 回忆一下上一章所讲，在Uniswap V3中，整个价格区间被划分成了ticks：每个tick对应一个价格，以及有一个编号。在我们的第一个实现中，我们的现货价格设置为1ETH对5000USDC。购买ETH会移除池子中的一部分ETH，从而使得价格变得高于5000USDC。我们希望在一个包含此价格的区间中提供流动性，并且要确保最终的价格落在这个区间内。（跨区间的交易将会在后续章节提到）。\n我们需要找到3个tick：\n对应现货价格的tick（1ETH-5000USDC） 提供流动性的价格区间上下界对应的tick。在这里，下界为4545u，上界为5500u。 （译者注：4545u，$4545，4545USDC均代表相同含义，在本书中可能会混合使用）\n从之前的章节中我们知道下述公式：\n$$\\sqrt{P} = \\sqrt{\\frac{y}{x}}$$\n由于我们把ETH作为资产$x$，USDC作为资产$y$，每个tick对应的值为：\n$$\\sqrt{P_c} = \\sqrt{\\frac{5000}{1}} = \\sqrt{5000} \\approx 70.71$$\n$$\\sqrt{P_l} = \\sqrt{\\frac{4545}{1}} \\approx 67.42$$\n$$\\sqrt{P_u} = \\sqrt{\\frac{5500}{1}} \\approx 74.16$$\n在这里，$P_c$代表现货价格，$P_l$代表区间下界，$P_u$代表区间上界。\n接下来，我们可以计算价格对应的ticks。使用下面公式：\n$$\\sqrt{P(i)}=1.0001^{\\frac{i}{2}}$$\n我们可以得到关于$i$的公式：\n$$i = log_{\\sqrt{1.0001}} \\sqrt{P(i)}$$\n公式中的两个根号实际上是可以消去的，但由于我们会使用$\\sqrt{p}$进行计算，我们选择保留根号\n这几个对应的tick分别为:\n现货tick: $i_c = log_{\\sqrt{1.0001}} 70.71 = 85176$ 下界tick: $i_l = log_{\\sqrt{1.0001}} 67.42 = 84222$ 上界tick: $i_u = log_{\\sqrt{1.0001}} 74.16 = 86129$ 计算过程使用的是Python：\nimport math def price_to_tick(p): return math.floor(math.log(p, 1.0001)) price_to_tick(5000) \u0026gt; 85176 价格区间的计算就是这样！\n最后需要提到的是，在Solidity中，Uniswap使用Q64.96来存储$\\sqrt{p}$。这是一个整数位由64位表示、小数位由96位表示的定点数格式。在我们上面的计算中，价格按照浮点数形式计算：70.71, 67.42, 74.16。我们需要将它们转换成Q64.96格式，也非常简单：只需要将这个数乘以$2^{96}$，即可得到：\n$$\\sqrt{P_c} = 5602277097478614198912276234240$$\n$$\\sqrt{P_l} = 5314786713428871004159001755648$$\n$$\\sqrt{P_u} = 5875717789736564987741329162240$$\n在Python中：\nq96 = 2**96 def price_to_sqrtp(p): return int(math.sqrt(p) * q96) price_to_sqrtp(5000) \u0026gt; 5602277097478614198912276234240 注意先进行乘法再取整，否则会损失精度\nToken数量计算 # 接下来，我们需要决定向池子中投入多少token。答案是：越多越好。数量并没有严格定义，我们质押的数目越多，购买同样数量的ETH就会使得价格的变动越小，防止离开我们的价格区间。在开发和测试智能合约的过程中，我们可以获得任意数量的token，所以钱不是问题。\n为了实现我们的第一笔交易，我们将会在池子中质押1ETH和5000USDC。\n要记得池子中资产数量的比例决定了现货价格。所以假设我们希望像池子中投入更多的资产而保持现货价格不变，我们投入的资产也必须满足同样的比例，例如：2ETH和10,000USDC；10ETH和50,000USDC。\n流动性数量计算 # 接下来，我们将基于我们质押token的数量计算流动性$L$的值。这部分可能略有难度，记得跟紧！\n根据之前我们提到过的公式，流动性数量如下计算：\n$$L = \\sqrt{xy}$$\n然而，上述公式是用于无穷价格区间曲线的 🙂。但我们希望的是把流动性放在某个有界的价格区间，仅仅是无穷曲线的一部分。我们需要针对我们希望流动性存在的价格区间来计算对应的$L$，因此可能需要一些更复杂的计算。\n为了计算这个价格区间的$L$，我们来回顾我们之前讨论过的一个有趣的点：价格区间可以被耗尽。我们可以将一个价格区间的某种token全部买走，使得该区间中只有另一种token：\n在上图中的两个边界点，区间流动性池中都只有一种token：在$a$点池子里只有ETH，在$b$点只有USDC。\n也就是说，我们希望能够找到一个$L$，使得价格能够移动到两个端点处。我们需要足够的流动性来使得价格能够达到上下界，因此，我们会希望通过$\\Delta x$和$\\Delta y$的最大值来计算流动性。\n现在我们来看一下边界点的价格。当从池子中购买ETH，价格会升高；当从池子中购买USDC（卖出ETH），价格会下跌。由于价格为$\\frac{y}{x}$，所以$a$点为价格最低点，$b$点为价格最高点。\n事实上，按照公式，在这两个点的价格是没有定义的，因为池子中只有一种token，但是我们在这里只需要理解，$b$点的价格高于起始价格，$a$点价格低于起始价格即可。\n现在，我们将图中的曲线分为两部分：起始点左边和起始点右边。我们将在两边分别计算出$L$。为什么会有两个？因为池子中的两种资产分别对其中一边起作用。由于我们希望流动性均匀分布在这个区间，我们最后会选取两个$L$中较小的一个。\n（译者注：保证需要提供的token数量不超过原始预计的token数量）\n最后还需要说明的一个关键点是：新的流动性需要保证不改变现货价格。也即，它必须与现在两种资产的数量成比例。这也是为什么我们上面会计算出两个$L$-因为仅考虑一种资产，没有保证比例。我们选择较小的那个$L$来重新计算比例。\n或许在后面小节实现代码的过程中我们会对此有更多感觉吧。现在我们来看公式\n回忆一下， $\\Delta x$ 和 $\\Delta y$ 的计算公式为：\n$$\\Delta x = \\Delta \\frac{1}{\\sqrt{P}} L$$ $$\\Delta y = \\Delta \\sqrt{P} L$$\n我们把上述公式中的:$\\Delta \\sqrt{P}$ 相关部分展开：\n$$\\Delta x = (\\frac{1}{\\sqrt{P_b}} - \\frac{1}{\\sqrt{P_c}}) L$$ $$\\Delta y = (\\sqrt{P_c} - \\sqrt{P_a}) L$$\n$P_a$ 是 $a$点的价格，$P_b$ 是 $b$点的价格, $P_c$ 是现货价格。\n我们接下来根据第一个公式推导出计算$L$的公式：\n$$\\Delta x = (\\frac{1}{\\sqrt{P_b}} - \\frac{1}{\\sqrt{P_c}}) L$$ $$\\Delta x = \\frac{L}{\\sqrt{P_b}} - \\frac{L}{\\sqrt{P_c}}$$ $$\\Delta x = \\frac{L(\\sqrt{P_b} - \\sqrt{P_c})}{\\sqrt{P_b} \\sqrt{P_c}}$$ $$L = \\Delta x \\frac{\\sqrt{P_b} \\sqrt{P_c}}{\\sqrt{P_b} - \\sqrt{P_c}}$$\n从第二个公式推导: $$\\Delta y = (\\sqrt{P_c} - \\sqrt{P_a}) L$$ $$L = \\frac{\\Delta y}{\\sqrt{P_c} - \\sqrt{P_a}}$$\n这就是我们的两个$L$的计算公式，跟别对应起始点两边的两段曲线:\n$$L = \\Delta x \\frac{\\sqrt{P_b} \\sqrt{P_c}}{\\sqrt{P_b} - \\sqrt{P_c}}$$ $$L = \\frac{\\Delta y}{\\sqrt{P_c} - \\sqrt{P_a}}$$\n接下来，我们把之前计算出的价格代入公式:\n$$L = \\Delta x \\frac{\\sqrt{P_b}\\sqrt{P_c}}{\\sqrt{P_b}-\\sqrt{P_c}} = 1 ETH * \\frac{67.42 * 70.71}{70.71 - 67.42}$$ 转换成Q64.96后得到:\n$$L = 1519437308014769733632$$\n对于另一个$L$: $$L = \\frac{\\Delta y}{\\sqrt{P_c}-\\sqrt{P_a}} = \\frac{5000USDC}{74.16-70.71}$$ $$L = 1517882343751509868544$$\n两者中，我们选择小的那一个\nPython计算:\nsqrtp_low = price_to_sqrtp(4545) sqrtp_cur = price_to_sqrtp(5000) sqrtp_upp = price_to_sqrtp(5500) def liquidity0(amount, pa, pb): if pa \u0026gt; pb: pa, pb = pb, pa return (amount * (pa * pb) / q96) / (pb - pa) def liquidity1(amount, pa, pb): if pa \u0026gt; pb: pa, pb = pb, pa return amount * q96 / (pb - pa) liq0 = liquidity0(amount_eth, sqrtp_cur, sqrtp_upp) liq1 = liquidity1(amount_usdc, sqrtp_cur, sqrtp_low) liq = int(min(liq0, liq1)) \u0026gt; 1517882343751509868544 重新计算token数量 # 尽管我们初始选择了我们想要质押的token数目，这个数目可能并不准确。我们并不能在任何价格区间质押任何比例的token来获取流动性，因为流动性需要满足在价格区间的曲线上均匀分布。因此，尽管用户选择了其实数量，合约会对它们重新计算，所以实际的数量会略有不同（至少，由于取整的精度变化）\n幸运的是，我们已经获得了对应的公式\n$$\\Delta x = \\frac{L(\\sqrt{P_b} - \\sqrt{P_c})}{\\sqrt{P_b} \\sqrt{P_c}}$$ $$\\Delta y = L(\\sqrt{P_c} - \\sqrt{P_a})$$\n在Python中:\ndef calc_amount0(liq, pa, pb): if pa \u0026gt; pb: pa, pb = pb, pa return int(liq * q96 * (pb - pa) / pa / pb) def calc_amount1(liq, pa, pb): if pa \u0026gt; pb: pa, pb = pb, pa return int(liq * (pb - pa) / q96) amount0 = calc_amount0(liq, sqrtp_upp, sqrtp_cur) amount1 = calc_amount1(liq, sqrtp_low, sqrtp_cur) (amount0, amount1) \u0026gt; (998976618347425408, 5000000000000000000000) 正如上述计算结果，得到的数据基本等于我们想要提供的数量，不过ETH略少一点\nHint: 使用 cast --from-wei AMOUNT 来把wei转换成ether, 示例:\ncast --from-wei 998976618347425280 输出 0.998976618347425280.\n"},{"id":14,"href":"/docs/milestone_2/output-amount-calculation/","title":"输出金额计算","section":"Milestone 2. 第二笔交易","content":" \\[ \\] 输出金额计算 # 我们的Uniswap数学公式中还缺最后一个组成部分：计算卖出 ETH (即 token $x$ )时获得的资产数量。在前一章中，我们有一个类似的公式计算购买ETH(购买 token $x$)的场景：\n$$\\Delta \\sqrt{P} = \\frac{\\Delta y}{L}$$\n这个公式计算卖出token $y$时的价格变化。我们把这个差价加到现价上面，来得到目标价格：\n$$\\sqrt{P_{target}} = \\sqrt{P_{current}} + \\Delta \\sqrt{P}$$\n现在，我们需要一个类似的公式来计算卖出 token $x$（在本案例中为 ETH）买入 token $y$（在本案例中为 USDC）时的目标价格（在本案例中为卖出 ETH）。\n回忆一下，token $x$ 的变化可以如下计算：\n$$\\Delta x = \\Delta \\frac{1}{\\sqrt{P}}L$$\n从上面公式，我们可以推导出目标价格：\n$$\\Delta x = (\\frac{1}{\\sqrt{P_{target}}} - \\frac{1}{\\sqrt{P_{current}}}) L$$ $$= \\frac{L}{\\sqrt{P_{target}}} - \\frac{L}{\\sqrt{P_{current}}}$$\n$$\\ \\sqrt{P_{target}} = \\frac{\\sqrt{P}L}{\\Delta x \\sqrt{P} + L}$$\n知道了目标价格，我们就能够用前一章类似的方式计算出输出的金额\n更新一下对应的Python脚本\n# Swap ETH for USDC amount_in = 0.01337 * eth print(f\u0026#34;\\nSelling {amount_in/eth} ETH\u0026#34;) price_next = int((liq * q96 * sqrtp_cur) // (liq * q96 + amount_in * sqrtp_cur)) print(\u0026#34;New price:\u0026#34;, (price_next / q96) ** 2) print(\u0026#34;New sqrtP:\u0026#34;, price_next) print(\u0026#34;New tick:\u0026#34;, price_to_tick((price_next / q96) ** 2)) amount_in = calc_amount0(liq, price_next, sqrtp_cur) amount_out = calc_amount1(liq, price_next, sqrtp_cur) print(\u0026#34;ETH in:\u0026#34;, amount_in / eth) print(\u0026#34;USDC out:\u0026#34;, amount_out / eth) 输出：\nSelling 0.01337 ETH New price: 4993.777388290041 New sqrtP: 5598789932670289186088059666432 New tick: 85163 ETH in: 0.013369999999998142 USDC out: 66.80838889019013 上述结果显示，在之前提供流动性的基础上，卖出0.01337 ETH 可以获得 66.8 USDC。\n这看起来还不错，但是我们已经受够了使用Python！下面我们将会在Solidity中实现所有的数学计算。\n"},{"id":15,"href":"/docs/milestone_3/cross-tick-swaps/","title":"Cross-Tick Swaps","section":"Milestone 3. 跨tick交易","content":" \\[ \\] Cross-Tick Swaps # Cross-tick swaps is probably the most advanced feature of Uniswap V3. Luckily, we have already implemented almost everything we need to make cross-tick swaps. Let\u0026rsquo;s see how cross-tick swaps work before implementing them.\nHow Cross-Tick Swaps Work # A common Uniswap V3 pool is a pool with many overlapping (and outstanding) price ranges. Each pool tracks current $\\sqrt{P}$ and tick. When users swap tokens they move current price and tick to the left or to the right, depending on swap direction. These movements are caused by tokens being added and removed from pools during swaps.\nPools also track $L$ (liquidity variable in our code), which is the total liquidity provided by all price ranges that include current price. It\u0026rsquo;s expected that, during big price moves, current price moves outside of price ranges. When this happens, such price ranges become inactive and their liquidity gets subtracted from $L$. On the other hand, when current price enters a price range, $L$ is increased and the price range gets activated.\nLet\u0026rsquo;s analyze this illustration:\nThere are three price ranges on this image. The top one is the one currently engaged, it includes the current price. The liquidity of this price range is set to the liquidity state variable of the Pool contract.\nIf we buy all the ETH from the top price range, the price will increase and we\u0026rsquo;ll move to the right price range, which at this moment contains only ETH, not USDC. We might stop in this price range if there\u0026rsquo;s enough liquidity to satisfy our demand. In this case, the liquidity variable will contain only the liquidity provided by this price range. If we continue buying ETH and deplete the right price range, we\u0026rsquo;ll need another price range that\u0026rsquo;s to the right of this price range. If there are no more price ranges, we\u0026rsquo;ll have to stop, and our swap will be satisfied only partially.\nIf we buy all the USDC from the top price range (and sell ETH), the price will decrease and we\u0026rsquo;ll move to the left price range–at this moment it contains only USDC. If we deplete it, we\u0026rsquo;ll need another price range to the left of it.\nThe current price moves during swapping. It moves from one price range to another, but it must always stay within a price range–otherwise, trading is not possible.\nOf course, price ranges can overlap, so, in practice, the transition between price ranges is seamless. And it\u0026rsquo;s not possible to hop over a gap–a swap would be completed partially. It\u0026rsquo;s also worth noting that, in the areas where price ranges overlap, price moves slower. This is due to the fact that supply is higher in such areas and the effect of demand is lower (recall from the introduction that high demand with low supply increases the price).\nOur current implementation doesn\u0026rsquo;t support such fluidity: we only allow swaps within one active price range. This is what we\u0026rsquo;re going to improve now.\nUpdating computeSwapStep Function # In the swap function, we\u0026rsquo;re iterating over initialized ticks (that is, ticks with liquidity) to fill the amount the user has requested. In each iteration, we:\nfind next initialized tick using tickBitmap.nextInitializedTickWithinOneWord; swap in the range between the current price and the next initialized tick (using SwapMath.computeSwapStep); always expect that current liquidity is enough to satisfy the swap (i.e. the price after swap is between the current price and the next initialized tick). But what happens if the third step is not true? We have this scenario covered in tests:\n// test/UniswapV3Pool.t.sol function testSwapBuyEthNotEnoughLiquidity() public { ... uint256 swapAmount = 5300 ether; ... vm.expectRevert(stdError.arithmeticError); pool.swap(address(this), false, swapAmount, extra); } The \u0026ldquo;Arithmetic over/underflow\u0026rdquo; happens when the pool tries to send us more ether than it has. This error happens because, in our current implementation, we always expect that there\u0026rsquo;s enough liquidity to satisfy any swap:\n// src/lib/SwapMath.sol function computeSwapStep(...) { ... sqrtPriceNextX96 = Math.getNextSqrtPriceFromInput( sqrtPriceCurrentX96, liquidity, amountRemaining, zeroForOne ); amountIn = ... amountOut = ... } To improve this, we need to consider several situations:\nwhen the range between the current and the next ticks has enough liquidity to fill amountRemaining; when the range doesn\u0026rsquo;t fill the entire amountRemaining. In the first case, the swap is done entirely within the range–this is the scenario we have implemented. In the second situation, we\u0026rsquo;ll consume the whole liquidity provided by the range and will move to the next range (if it exists). With this in mind, let\u0026rsquo;s rework computeSwapStep:\n// src/lib/SwapMath.sol function computeSwapStep(...) { ... amountIn = zeroForOne ? Math.calcAmount0Delta( sqrtPriceCurrentX96, sqrtPriceTargetX96, liquidity ) : Math.calcAmount1Delta( sqrtPriceCurrentX96, sqrtPriceTargetX96, liquidity ); if (amountRemaining \u0026gt;= amountIn) sqrtPriceNextX96 = sqrtPriceTargetX96; else sqrtPriceNextX96 = Math.getNextSqrtPriceFromInput( sqrtPriceCurrentX96, liquidity, amountRemaining, zeroForOne ); amountIn = Math.calcAmount0Delta( sqrtPriceCurrentX96, sqrtPriceNextX96, liquidity ); amountOut = Math.calcAmount1Delta( sqrtPriceCurrentX96, sqrtPriceNextX96, liquidity ); } First, we calculate amountIn–the input amount the current range can satisfy. If it\u0026rsquo;s smaller than amountRemaining, we say that the current price range cannot fulfil the whole swap, thus the next $\\sqrt{P}$ is the upper/lower $\\sqrt{P}$ of the price range (in other words, we use the entire liquidity of the price range). If amountIn is greater than amountRemaining, we compute sqrtPriceNextX96–it\u0026rsquo;ll be a price within the current price range.\nIn the end, after figuring the next price, we re-compute amountIn and compute amountOut withing this shorter price range (we don\u0026rsquo;t consume the entire liquidity).\nI hope this makes sense!\nUpdating swap Function # Now, in swap function, we need to handle the case we introduced in the previous part: when swap price reaches a boundary of a price range. When this happens, we want to deactivate the price range we\u0026rsquo;re leaving and active the next price range. We also want to start another iteration of the loop and try to find another tick with liquidity.\nHere\u0026rsquo;s what we need to add to the end of the loop:\nif (state.sqrtPriceX96 == step.sqrtPriceNextX96) { int128 liquidityDelta = ticks.cross(step.nextTick); if (zeroForOne) liquidityDelta = -liquidityDelta; state.liquidity = LiquidityMath.addLiquidity( state.liquidity, liquidityDelta ); if (state.liquidity == 0) revert NotEnoughLiquidity(); state.tick = zeroForOne ? step.nextTick - 1 : step.nextTick; } else { state.tick = TickMath.getTickAtSqrtRatio(state.sqrtPriceX96); } The second branch is what we had before–it handles the case when current price stays within the range. So let\u0026rsquo;s focus on the first one.\nstate.sqrtPriceX96 is the new current price, i.e. the price that will be set after the current swap; step.sqrtPriceNextX96 is the price at the next initialized tick. If these are equal, we have reached a price range boundary. As explained above, when this happens, we want to update $L$ (add or remove liquidity) and continue the swap using the boundary tick as the current tick.\nBy convention, crossing a tick means crossing it from left to right. Thus, crossing lower ticks always adds liquidity and crossing upper ticks always removes it. However, when zeroForOne is true, we negate the sign: when price goes down (token $x$ is being sold), upper ticks add liquidity and lower ticks remove it.\nWhen updating state.tick, if price moves down (zeroForOne is true), we need to subtract 1 to step out of the price range. When moving up (zeroForOne is false), current tick is always excluded in TickBitmap.nextInitializedTickWithinOneWord.\nAnother small, but very important, change that we need to make is to update $L$ when crossing a tick. We do this after the loop:\nif (liquidity_ != state.liquidity) liquidity = state.liquidity; Within the loop, we update state.liquidity multiple times when entering/leaving price ranges. After a swap, we need to update the global $L$ for it to reflect the liquidity available at the new current price.\nLiquidity Tracking and Ticks Crossing # Let\u0026rsquo;s now look at updated Tick library.\nFirst change is in Tick.Info structure: we now have two variables to track tick liquidity:\nstruct Info { bool initialized; // total liquidity at tick uint128 liquidityGross; // amount of liqudiity added or subtracted when tick is crossed int128 liquidityNet; } liquidityGross tracks the absolute liquidity amount of a tick. It\u0026rsquo;s needed to find if tick was flipped or not. liquidityNet, on the other hand, is a signed integer–it tracks the amount of liquidity added (in case of lower tick) or removed (in case of upper tick) when a tick is crossed.\nliquidityNet is set in update function:\nfunction update( mapping(int24 =\u0026gt; Tick.Info) storage self, int24 tick, int128 liquidityDelta, bool upper ) internal returns (bool flipped) { ... tickInfo.liquidityNet = upper ? int128(int256(tickInfo.liquidityNet) - liquidityDelta) : int128(int256(tickInfo.liquidityNet) + liquidityDelta); } The cross function we saw above simply returns liquidityNet (it\u0026rsquo;ll get more complicated after we introduce new features in later milestones):\nfunction cross(mapping(int24 =\u0026gt; Tick.Info) storage self, int24 tick) internal view returns (int128 liquidityDelta) { Tick.Info storage info = self[tick]; liquidityDelta = info.liquidityNet; } Testing # Let\u0026rsquo;s review different liquidity set ups and test them to ensure our pool implementation can handle them correctly.\nOne Price Range # This is the scenario we had earlier. After we have updated the code, we need to ensure old functionality keeps working correctly.\nFor brevity, I\u0026rsquo;ll show only most important parts of the tests. You can find full tests in the code repo.\nWhen buying ETH: function testBuyETHOnePriceRange() public { LiquidityRange[] memory liquidity = new LiquidityRange[](1); liquidity[0] = liquidityRange(4545, 5500, 1 ether, 5000 ether, 5000); ... (int256 expectedAmount0Delta, int256 expectedAmount1Delta) = ( -0.008396874645169943 ether, 42 ether ); assertSwapState( ExpectedStateAfterSwap({ ... sqrtPriceX96: 5604415652688968742392013927525, // 5003.8180249710795 tick: 85183, currentLiquidity: liquidity[0].amount }) ); } When buying USDC: function testBuyUSDCOnePriceRange() public { LiquidityRange[] memory liquidity = new LiquidityRange[](1); liquidity[0] = liquidityRange(4545, 5500, 1 ether, 5000 ether, 5000); ... (int256 expectedAmount0Delta, int256 expectedAmount1Delta) = ( 0.01337 ether, -66.807123823853842027 ether ); assertSwapState( ExpectedStateAfterSwap({ ... sqrtPriceX96: 5598737223630966236662554421688, // 4993.683362269102 tick: 85163, currentLiquidity: liquidity[0].amount }) ); } In both of these scenario we buy a small amount of EHT or USDC–it needs to be small enough for the price to not leave the only price range we created. Key values after swapping is done:\nsqrtPriceX96 is slightly above or below the initial price and stays within the price rage; currentLiquidity remains unchanged. Multiple Identical and Overlapping Price Ranges # When buying ETH:\nfunction testBuyETHTwoEqualPriceRanges() public { LiquidityRange memory range = liquidityRange( 4545, 5500, 1 ether, 5000 ether, 5000 ); LiquidityRange[] memory liquidity = new LiquidityRange[](2); liquidity[0] = range; liquidity[1] = range; ... (int256 expectedAmount0Delta, int256 expectedAmount1Delta) = ( -0.008398516982770993 ether, 42 ether ); assertSwapState( ExpectedStateAfterSwap({ ... sqrtPriceX96: 5603319704133145322707074461607, // 5001.861214026131 tick: 85179, currentLiquidity: liquidity[0].amount + liquidity[1].amount }) ); } When buying USDC:\nfunction testBuyUSDCTwoEqualPriceRanges() public { LiquidityRange memory range = liquidityRange( 4545, 5500, 1 ether, 5000 ether, 5000 ); LiquidityRange[] memory liquidity = new LiquidityRange[](2); liquidity[0] = range; liquidity[1] = range; ... (int256 expectedAmount0Delta, int256 expectedAmount1Delta) = ( 0.01337 ether, -66.827918929906650442 ether ); assertSwapState( ExpectedStateAfterSwap({ ... sqrtPriceX96: 5600479946976371527693873969480, // 4996.792621611429 tick: 85169, currentLiquidity: liquidity[0].amount + liquidity[1].amount }) ); } This scenario is similar to the previous one but this time we create two identical price ranges. Since those are fully overlapping price ranges, they in fact act as one price range with a higher amount of liquidity. Thus, the price changes slower than in the previous scenario. Also, we get slightly more tokens thanks to deeper liquidity.\nConsecutive Price Ranges # When buying ETH: function testBuyETHConsecutivePriceRanges() public { LiquidityRange[] memory liquidity = new LiquidityRange[](2); liquidity[0] = liquidityRange(4545, 5500, 1 ether, 5000 ether, 5000); liquidity[1] = liquidityRange(5500, 6250, 1 ether, 5000 ether, 5000); ... (int256 expectedAmount0Delta, int256 expectedAmount1Delta) = ( -1.820694594787485635 ether, 10000 ether ); assertSwapState( ExpectedStateAfterSwap({ ... sqrtPriceX96: 6190476002219365604851182401841, // 6105.045728033458 tick: 87173, currentLiquidity: liquidity[1].amount }) ); } When buying USDC: function testBuyUSDCConsecutivePriceRanges() public { LiquidityRange[] memory liquidity = new LiquidityRange[](2); liquidity[0] = liquidityRange(4545, 5500, 1 ether, 5000 ether, 5000); liquidity[1] = liquidityRange(4000, 4545, 1 ether, 5000 ether, 5000); ... (int256 expectedAmount0Delta, int256 expectedAmount1Delta) = ( 2 ether, -9103.264925902176327184 ether ); assertSwapState( ExpectedStateAfterSwap({ ... sqrtPriceX96: 5069962753257045266417033265661, // 4094.9666586581643 tick: 83179, currentLiquidity: liquidity[1].amount }) ); } In these scenarios, we make big swaps that cause price to move outside of a price range. As a result, the second price range gets activated and provides enough liquidity to satisfy the swap. In both scenarios, we can see that price lands outside of the current price range and that the price range gets deactivated (current liquidity equals to the liquidity of the second price range).\nPartially Overlapping Price Ranges # When buying ETH:\nfunction testBuyETHPartiallyOverlappingPriceRanges() public { LiquidityRange[] memory liquidity = new LiquidityRange[](2); liquidity[0] = liquidityRange(4545, 5500, 1 ether, 5000 ether, 5000); liquidity[1] = liquidityRange(5001, 6250, 1 ether, 5000 ether, 5000); ... (int256 expectedAmount0Delta, int256 expectedAmount1Delta) = ( -1.864220641170389178 ether, 10000 ether ); assertSwapState( ExpectedStateAfterSwap({ ... sqrtPriceX96: 6165345094827913637987008642386, // 6055.578153852725 tick: 87091, currentLiquidity: liquidity[1].amount }) ); } When buying USDC:\nfunction testBuyUSDCPartiallyOverlappingPriceRanges() public { LiquidityRange[] memory liquidity = new LiquidityRange[](2); liquidity[0] = liquidityRange(4545, 5500, 1 ether, 5000 ether, 5000); liquidity[1] = liquidityRange(4000, 4999, 1 ether, 5000 ether, 5000); ... (int256 expectedAmount0Delta, int256 expectedAmount1Delta) = ( 2 ether, -9321.077831210790476918 ether ); assertSwapState( ExpectedStateAfterSwap({ ... sqrtPriceX96: 5090915820491052794734777344590, // 4128.883835866256 tick: 83261, currentLiquidity: liquidity[1].amount }) ); } This is a variation of the previous scenario, but this time the price ranges are partially overlapping. In the areas where the price ranges overlap, there\u0026rsquo;s deeper liquidity, which makes the price movements slower. This is similar to providing more liquidity into the overlapping ranges.\nAlso notice that, in both swaps, we got more tokens than in the \u0026ldquo;Consecutive Price Ranges\u0026rdquo; scenarios–this is again due to deeper liquidity in the overlapping ranges.\n"},{"id":16,"href":"/docs/milestone_5/flash-loan-fees/","title":"Flash Loan Fees","section":"Milestone 5. Fees and Price Oracle","content":" Flash Loan Fees # In a previous chapter we implemented flash loans and made them free. However, Uniswap collects swap fees on flash loans, and we\u0026rsquo;re going to add this to our implementation: the amounts repaid by flash loan borrowers must include a fee.\nHere\u0026rsquo;s what the updated flash function looks like:\nfunction flash( uint256 amount0, uint256 amount1, bytes calldata data ) public { uint256 fee0 = Math.mulDivRoundingUp(amount0, fee, 1e6); uint256 fee1 = Math.mulDivRoundingUp(amount1, fee, 1e6); uint256 balance0Before = IERC20(token0).balanceOf(address(this)); uint256 balance1Before = IERC20(token1).balanceOf(address(this)); if (amount0 \u0026gt; 0) IERC20(token0).transfer(msg.sender, amount0); if (amount1 \u0026gt; 0) IERC20(token1).transfer(msg.sender, amount1); IUniswapV3FlashCallback(msg.sender).uniswapV3FlashCallback( fee0, fee1, data ); if (IERC20(token0).balanceOf(address(this)) \u0026lt; balance0Before + fee0) revert FlashLoanNotPaid(); if (IERC20(token1).balanceOf(address(this)) \u0026lt; balance1Before + fee1) revert FlashLoanNotPaid(); emit Flash(msg.sender, amount0, amount1); } What\u0026rsquo;s changed is that we\u0026rsquo;re now calculating fees on the amounts requested by caller and then expect pool balances to have grown by the fee amounts.\n"},{"id":17,"href":"/docs/milestone_6/nft-manager/","title":"NFT Manager","section":"Milestone 6: NFT positions","content":" \\[ \\] NFT Manager Contract # Obviously, we\u0026rsquo;re not going to add NFT-related functionality to the pool contract–we need a separate contract that will merge NFTs and liquidity positions. Recall that, while working on our implementation, we built the UniswapV3Manager contract to facilitate interaction with pool contracts (to make some calculations simpler and to enable multi-pool swaps). This contract was a good demonstration of how core Uniswap contracts can be extended. And we\u0026rsquo;re going to push this idea a little bit further.\nWe\u0026rsquo;ll need a manager contract that will implement the ERC721 standard and will manage liquidity positions. The contract will have the standard NFT functionality (minting, burning, transferring, balances and ownership tracking, etc.) and will allow to provide and remove liquidity to pools. The contract will need to be the actual owner of liquidity in pools because we don\u0026rsquo;t want to let users to add liquidity without minting a token and removing entire liquidity without burning one. We want every liquidity position to be linked to an NFT token, and we want to them to be synchronized.\nLet\u0026rsquo;s see what functions we\u0026rsquo;ll have in the new contract:\nsince it\u0026rsquo;ll be an NFT contract, it\u0026rsquo;ll have all the ERC721 functions, including tokenURI, which returns the URI of the image of an NFT token; mint and burn to mint and burn liquidity and NFT tokens at the same time; addLiquidity and removeLiquidity to add and remove liquidity in existing positions; collect, to collect tokens after removing liquidity. Alright, let\u0026rsquo;s get to code.\nThe Minimal Contract # Since we don\u0026rsquo;t want to implement the ERC721 standard from scratch, we\u0026rsquo;re going to use a library. We already have Solmate in the dependencies, so we\u0026rsquo;re going to use its ERC721 implementation.\nUsing the ERC721 implementation from OpenZeppelin is also an option, but I personally prefer the gas optimized contracts from Solmate.\nThis will be the bare minimum of the NFT manager contract:\ncontract UniswapV3NFTManager is ERC721 { address public immutable factory; constructor(address factoryAddress) ERC721(\u0026#34;UniswapV3 NFT Positions\u0026#34;, \u0026#34;UNIV3\u0026#34;) { factory = factoryAddress; } function tokenURI(uint256 tokenId) public view override returns (string memory) { return \u0026#34;\u0026#34;; } } tokenURI will return an empty string until we implement a metadata and SVG renderer. We\u0026rsquo;ve added the stub so that the Solidity compiler doesn\u0026rsquo;t fail while we\u0026rsquo;re working on the rest of the contract (the tokenURI function in the Solmate ERC721 contract is virtual, so we must implement it).\nMinting # Minting, as we discussed earlier, will involve two operations: adding liquidity to a pool and minting an NFT.\nTo keep the links between pool liquidity positions and NFTs, we\u0026rsquo;ll need a mapping and a structure:\nstruct TokenPosition { address pool; int24 lowerTick; int24 upperTick; } mapping(uint256 =\u0026gt; TokenPosition) public positions; To find a position we need:\na pool address; an owner address; the boundaries of a position (lower and upper ticks). Since the NFT manager contract will be the owner of all positions created via it, we don\u0026rsquo;t need to store position\u0026rsquo;s owner address and we can only store the rest data. The keys in the positions mapping are token IDs; the mapping links NFT IDs to the position data that\u0026rsquo;s required to find a liquidity position.\nLet\u0026rsquo;s implement minting:\nstruct MintParams { address recipient; address tokenA; address tokenB; uint24 fee; int24 lowerTick; int24 upperTick; uint256 amount0Desired; uint256 amount1Desired; uint256 amount0Min; uint256 amount1Min; } function mint(MintParams calldata params) public returns (uint256 tokenId) { ... } The minting parameters are identical to those of UniswapV3Manager, with an addition of recipient, which will allow to mint NFT to another address.\nIn the mint function, we first add liquidity to a pool:\nIUniswapV3Pool pool = getPool(params.tokenA, params.tokenB, params.fee); (uint128 liquidity, uint256 amount0, uint256 amount1) = _addLiquidity( AddLiquidityInternalParams({ pool: pool, lowerTick: params.lowerTick, upperTick: params.upperTick, amount0Desired: params.amount0Desired, amount1Desired: params.amount1Desired, amount0Min: params.amount0Min, amount1Min: params.amount1Min }) ); _addLiquidity is identical to the body of mint function in the UniswapV3Manager contract: it converts ticks to $sqrt(P)$, computes liquidity amount, and calls pool.mint().\nNext, we mint an NFT:\ntokenId = nextTokenId++; _mint(params.recipient, tokenId); totalSupply++; tokenId is set to the current nextTokenId and the latter is then incremented. The _mint function is provided by the ERC721 contract from Solmate. After minting a new token, we update totalSupply.\nFinally, we need to store the information about the new token and the new position:\nTokenPosition memory tokenPosition = TokenPosition({ pool: address(pool), lowerTick: params.lowerTick, upperTick: params.upperTick }); positions[tokenId] = tokenPosition; This will later help us find liquidity position by token ID.\nAdding Liquidity # Next, we\u0026rsquo;ll implement a function to add liquidity to an existing position, in the case when we want more liquidity to a position that already has some. In such cases, we don\u0026rsquo;t want to mint an NFT, but only to increase the amount of liquidity in an existing. position. For that, we\u0026rsquo;ll only need to provide a token ID and token amounts:\nfunction addLiquidity(AddLiquidityParams calldata params) public returns ( uint128 liquidity, uint256 amount0, uint256 amount1 ) { TokenPosition memory tokenPosition = positions[params.tokenId]; if (tokenPosition.pool == address(0x00)) revert WrongToken(); (liquidity, amount0, amount1) = _addLiquidity( AddLiquidityInternalParams({ pool: IUniswapV3Pool(tokenPosition.pool), lowerTick: tokenPosition.lowerTick, upperTick: tokenPosition.upperTick, amount0Desired: params.amount0Desired, amount1Desired: params.amount1Desired, amount0Min: params.amount0Min, amount1Min: params.amount1Min }) ); } This function ensures there\u0026rsquo;s an existing token and calls pool.mint() with parameters of an existing position.\nRemove Liquidity # Recall that in the UniswapV3Manager contract we didn\u0026rsquo;t implement a burn function because we wanted users to be owners of liquidity positions. Now, we want the NFT manager to be the owner. And we can have liquidity burning implemented in it:\nstruct RemoveLiquidityParams { uint256 tokenId; uint128 liquidity; } function removeLiquidity(RemoveLiquidityParams memory params) public isApprovedOrOwner(params.tokenId) returns (uint256 amount0, uint256 amount1) { TokenPosition memory tokenPosition = positions[params.tokenId]; if (tokenPosition.pool == address(0x00)) revert WrongToken(); IUniswapV3Pool pool = IUniswapV3Pool(tokenPosition.pool); (uint128 availableLiquidity, , , , ) = pool.positions( poolPositionKey(tokenPosition) ); if (params.liquidity \u0026gt; availableLiquidity) revert NotEnoughLiquidity(); (amount0, amount1) = pool.burn( tokenPosition.lowerTick, tokenPosition.upperTick, params.liquidity ); } We\u0026rsquo;re again checking that provided token ID is valid. And we also need to ensure that a position has enough liquidity to burn.\nCollecting Tokens # The NFT manager contract can also collect tokens after burning liquidity. Notice that collected tokens are send to msg.sender since the contract manages liquidity on behalf of the caller:\nstruct CollectParams { uint256 tokenId; uint128 amount0; uint128 amount1; } function collect(CollectParams memory params) public isApprovedOrOwner(params.tokenId) returns (uint128 amount0, uint128 amount1) { TokenPosition memory tokenPosition = positions[params.tokenId]; if (tokenPosition.pool == address(0x00)) revert WrongToken(); IUniswapV3Pool pool = IUniswapV3Pool(tokenPosition.pool); (amount0, amount1) = pool.collect( msg.sender, tokenPosition.lowerTick, tokenPosition.upperTick, params.amount0, params.amount1 ); } Burning # Finally, burning. Unlike the other functions of the contract, this function doesn\u0026rsquo;t do anything with a pool: it only burns an NFT. And to burn an NFT, the underlying position must be empty and tokens must be collected. So, if we want to burn an NFT, we need to:\ncall removeLiquidity an remove the entire position liquidity; call collect to collect the tokens after burning the position; call burn to burn the token. function burn(uint256 tokenId) public isApprovedOrOwner(tokenId) { TokenPosition memory tokenPosition = positions[tokenId]; if (tokenPosition.pool == address(0x00)) revert WrongToken(); IUniswapV3Pool pool = IUniswapV3Pool(tokenPosition.pool); (uint128 liquidity, , , uint128 tokensOwed0, uint128 tokensOwed1) = pool .positions(poolPositionKey(tokenPosition)); if (liquidity \u0026gt; 0 || tokensOwed0 \u0026gt; 0 || tokensOwed1 \u0026gt; 0) revert PositionNotCleared(); delete positions[tokenId]; _burn(tokenId); totalSupply--; } That\u0026rsquo;s it!\n"},{"id":18,"href":"/docs/milestone_2/math-in-solidity/","title":"Solidity中的数学运算","section":"Milestone 2. 第二笔交易","content":" \\[ \\] Solidity中的数学运算 # 由于Solidity不支持浮点数，在其中的运算会有些复杂。Solidity拥有整数(integer)和无符号整数(unsigned integer)类型，这并不足够让我们实现复杂的数学运算。\n另一个困难之处在于gas消耗：一个算法越复杂，它消耗的gas就越多。因此，如果我们需要比较高级的数学运算（例如exp, ln, sqrt），我们会希望它们尽可能节省gas。\n还有一个很大的问题是溢出。当进行uint256类型的乘法时，有溢出的风险：结果的数据可能会超出256位。\n所有的上述困难都让我们不得不使用那些实现了高级数学运算并进行了gas优化的第三方库。如果库里面没有我们需要的算法，我们就需要自己来实现，这将会是一个很困难的任务。\n重用数学库 # 在我们的Uniswap V3实现中，我们会使用两个第三方数学库：\nPRBMath，一个包含了复杂的定点数运算的库。我们会使用其中的mulDiv函数来处理乘除法过程中可能的溢出 TickMath，来自原始的Uniswap V3仓库。这个合约实现了两个函数，getSqrtRatioAtTick 和 getTickAtSqrtRatio，功能是在tick和$\\sqrt{P}$之间相互转换。 我们先关注第二个库。在我们的合约中，我们需要将tick转换成对应的$\\sqrt{P}$，或者反过来。对应的公式为：\n$$\\sqrt{P(i)} = \\sqrt{1.0001^i} = 1.0001^{\\frac{i}{2}}$$\n$$i = log_{\\sqrt{1.0001}}\\sqrt{P(i)}$$\n这些是非常复杂的数学运算（至少在Solidity中是这样）并且它们需要很高的精度，因为我们不希望取整的问题干扰我们的价格计算。为了能实现更高的精度和gas优化，我们需要特定的实现。\n如果你看一下getSqrtRatioAtTick和getTickAtSqrtRatio的代码，你会发现它们非常复杂：其中有大量的magic number（像0xfffcb933bd6fad37aa2d162d1a594001这样），乘法以及位运算。在当前阶段，我们不会试图分析这些代码或者尝试重新实现它们，因为这会是另一个不同的且复杂的主题。我们在这里仅仅使用它们。在后续的章节中，我们可能会深入探讨这部分代码。\n"},{"id":19,"href":"/docs/milestone_4/path/","title":"Swap Path","section":"Milestone 4. Multi-pool Swaps","content":" Swap Path # Let\u0026rsquo;s imagine that we have only these pools: WETH/USDC, USDC/USDT, WBTC/USDT. If we want to swap WETH for WBTC, we\u0026rsquo;ll need to make multiple swaps (WETH→USDC→USDT→WBTC) since there\u0026rsquo;s no WETH/WBTC pool. We can do this manually or we can improve our contracts to handle such chained, or multi-pool, swaps. Of course, we\u0026rsquo;ll do the latter!\nWhen doing multi-pool swaps, we\u0026rsquo;re sending output of a previous swap to the input of the next one. For example:\nin WETH/USDC pool, we\u0026rsquo;re selling WETH and buying USDC; in USDC/USDT pool, we\u0026rsquo;re selling USDC from the previous swap and buying USDT; in WBTC/USDT pool, we\u0026rsquo;re selling USDT from the previous pool and buying WBTC. We can turn this series into a path:\nWETH/USDC,USDC/USDT,WBTC/USDT And iterate over such path in our contracts to perform multiple swaps in one transaction. However, recall from the previous chapter that we don\u0026rsquo;t need to know pool addresses and, instead, we can derive them from pool parameters. Thus, the above swap can be turned into a series of tokens:\nWETH, USDC, USDT, WBTC And recall that tick spacing is another parameter (besides tokens) that identifies a pool. Thus, the above path becomes:\nWETH, 60, USDC, 10, USDT, 60, WBTC Where 60 and 10 are tick spacings. We\u0026rsquo;re using 60 in volatile pairs (e.g. ETH/USDC, WBTC/USDT) and 10 in stablecoin pairs (USDC/USDT).\nNow, having such path, we can iterate over it to build pool parameters for each of the pool:\nWETH, 60, USDC; USDC, 10, USDT; USDT, 60, WBTC. Knowing these parameters, we can derive pool addresses using PoolAddress.computeAddress, which we implemented in the previous chapter.\nWe also can use this concept when doing swaps within one pool: the path would simple contain the parameters of one pool. And, thus, we can use swap paths in all swaps, universally.\nLet\u0026rsquo;s build a library to work with swap paths.\nPath Library # In code, a swap path is a sequence of bytes. In Solidity, a path can be built like that:\nbytes.concat( bytes20(address(weth)), bytes3(uint24(60)), bytes20(address(usdc)), bytes3(uint24(10)), bytes20(address(usdt)), bytes3(uint24(60)), bytes20(address(wbtc)) ); And it looks like that:\n0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 # weth address 00003c # 60 A0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48 # usdc address 00000a # 10 dAC17F958D2ee523a2206206994597C13D831ec7 # usdt address 00003c # 60 2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599 # wbtc address These are the functions that we\u0026rsquo;ll need to implement:\ncalculating the number of pools in a path; figuring out if a path has multiple tokens; extracting first pool parameters from a path; proceeding to the next pair in a path; and decoding first pool parameters. Calculating the Number of Pools in a Path # Let\u0026rsquo;s begin with calculating the number of pools in a path:\n// src/lib/Path.sol library Path { /// @dev The length the bytes encoded address uint256 private constant ADDR_SIZE = 20; /// @dev The length the bytes encoded tick spacing uint256 private constant TICKSPACING_SIZE = 3; /// @dev The offset of a single token address + tick spacing uint256 private constant NEXT_OFFSET = ADDR_SIZE + TICKSPACING_SIZE; /// @dev The offset of an encoded pool key (tokenIn + tick spacing + tokenOut) uint256 private constant POP_OFFSET = NEXT_OFFSET + ADDR_SIZE; /// @dev The minimum length of a path that contains 2 or more pools; uint256 private constant MULTIPLE_POOLS_MIN_LENGTH = POP_OFFSET + NEXT_OFFSET; ... We first define a few constants:\nADDR_SIZE is the size of an address, 20 bytes; TICKSPACING_SIZE is the size of a tick spacing, 3 bytes (uint24); NEXT_OFFSET is the offset of a next token address–to get it, we skip an address and a tick spacing; POP_OFFSET is the offset of a pool key (token address + tick spacing + token address); MULTIPLE_POOLS_MIN_LENGTH is the length of a path that contains 2 or more pools (one set of pool parameters + tick spacing + token address). To count the number of pools in a path, we subtract the size of an address (first or last token in a path) and divide the remaining part by NEXT_OFFSET (address + tick spacing):\nfunction numPools(bytes memory path) internal pure returns (uint256) { return (path.length - ADDR_SIZE) / NEXT_OFFSET; } Figuring Out If a Path Has Multiple Tokens # To check if there are multiple pools in a path, we need to compare the length of a path with MULTIPLE_POOLS_MIN_LENGTH:\nfunction hasMultiplePools(bytes memory path) internal pure returns (bool) { return path.length \u0026gt;= MULTIPLE_POOLS_MIN_LENGTH; } Extracting First Pool Parameters From a Path # To implement the other functions, we\u0026rsquo;ll need a helper library because Solidity doesn\u0026rsquo;t have native bytes manipulation functions. Specifically, we\u0026rsquo;ll need a function to extract a sub-array from an array of bytes, and a couple of functions to convert bytes to address and uint24.\nLuckily, there\u0026rsquo;s a great open-source library called solidity-bytes-utils. To use the library, we need to extend the bytes type in the Path library:\nlibrary Path { using BytesLib for bytes; ... } We can implement getFirstPool now:\nfunction getFirstPool(bytes memory path) internal pure returns (bytes memory) { return path.slice(0, POP_OFFSET); } The function simply returns the first \u0026ldquo;token address + tick spacing + token address\u0026rdquo; segment encoded as bytes.\nProceeding to a Next Pair in a Path # We\u0026rsquo;ll use the next function when iterating over a path and throwing away processed pools. Notice that we\u0026rsquo;re removing \u0026ldquo;token address + tick spacing\u0026rdquo;, not full pool parameters, because we need the other token address to calculate next pool address.\nfunction skipToken(bytes memory path) internal pure returns (bytes memory) { return path.slice(NEXT_OFFSET, path.length - NEXT_OFFSET); } Decoding First Pool Parameters # And, finally, we need to decode the parameters of the first pool in a path:\nfunction decodeFirstPool(bytes memory path) internal pure returns ( address tokenIn, address tokenOut, uint24 tickSpacing ) { tokenIn = path.toAddress(0); tickSpacing = path.toUint24(ADDR_SIZE); tokenOut = path.toAddress(NEXT_OFFSET); } Unfortunately, BytesLib doesn\u0026rsquo;t implement toUint24 function but we can implement it ourselves! BytesLib has multiple toUintXX functions, so we can take one of them and convert to a uint24 one:\nlibrary BytesLibExt { function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) { require(_bytes.length \u0026gt;= _start + 3, \u0026#34;toUint24_outOfBounds\u0026#34;); uint24 tempUint; assembly { tempUint := mload(add(add(_bytes, 0x3), _start)) } return tempUint; } } We\u0026rsquo;re doing this in a new library contract, which we can then use in our Path library alongside BytesLib:\nlibrary Path { using BytesLib for bytes; using BytesLibExt for bytes; ... } "},{"id":20,"href":"/docs/introduction/uniswap-v3/","title":"Uniswap V3","section":"Milestone 0. 简介","content":" \\[ \\] Uniswap V3简介 # 本章节主要讲述了Uniswap V3白皮书中的内容。同样，假设你没有理解本章的所有概念也没有关系，我们在后面章节直接看代码可能会更清晰。\n为了更好地理解Uniswap V3的创新之处在哪里，我们首先来看Uniswap V2的缺点有哪些。\nUniswap V2使用AMM机制实现了一个通用的交易市场。然而，并不是所有的交易对都是平等的，交易对可以根据价格的波动性分为以下两类\n价格波动性为中等或高的代币对。这一类包含绝大多数的代币，因为绝大多数代币并没有锚定(pegged to)到某些东西，因此其价格随着市场波动而波动。 价格波动性低的代币对。这一类包含了有锚定的代币，主要为稳定币：USDT/USDC，USDC/DAI，USDT/DAI等等。也包括ETH/stETH，ETH/rETH（一些wrapped ETH）等类型。 这些类对于我们称作“流动性池配置”的概念有不同的要求。最主要的区别在于，锚定代币对需要非常高的流动性来降低大额交易对其的影响。USDC与USDT的价格必须保持在1附近，无论我要买卖多大数目的代币。由于Uniswap V2的通用AMM算法对于稳定币交易并没有很好的适配，其他的AMM（主要是Curve）则在稳定币交易中更加流行。\n导致这个问题出现的原因在于，Uniswap V2池子的流动性是分布在无穷区域上的-即池子允许在任何价格的交易发生，从0到正无穷：\n这听起来不是一个坏事，但事实上它导致了资本利用效率的不足。一个资产的历史价格通常是在某个区间内的，不管这个区间是大还是小。比如，ETH的历史价格大致在$0.75 到 $4,800 这个区间（数据来源CoinMarketCap）。在今天（2022年6月，1个ETH的现货价格是$1800，没有人会愿意用$5000购买一个ETH，所以在这个点提供流动性是毫无用处的。因此，在远离当前价格区间的、永远不会达到的某个点上提供流动性是毫无意义的\n当然，我们都相信ETH的价格某天会达到$10000 （译者注：仅代表原作者观点）\n集中流动性 # Uniswap V3引入了 集中流动性(concentrated liquidity) 的概念：LP可以选择他们希望在哪个价格区间提供流动性。这个机制通过将更多的流动性提供在一个相对狭窄的价格区间，从而大大提高了资本利用效率；这也使Uniswap的使用场景更加多样化：它现在可以对于不同价格波动性的池子进行不同的配置。这就是V3相对于V2的提升点。\n简单地来说，一个Uniswap V3的交易对是许多个Uniswap V2的交易对。V2与V3的区别是，在V3中，一个交易对有许多的价格区间，而每个价格区间内都有有限数量的资产。从零到正无穷的整个价格区间被划分成了许多个小的价格区间，每一个区间中都有一定数量的流动性。而更关键的点在于，在每个小的价格区间中，工作机制与Uniswap V2一样。这也是为什么说一个Uniswap V3的池子就是许多个V2的池子。\n下面，我们来对这种机制进行可视化。我们并不是重新选择一个有限的曲线，而是我们把它在价格$a$ 与价格$b$ 之间的部分截取出来，认为它们是曲线的边界。更进一步，我们把曲线进行平移使得边界点落在坐标轴上，于是得到了下图：\n它看起来或许有点孤单， 因此Uniswap V3有许多的价格区间——这样它们就不会感到孤单了 🙂\n正如我们在前一章中讲到的那样，交易token使得价格在曲线上移动，而价格区间限制了价格点的移动。当价格移动到曲线的一端时，我们说这个池子被耗尽了：其中一种代币的资产变成了0，无法再购买这种代币（当然，仅仅指在这个价格区间内）\n假设起始价格在上面途中曲线的中间点。为了到达点$a$，我们需要购买池子里所有的$y$来使得池子里的$x$最大化；为了到达点$b$，我们需要买光池子里的$x$从而使$y$最大化。在这两个点，池子里都只剩一种token。\n一个有趣的点：根据这个原理，可以利用V3的价格区间来挂限价单\n如果当前价格区间池子被耗尽将会发生什么？价格点会滑动到下一个价格区间。如果下一个价格区间不存在，这笔交易就会以部分成交而结束——我们将在本书后面的部分看到其如何实现。\n下面一图展示了USDC/ETH池子的流动性分布:\n可以看到，大量流动性集中在现在价格的附近，而较远的价格区间中的流动性较少——这是因为LP更希望提高它们的资产利用效率。当然，整个区间也不是无穷的，在图片右侧也显示了其上界。\nUniswap V3的数学原理 # 在数学原理上，V3是基于V2的：它们使用了相同的底层公式，但实际上V3使用的是可以被称作增强版。\n为了处理价格区间之间的转换，简化流动性管理，以及避免取整出现问题，V3使用了下面这些新的标识：\n$$L = \\sqrt{xy}$$\n$$\\sqrt{P} = \\sqrt{\\frac{y}{x}}$$\n$L$ 被称作 流动性数量。池子中的流动性是两种token资产数量的组合。我们知道按照公式，两种代币数量乘积为$k$，因此我们可以用 $\\sqrt{xy}$ 来衡量池子流动性。$L$ 实际上是 $x$ 和 $y$ 的几何平均数。\n$y/x$ 是token 0相对于token 1的价格. 由于池子里两种代币的价格互为倒数，我们在计算中仅使用其中一个(Uniswap V3使用的是$y/x$)。Token 1相对于token 0的价格即为$\\frac{1}{y/x}=\\frac{x}{y}$。类似地， $\\frac{1}{\\sqrt{P}} = \\frac{1}{\\sqrt{y/x}} = \\sqrt{\\frac{x}{y}}$.\n我们使用 $\\sqrt{P}$ 而不是 $P$ 有以下两个原因：\n平方根计算并不精确并且会引入取整的问题。因此，更简单的方法是我们干脆就在合约中存平方根的结果，而不是在合约中计算它。（合约中并不存储$x$和$y$）\n$\\sqrt{P}$ 与 $L$ 之间有一个有趣的关系：$L$ 也表示了output amount的变化与$\\sqrt{P}$的变化之间的关系：\n$$L = \\frac{\\Delta y}{\\Delta\\sqrt{P}}$$\n证明: $$L = \\frac{\\Delta y}{\\Delta\\sqrt{P}}$$\n$$\\sqrt{xy} = \\frac{y_1 - y_0}{\\sqrt{P_1} - \\sqrt{P_0}}$$\n$$\\sqrt{xy} (\\sqrt{P_1} - \\sqrt{P_0}) = y_1 - y_0$$\n$$\\sqrt{xy} (\\sqrt{\\frac{y_1}{x_1}} - \\sqrt{\\frac{y_0}{x_0}}) = y_1 - y_0$$\n$$\\sqrt{y_1^2} - \\sqrt{y_0^2} = y_1 - y_0$$\n$$y_1 - y_0 = y_1 - y_0$$\n（译者注：第四步到第五步，$\\sqrt{xy} = \\sqrt{x_0y_0} = \\sqrt{x_1y_1}$ ）\n价格 # 同样，我们并不需要计算准确的价格——我们可以直接计算获得的token数量。并且，由于我们在合约中并不存储$x$和$y$，我们将仅通过 $L$ 和 $\\sqrt{P}$ 进行计算。\n根据上文中的公式，我们能得到 $\\Delta y$：\n$$\\Delta y = \\Delta \\sqrt{P} L$$\n见上述证明中的第三步。\n正如上面所说，双方的价格互为倒数。因此，$\\Delta x$ 的公式为：\n$$\\Delta x = \\Delta \\frac{1}{\\sqrt{P}} L$$\n$L$ 和 $\\sqrt{P}$ 让我们不再需要存储和更新池子资产数量。并且，我们也并不需要每次都重新计算 $\\sqrt{P}$ 因为我们从上述公式可以得到 $\\Delta \\sqrt{P}$。\nTicks # 正如我们前面说到的，V2中的无穷价格区间在V3中被分成了更小的价格区间，每个区间都由上下界断点进行限制。为了进行这些边界的协调，V3引入和 ticks。\n在V3，整个价格区间由离散的、均匀分布的ticks进行标定。每个tick有一个index和对应的价格：\n$$p(i) = 1.0001^i$$\n$p(i)$ 即为 tick $i$的价格. 使用1.0001的幂次作为标定有一个很好的性质：两个相邻tick之间的差距为0.01%或者一个基点。\n基点 (1%的百分之一，或者0.01%，或者0.0001)是在金融中用来衡量百分比的一个单位。你可能在央行宣布对于利率的调整中听过基点这个名词。\n正如我们之前讨论的，Uniswap V3存储的是$\\sqrt{P}$而不是$P$。所以这个公式实际上是：\n$$\\sqrt{p(i)} = \\sqrt{1.0001}^i = 1.0001 ^{\\frac{i}{2}}$$\n我们得到的值大概是这样：$\\sqrt{p(0)} = 1$, $\\sqrt{p(1)} = \\sqrt{1.0001} \\approx 1.00005$, $\\sqrt{p(-1)} \\approx 0.99995$.\nTicks可以为正也可以为负，并且显然它不是无穷的。V3把$\\sqrt{P}$ 存储为一个Q64.96类型的定点数，使用64位作为整数部分，使用96位作为小数部分。因此，价格的取值范围是$[2^{-128}, 2^{128}]$，ticks的取值范围是：\n$$[log_{1.0001}2^{-128}, log_{1.0001}{2^{128}}] = [-887272, 887272]$$\n如果希望对于Uniswap V3的数学原理有更深的理解，作者推荐这篇技术文章，作者为Atis Elsts\n"},{"id":21,"href":"/docs/milestone_1/providing-liquidity/","title":"提供流动性","section":"Milestone 1. 第一笔交易","content":" \\[ \\] 提供流动性 # 有了这些理论，我们现在可以开始写代码了！\n新建一个文件夹，cd进去运行forge init --vscode-来初始化一个Forge项目。加上--vscode会让Forge配置vscode的Solidity插件。 删除其中的合约和测试文件：\nscript/Contract.s.sol src/Contract.sol test/Contract.t.sol 现在，我们可以开始写我们的第一个合约了~\n池子合约 # 正如我们在简介中提到的那样，Uniswap部署了多个池子合约，每一个都是负责一对token的交易。Uniswap的所有合约被分为以下两类：\n核心合约(core contracts) 外部合约(periphery contracts) 正如其名，核心合约实现了核心的逻辑。这些合约是最小的，对用户不友好的，底层的合约。这些合约都只做一件事并且保证这件事尽可能地安全。在Uniswap V3中，核心合约包含以下两个：\n池子(Pool)合约，实现了去中心化交易的核心逻辑 工厂(Factory)合约，作为池子合约的注册入口，使得部署池子合约更加简单。 我们将会从池子合约开始，这部分实现了Uniswap 99%的核心功能。\n创建 src/UniswapV3Pool.sol:\npragma solidity ^0.8.14; contract UniswapV3Pool {} 让我们想一下这个合约需要存储哪些数据：\n由于每个合约都是一对token的交易市场，我们需要存储两个token的地址。这些地址是静态的，仅设置一次并且保持不变的。(因此，这些变量需要被设置为immutable) 每个池子合约包含了一系列的流动性位置，我们需要用一个mapping来存储这些信息，key代表不同位置，value是包含这些位置相关的信息。 每个池子合约都包含一些tick的信息，需要一个mapping来存储tick的编号与对应的信息 tick的范围是固定的，这些范围在合约中存为常数 需要存储池子流动性的数量$L$ 最后，我们还需要跟踪现在的价格和对应的tock。我们将会把他们存储在一个slot中来节省gas费：因为这些变量会被频繁读写，所以我们需要充分考虑Solidity变量在存储中的分布特点 总之，合约大概存储了以下这些信息：\n// src/lib/Tick.sol library Tick { struct Info { bool initialized; uint128 liquidity; } ... } // src/lib/Position.sol library Position { struct Info { uint128 liquidity; } ... } // src/UniswapV3Pool.sol contract UniswapV3Pool { using Tick for mapping(int24 =\u0026gt; Tick.Info); using Position for mapping(bytes32 =\u0026gt; Position.Info); using Position for Position.Info; int24 internal constant MIN_TICK = -887272; int24 internal constant MAX_TICK = -MIN_TICK; // Pool tokens, immutable address public immutable token0; address public immutable token1; // Packing variables that are read together struct Slot0 { // Current sqrt(P) uint160 sqrtPriceX96; // Current tick int24 tick; } Slot0 public slot0; // Amount of liquidity, L. uint128 public liquidity; // Ticks info mapping(int24 =\u0026gt; Tick.Info) public ticks; // Positions info mapping(bytes32 =\u0026gt; Position.Info) public positions; ... Uniswap V3有很多辅助的合约，Tick和Position就是其中两个。using A for B是Solidity的一个语言特性，能够让你用库合约A中的函数来扩展类型B，简化了对于复杂数据结构的管理方式。\n简洁起见，我会省略掉关于Solidity的语法和特性的一些细节上的解释。Solidity有非常清楚的文档，当遇到相关问题是可以参考这里。\n接下来，我们在constructor中初始化其中一些变量：\nconstructor( address token0_, address token1_, uint160 sqrtPriceX96, int24 tick ) { token0 = token0_; token1 = token1_; slot0 = Slot0({sqrtPriceX96: sqrtPriceX96, tick: tick}); } } 在构造函数中，我们初始化了不可变的token地址、现在的价格和对应的tick。我们暂时还不需要提供流动性。\n从这里开始，到本节的最后我们会使用我们预先计算好的数值，完成我们的第一笔交易\n铸造(Minting) # 在Uniswap V2中，提供流动性被称作minting(铸造)，因为Uniswap V2的池子给予LP-token作为提供流动性的交换。V3没有这种行为，但是仍然保留了同样的名字，我们在这里也同样使用这个名字：\nfunction mint( address owner, int24 lowerTick, int24 upperTick, uint128 amount ) external returns (uint256 amount0, uint256 amount1) { ... 我们的mint函数会包含以下参数：\n所有者的地址，来识别是谁提供的流动性 上界和下界的tick，来设置价格区间的边界 希望提供的流动性的数量 注意到在这里，用户指定了$L$，而不是具体的token数量。这显然不是特别方便，但是要记得池子合约是核心合约的一部分——它并不需要用户友好，因为它仅实现了最小的核心逻辑。在后面章节中，我们会实现一些辅助合约，来帮助用户在调用Pool.mint之前将token数目转换成$L$。\n我们简单描述一下铸造函数如何工作：\n用户指定价格区间和流动性的数量 合约更新ticks和positions的mapping。 合约计算出用户需要提供的token数量（在本节我们用事先计算好的值） 合约从用户处获得token，并且验证数量是否正确 首先来检查ticks：\nif ( lowerTick \u0026gt;= upperTick || lowerTick \u0026lt; MIN_TICK || upperTick \u0026gt; MAX_TICK ) revert InvalidTickRange(); 并且确保流动性的数量不为零：\nif (amount == 0) revert ZeroLiquidity(); 接下来，增加tick和position的信息：\nticks.update(lowerTick, amount); ticks.update(upperTick, amount); Position.Info storage position = positions.get( owner, lowerTick, upperTick ); position.update(amount); ticks.update函数如下所示：\n// src/lib/Tick.sol function update( mapping(int24 =\u0026gt; Tick.Info) storage self, int24 tick, uint128 liquidityDelta ) internal { Tick.Info storage tickInfo = self[tick]; uint128 liquidityBefore = tickInfo.liquidity; uint128 liquidityAfter = liquidityBefore + liquidityDelta; if (liquidityBefore == 0) { tickInfo.initialized = true; } tickInfo.liquidity = liquidityAfter; } 它初始化一个流动性为0的tick，并且在上面添加新的流动性。正如上面所示，我们会在下界tick和上界tick均调用此函数，流动性在两边都有添加。\nposition.update函数如下所示:\n// src/libs/Position.sol function update(Info storage self, uint128 liquidityDelta) internal { uint128 liquidityBefore = self.liquidity; uint128 liquidityAfter = liquidityBefore + liquidityDelta; self.liquidity = liquidityAfter; } 与tick的函数类似，它也在特定的位置上添加流动性。其中的get函数如下：\n// src/libs/Position.sol ... function get( mapping(bytes32 =\u0026gt; Info) storage self, address owner, int24 lowerTick, int24 upperTick ) internal view returns (Position.Info storage position) { position = self[ keccak256(abi.encodePacked(owner, lowerTick, upperTick)) ]; } ... 每个位置都由三个变量所确定：LP地址，下界tick编号，上界tick编号。我们将这三个变量哈希来减少数据存储开销：哈希结果只有32字节，而三个变量分别存储需要96字节。\n如果我们使用三个变量来标定，我们就需要三个mapping。每个变量都分别需要32字节的开销，因为solidity会把变量存储在32字节的slot中（此处没有packing）\n让我们继续完成我们的minting函数。接下来我们需要计算用户需要质押token的数量，幸运的是，我们在上一章中已经用公式计算出了对应的数值。在这里我们会在代码中硬编码这些数据：\namount0 = 0.998976618347425280 ether; amount1 = 5000 ether; 在后面的章节中，我们会把这里替换成真正的计算\n现在，我们可以从用户处获得token了。这部分是通过callback来实现的：\nuint256 balance0Before; uint256 balance1Before; if (amount0 \u0026gt; 0) balance0Before = balance0(); if (amount1 \u0026gt; 0) balance1Before = balance1(); IUniswapV3MintCallback(msg.sender).uniswapV3MintCallback( amount0, amount1 ); if (amount0 \u0026gt; 0 \u0026amp;\u0026amp; balance0Before + amount0 \u0026gt; balance0()) revert InsufficientInputAmount(); if (amount1 \u0026gt; 0 \u0026amp;\u0026amp; balance1Before + amount1 \u0026gt; balance1()) revert InsufficientInputAmount(); 首先，我们记录下现在的token余额。接下来我们调用caller的uniswapV3MintCallback方法。预期调用者为合约地址，因为普通用户地址无法实现callback函数。使用callback函数看起来很不用户友好，但是这能够让合约计算token的数量——这非常关键，因为我们无法信任用户。\n调用者需要实现uniswapV3MintCallback来将token转给池子合约。调用callback函数后，我们会检查池子合约的对应余额是否发生变化，并且增量应该大于amount0和amount1：这意味着调用者已经把钱转到了池子。\n最后，发出一个Mint事件：\nemit Mint(msg.sender, owner, lowerTick, upperTick, amount, amount0, amount1); 事件(Event)是合约数据再以太坊中标定的方式，后续可以据此进行搜索。通常来说，比较好的编程习惯是在合约的状态变量发生改变时发出一个事件，这能够让前端知道这件事情发生了。事件也包含了很多有用的信息，比如：调用者的地址，对应的流动性位置，上界和下界的tick，新的流动性数量，两种token的数量。这些信息会作为日志（log）存储，任何人都可以通过收集这样的日志来重放合约中的状态变动，而不需要去遍历分析所有的区块和交易。\n现在我们完成了！（出乎意料的简单）。接下来到了测试部分。\n测试 # 现在，我们还不知道我们的合约是否正确。在部署我们的合约之前，我们需要写一系列的测试来保证合约功能正常。正如之前所说，Forge是一个绝妙的测试框架，能够让我们的测试十分简单。\n创建一个新的测试文件：\n// test/UniswapV3Pool.t.sol // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.14; import \u0026#34;forge-std/Test.sol\u0026#34;; contract UniswapV3PoolTest is Test { function setUp() public {} function testExample() public { assertTrue(true); } } 我们来运行一下：\n$ forge test Running 1 test for test/UniswapV3Pool.t.sol:UniswapV3PoolTest [PASS] testExample() (gas: 279) Test result: ok. 1 passed; 0 failed; finished in 5.07ms 测试通过了！这是显然的，因为目前我们只测试了true等于true。\n测试合约都继承自forge-std/Test.sol。这个合约实现了一些列的测试功能，我们后续会对这些功能越来越熟悉。如果你现在就一定想知道，可以打开lib/forge-std/src/Test.sol简单读一下。\n测试合约遵循以下规则：\nsetUp函数用来准备测试样例。在每个测试样例中，我们都希望有一个配置好的环境，比如合约的部署、token的铸造、池子的初始化——这些都将在setUp中完成 每个测试样例以test开头，例如testMint()。这能够让Forge区分出测试样例和其他的辅助函数（这里我们也可以写任何我们需要的辅助函数）。 现在我们来真正测试minting\n测试token # 为了测试minting功能，我们需要token。这对我们来说不是个问题，因为我们在测试中能够随意部署任何合约！更进一步，Forge能够用依赖的方式安装其他开源合约。在这里，我们需要包含铸造功能的ERC20合约。我们会使用Solmate的ERC20合约（Solmate包含了一系列gas优化的合约），并且创建一个继承自Solmate合约的ERC20合约，开放mint接口。\n首先安装solmate:\n$ forge install rari-capital/solmate 之后，在test文件夹中创建ERC20Mintable.sol合约（因为此合约仅用于测试）：\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.14; import \u0026#34;solmate/tokens/ERC20.sol\u0026#34;; contract ERC20Mintable is ERC20 { constructor( string memory _name, string memory _symbol, uint8 _decimals ) ERC20(_name, _symbol, _decimals) {} function mint(address to, uint256 amount) public { _mint(to, amount); } } 我们的ERC20Mintable继承了solmate/tokens/ERC20.sol的所有功能，并且额外实现了一个public的mint方法，能够让我们铸造任意数量的token。\n测试 Minting # 现在，我们可以进行minting的测试了。\n首先，部署所有需要用到的合约：\n// test/UniswapV3Pool.t.sol ... import \u0026#34;./ERC20Mintable.sol\u0026#34;; import \u0026#34;../src/UniswapV3Pool.sol\u0026#34;; contract UniswapV3PoolTest is Test { ERC20Mintable token0; ERC20Mintable token1; UniswapV3Pool pool; function setUp() public { token0 = new ERC20Mintable(\u0026#34;Ether\u0026#34;, \u0026#34;ETH\u0026#34;, 18); token1 = new ERC20Mintable(\u0026#34;USDC\u0026#34;, \u0026#34;USDC\u0026#34;, 18); } ... 在setUp函数中，我们部署了token合约，但是不需要部署池子合约。这是因为所有的测试样例都会使用同样的token，但是可能会使用不同的池子。\n为了让池子的设置更加简单清晰，我们将在另外一个函数中完成这部分工作，setupTestCase。它接受一系列的测试样例参数，进行池子的设置。在我们的第一个测试样例中，我们会测试成功的流动性铸造，其参数如下所示：\nfunction testMintSuccess() public { TestCaseParams memory params = TestCaseParams({ wethBalance: 1 ether, usdcBalance: 5000 ether, currentTick: 85176, lowerTick: 84222, upperTick: 86129, liquidity: 1517882343751509868544, currentSqrtP: 5602277097478614198912276234240, shouldTransferInCallback: true, mintLiqudity: true }); 我们计划向池子中质押1ETH和5000USDC 当前的tick为81576，上下界的tick分别为84222和86129（在上一章中计算的结果） 我们将会指定预先计算好的流动性$L$和现价$\\sqrt{P}$ 在本样例中，我们会铸造流动性（mintLiquidity参数为true），也会在池子合约调用callback时转给它token（shouldTransferInCallback参数为true）。我们并不会在每个测试中都这样做，因此我们有这些参数的设置。 接下来，我们用上述参数调用setUpTestCase：\nfunction setupTestCase(TestCaseParams memory params) internal returns (uint256 poolBalance0, uint256 poolBalance1) { token0.mint(address(this), params.wethBalance); token1.mint(address(this), params.usdcBalance); pool = new UniswapV3Pool( address(token0), address(token1), params.currentSqrtP, params.currentTick ); if (params.mintLiqudity) { (poolBalance0, poolBalance1) = pool.mint( address(this), params.lowerTick, params.upperTick, params.liquidity ); } shouldTransferInCallback = params.shouldTransferInCallback; } 在这个函数中，我们铸造了token，部署了池子合约。由于mintLiquidity参数设置为true，我们会在池子中铸造初始流动性。最后，我们设置shouldTransferInCallback变量，使得在callback中能读到此参数：\nfunction uniswapV3MintCallback(uint256 amount0, uint256 amount1) public { if (shouldTransferInCallback) { token0.transfer(msg.sender, amount0); token1.transfer(msg.sender, amount1); } } 在这个测试中，是测试合约提供流动性并且调用池子的mint函数，与用户（EOA）无关。测试合约会作为用户，因此它实现了callback函数。测试合约仅仅是个合约而已，你可以用任何你习惯的方式来编写它。\n在testMineSuccess中，我们希望池子合约能够：\n从用户处获取正确数量的token 创建一个关键字和流动性正确的position 初始化我们声明的上下界tick 有正确的$\\sqrt{P}$和$L$。 我们来实现这些。\n铸造在setupTestCase中实现，我们不需要再写一遍了。这个函数也反悔了我们需要的token数量，我们对其进行检查：\n(uint256 poolBalance0, uint256 poolBalance1) = setupTestCase(params); uint256 expectedAmount0 = 0.998976618347425280 ether; uint256 expectedAmount1 = 5000 ether; assertEq( poolBalance0, expectedAmount0, \u0026#34;incorrect token0 deposited amount\u0026#34; ); assertEq( poolBalance1, expectedAmount1, \u0026#34;incorrect token1 deposited amount\u0026#34; ); 我们希望池子里的token数量与我们预先设计好的一致。同样也直接对池子进行检查：\nassertEq(token0.balanceOf(address(pool)), expectedAmount0); assertEq(token1.balanceOf(address(pool)), expectedAmount1); 接下来，我们需要检查池子创建的position。回忆一下，在positions这个mapping中，我们的键值是一个哈希。我们手动计算这个键值并且获得合约中对应的position：\nbytes32 positionKey = keccak256( abi.encodePacked(address(this), params.lowerTick, params.upperTick) ); uint128 posLiquidity = pool.positions(positionKey); assertEq(posLiquidity, params.liquidity); 由于Position.Info是一个struct，它会在返回时被解构，每个field分别赋值给一个单独的变量。\n接下来检查ticks：\n(bool tickInitialized, uint128 tickLiquidity) = pool.ticks( params.lowerTick ); assertTrue(tickInitialized); assertEq(tickLiquidity, params.liquidity); (tickInitialized, tickLiquidity) = pool.ticks(params.upperTick); assertTrue(tickInitialized); assertEq(tickLiquidity, params.liquidity); 最后，检查$\\sqrt{P}$和$L$:\n(uint160 sqrtPriceX96, int24 tick) = pool.slot0(); assertEq( sqrtPriceX96, 5602277097478614198912276234240, \u0026#34;invalid current sqrtP\u0026#34; ); assertEq(tick, 85176, \u0026#34;invalid current tick\u0026#34;); assertEq( pool.liquidity(), 1517882343751509868544, \u0026#34;invalid current liquidity\u0026#34; ); 我们会发现，用Solidity写测试如此简单。\n失败 # 显然，仅仅测试成功的场景是不够的，我们也需要构造一些失败的测试样例。在提供流动性时可能会有哪些错误点？一些提示如下：\n上下界tick太大/太小 提供流动性数量为0 LP拥有的token数量不足 以上测试用例的编写将留作练习。代码也可以在这个仓库找到\n"},{"id":22,"href":"/docs/milestone_4/multi-pool-swaps/","title":"Multi-pool Swaps","section":"Milestone 4. Multi-pool Swaps","content":" Multi-pool Swaps # We\u0026rsquo;re now proceeding to the core of this milestone–implementing multi-pool swaps in our contracts. We won\u0026rsquo;t touch Pool contract in this milestone because it\u0026rsquo;s a core contract that should implement only core features. Multi-pool swaps is a utility feature, and we\u0026rsquo;ll implement it in Manager and Quoter contracts.\nUpdating Manager Contract # Single-pool and Multi-pool Swaps # In our current implementation, swap function in Manager contract supports only single-pool swaps and takes pool address in parameters:\nfunction swap( address poolAddress_, bool zeroForOne, uint256 amountSpecified, uint160 sqrtPriceLimitX96, bytes calldata data ) public returns (int256, int256) { ... } We\u0026rsquo;re going to split it into two functions: single-pool swap and multi-pool swap. These functions will have different set of parameters:\nstruct SwapSingleParams { address tokenIn; address tokenOut; uint24 tickSpacing; uint256 amountIn; uint160 sqrtPriceLimitX96; } struct SwapParams { bytes path; address recipient; uint256 amountIn; uint256 minAmountOut; } SwapSingleParams takes pool parameters, input amount, and a limiting price–this is pretty much identical to what we had before. Notice, that data is no longer required. SwapParams takes path, output amount recipient, input amount, and minimal output amount. The latter parameter replaces sqrtPriceLimitX96 because, when doing multi-pool swaps, we cannot use the slippage protection from Pool contract (which uses a limiting price). We need to implement another slippage protection, which checks the final output amount and compares it with minAmountOut: the slippage protection fails when the final output amount is smaller than minAmountOut. Core Swapping Logic # Let\u0026rsquo;s implement an internal _swap function that will be called by both single- and multi-pool swap functions. It\u0026rsquo;ll prepare parameters and call Pool.swap.\nfunction _swap( uint256 amountIn, address recipient, uint160 sqrtPriceLimitX96, SwapCallbackData memory data ) internal returns (uint256 amountOut) { ... SwapCallbackData is a new data structure that contains data we pass between swap functions and uniswapV3SwapCallback:\nstruct SwapCallbackData { bytes path; address payer; } path is a swap path and payer is the address that provides input tokens in swaps–we\u0026rsquo;ll have different payers during multi-pool swaps.\nFirst thing we do in _swap, is extracting pool parameters using Path library:\n// function _swap(...) { (address tokenIn, address tokenOut, uint24 tickSpacing) = data .path .decodeFirstPool(); Then we identify swap direction:\nbool zeroForOne = tokenIn \u0026lt; tokenOut; Then we make the actual swap:\n// function _swap(...) { (int256 amount0, int256 amount1) = getPool( tokenIn, tokenOut, tickSpacing ).swap( recipient, zeroForOne, amountIn, sqrtPriceLimitX96 == 0 ? ( zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1 ) : sqrtPriceLimitX96, abi.encode(data) ); This piece is identical to what we had before but this time we\u0026rsquo;re calling getPool to find the pool. getPool is a function that sorts tokens and calls PoolAddress.computeAddress:\nfunction getPool( address token0, address token1, uint24 tickSpacing ) internal view returns (IUniswapV3Pool pool) { (token0, token1) = token0 \u0026lt; token1 ? (token0, token1) : (token1, token0); pool = IUniswapV3Pool( PoolAddress.computeAddress(factory, token0, token1, tickSpacing) ); } After making a swap, we need to figure out which of the amounts is the output one:\n// function _swap(...) { amountOut = uint256(-(zeroForOne ? amount1 : amount0)); And that\u0026rsquo;s it. Let\u0026rsquo;s now look at how single-pool swap works.\nSingle-pool Swapping # swapSingle acts simply as a wrapper of _swap:\nfunction swapSingle(SwapSingleParams calldata params) public returns (uint256 amountOut) { amountOut = _swap( params.amountIn, msg.sender, params.sqrtPriceLimitX96, SwapCallbackData({ path: abi.encodePacked( params.tokenIn, params.tickSpacing, params.tokenOut ), payer: msg.sender }) ); } Notice that we\u0026rsquo;re building a one-pool path here: single-pool swap is a multi-pool swap with one pool 🙂.\nMulti-pool Swapping # Multi-pool swapping is only slightly more difficult than single-pool swapping. Let\u0026rsquo;s look at it:\nfunction swap(SwapParams memory params) public returns (uint256 amountOut) { address payer = msg.sender; bool hasMultiplePools; ... First swap is paid by user because it\u0026rsquo;s user who provides input tokens.\nThen, we start iterating over pools in the path:\n... while (true) { hasMultiplePools = params.path.hasMultiplePools(); params.amountIn = _swap( params.amountIn, hasMultiplePools ? address(this) : params.recipient, 0, SwapCallbackData({ path: params.path.getFirstPool(), payer: payer }) ); ... In each iteration, we\u0026rsquo;re calling _swap with these parameters:\nparams.amountIn tracks input amounts. During the first swap it\u0026rsquo;s the amount provided by user. During next swaps its the amounts returned from previous swaps. hasMultiplePools ? address(this) : params.recipient–if there are multiple pools in the path, recipient is the manager contract, it\u0026rsquo;ll store tokens between swaps. If there\u0026rsquo;s only one pool (last one) in the path, recipient is the one specified in the parameters (usually the same user that initiates the swap). sqrtPriceLimitX96 is set to 0 to disable slippage protection in the Pool contract. Last parameter is what we pass to uniswapV3SwapCallback–we\u0026rsquo;ll look at it shortly. After making one swap, we need to proceed to next pool in a path or return:\n... if (hasMultiplePools) { payer = address(this); params.path = params.path.skipToken(); } else { amountOut = params.amountIn; break; } } This is where we\u0026rsquo;re changing payer and removing a processed pool from the path.\nFinally, the new slippage protection:\nif (amountOut \u0026lt; params.minAmountOut) revert TooLittleReceived(amountOut); Swap Callback # Let\u0026rsquo;s look at the updated swap callback:\nfunction uniswapV3SwapCallback( int256 amount0, int256 amount1, bytes calldata data_ ) public { SwapCallbackData memory data = abi.decode(data_, (SwapCallbackData)); (address tokenIn, address tokenOut, ) = data.path.decodeFirstPool(); bool zeroForOne = tokenIn \u0026lt; tokenOut; int256 amount = zeroForOne ? amount0 : amount1; if (data.payer == address(this)) { IERC20(tokenIn).transfer(msg.sender, uint256(amount)); } else { IERC20(tokenIn).transferFrom( data.payer, msg.sender, uint256(amount) ); } } The callback expects encoded SwapCallbackData with path and payer address. It extracts pool tokens from the path, figures out swap direction (zeroForOne), and the amount the contract needs to transfer out. Then, it acts differently depending on payer address:\nIf payer is the current contract (this is so when making consecutive swaps), it transfers tokens to the next pool (the one that called this callback) from current contract\u0026rsquo;s balance. If payer is a different address (the user that initiated the swap), it transfers tokens from user\u0026rsquo;s balance. Updating Quoter Contract # Quoter is another contract that needs to be updated because we want to use it to also find output amounts in multi-pool swaps. Similarly to Manager, we\u0026rsquo;ll have two variants of quote function: single-pool and multi-pool one. Let\u0026rsquo;s look at the former first.\nSingle-pool Quoting # We need to make only a couple of changes in our current quote implementation:\nrename it to quoteSingle; extract parameters into a struct (this is mostly a cosmetic change); instead of a pool address, take a token address and a tick spacing in the parameters. // src/UniswapV3Quoter.sol struct QuoteSingleParams { address tokenIn; address tokenOut; uint24 tickSpacing; uint256 amountIn; uint160 sqrtPriceLimitX96; } function quoteSingle(QuoteSingleParams memory params) public returns ( uint256 amountOut, uint160 sqrtPriceX96After, int24 tickAfter ) { ... And the only change we have in the body of the function is usage of getPool to find pool address:\n... IUniswapV3Pool pool = getPool( params.tokenIn, params.tokenOut, params.tickSpacing ); bool zeroForOne = params.tokenIn \u0026lt; params.tokenOut; ... Multi-pool Quoting # Multi-pool quoting implementation is similar to the multi-pool swapping one, but it uses fewer parameters.\nfunction quote(bytes memory path, uint256 amountIn) public returns ( uint256 amountOut, uint160[] memory sqrtPriceX96AfterList, int24[] memory tickAfterList ) { sqrtPriceX96AfterList = new uint160[](path.numPools()); tickAfterList = new int24[](path.numPools()); ... As parameters, we only need input amount and swap path. The function returns similar values as quoteSingle, but \u0026ldquo;price after\u0026rdquo; and \u0026ldquo;tick after\u0026rdquo; are collected after each swap, thus we need to returns arrays.\nuint256 i = 0; while (true) { (address tokenIn, address tokenOut, uint24 tickSpacing) = path .decodeFirstPool(); ( uint256 amountOut_, uint160 sqrtPriceX96After, int24 tickAfter ) = quoteSingle( QuoteSingleParams({ tokenIn: tokenIn, tokenOut: tokenOut, tickSpacing: tickSpacing, amountIn: amountIn, sqrtPriceLimitX96: 0 }) ); sqrtPriceX96AfterList[i] = sqrtPriceX96After; tickAfterList[i] = tickAfter; amountIn = amountOut_; i++; if (path.hasMultiplePools()) { path = path.skipToken(); } else { amountOut = amountIn; break; } } The logic of the loop is identical to the one in the updated swap function:\nget current pool\u0026rsquo;s parameters; call quoteSingle on current pool; save returned values; repeat if there\u0026rsquo;re more pools in the path, or return otherwise. "},{"id":23,"href":"/docs/milestone_6/nft-renderer/","title":"NFT Renderer","section":"Milestone 6: NFT positions","content":" NFT Renderer # Now we need to build an NFT renderer: a library that will handle calls to tokenURI in the NFT manager contract. It will render JSON metadata and an SVG for each minted token. As we discussed earlier, we\u0026rsquo;ll use the data URI format, which requires base64 encoding–this means we\u0026rsquo;ll need a base64 encoder in Solidity. But first, let\u0026rsquo;s look at what our tokens will look like.\nSVG Template # I built this simplified variation of the Uniswap V3 NFTs:\nThis is what its code looks like;\n\u0026lt;svg xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; viewBox=\u0026#34;0 0 300 480\u0026#34;\u0026gt; \u0026lt;style\u0026gt; .tokens { font: bold 30px sans-serif; } .fee { font: normal 26px sans-serif; } .tick { font: normal 18px sans-serif; } \u0026lt;/style\u0026gt; \u0026lt;rect width=\u0026#34;300\u0026#34; height=\u0026#34;480\u0026#34; fill=\u0026#34;hsl(330,40%,40%)\u0026#34; /\u0026gt; \u0026lt;rect x=\u0026#34;30\u0026#34; y=\u0026#34;30\u0026#34; width=\u0026#34;240\u0026#34; height=\u0026#34;420\u0026#34; rx=\u0026#34;15\u0026#34; ry=\u0026#34;15\u0026#34; fill=\u0026#34;hsl(330,90%,50%)\u0026#34; stroke=\u0026#34;#000\u0026#34; /\u0026gt; \u0026lt;rect x=\u0026#34;30\u0026#34; y=\u0026#34;87\u0026#34; width=\u0026#34;240\u0026#34; height=\u0026#34;42\u0026#34; /\u0026gt; \u0026lt;text x=\u0026#34;39\u0026#34; y=\u0026#34;120\u0026#34; class=\u0026#34;tokens\u0026#34; fill=\u0026#34;#fff\u0026#34;\u0026gt; WETH/USDC \u0026lt;/text\u0026gt; \u0026lt;rect x=\u0026#34;30\u0026#34; y=\u0026#34;132\u0026#34; width=\u0026#34;240\u0026#34; height=\u0026#34;30\u0026#34; /\u0026gt; \u0026lt;text x=\u0026#34;39\u0026#34; y=\u0026#34;120\u0026#34; dy=\u0026#34;36\u0026#34; class=\u0026#34;fee\u0026#34; fill=\u0026#34;#fff\u0026#34;\u0026gt; 0.05% \u0026lt;/text\u0026gt; \u0026lt;rect x=\u0026#34;30\u0026#34; y=\u0026#34;342\u0026#34; width=\u0026#34;240\u0026#34; height=\u0026#34;24\u0026#34; /\u0026gt; \u0026lt;text x=\u0026#34;39\u0026#34; y=\u0026#34;360\u0026#34; class=\u0026#34;tick\u0026#34; fill=\u0026#34;#fff\u0026#34;\u0026gt; Lower tick: 123456 \u0026lt;/text\u0026gt; \u0026lt;rect x=\u0026#34;30\u0026#34; y=\u0026#34;372\u0026#34; width=\u0026#34;240\u0026#34; height=\u0026#34;24\u0026#34; /\u0026gt; \u0026lt;text x=\u0026#34;39\u0026#34; y=\u0026#34;360\u0026#34; dy=\u0026#34;30\u0026#34; class=\u0026#34;tick\u0026#34; fill=\u0026#34;#fff\u0026#34;\u0026gt; Upper tick: 123456 \u0026lt;/text\u0026gt; \u0026lt;/svg\u0026gt; This is a simple SVG template, and we\u0026rsquo;re going to make a Solidity contract that fills the fields in this template and returns it in tokenURI. The fields that will be filled uniquely for each token:\nthe color of the background, which is set in the first two rects; the hue component (330 in the template) will be unique for each token; the names of the tokens of a pool the position belongs to (WETH/USDC in the template); the fee of a pool (0.05%); tick values of the boundaries of the position (123456). Here are examples of NFTs our contract will be able to produce:\nDependencies # Solidity doesn\u0026rsquo;t provide native Base64 encoding tool so we\u0026rsquo;ll use a third-party one. Specifically, we\u0026rsquo;ll use the one from OpenZeppelin.\nAnother tedious thing about Solidity is that is has very poor support for operations with strings. For example, there\u0026rsquo;s no way to convert integers to strings–but we need that to render pool fee and position ticks in the SVG template. We\u0026rsquo;ll use the Strings library from OpenZeppelin to do that.\nFormat of the Result # The data produced by the renderer will have this format:\ndata:application/json;base64,BASE64_ENCODED_JSON The JSON will look like that:\n{ \u0026#34;name\u0026#34;: \u0026#34;Uniswap V3 Position\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;USDC/DAI 0.05%, Lower tick: -520, Upper text: 490\u0026#34;, \u0026#34;image\u0026#34;: \u0026#34;BASE64_ENCODED_SVG\u0026#34; } The image will be the above SVG template filled with position data and encoded in Base64.\nImplementing the Renderer # We\u0026rsquo;ll implement the renderer in a separate library contract to not make the NFT manager contract too noisy:\nlibrary NFTRenderer { struct RenderParams { address pool; address owner; int24 lowerTick; int24 upperTick; uint24 fee; } function render(RenderParams memory params) { ... } } In the render function, we\u0026rsquo;ll first render an SVG, then a JSON. To keep the code cleaner, we\u0026rsquo;ll break down each step into smaller steps.\nWe begin with fetching token symbols:\nfunction render(RenderParams memory params) { IUniswapV3Pool pool = IUniswapV3Pool(params.pool); IERC20 token0 = IERC20(pool.token0()); IERC20 token1 = IERC20(pool.token1()); string memory symbol0 = token0.symbol(); string memory symbol1 = token1.symbol(); ... SVG Rendering # Then we can render the SVG template:\nstring memory image = string.concat( \u0026#34;\u0026lt;svg xmlns=\u0026#39;http://www.w3.org/2000/svg\u0026#39; viewBox=\u0026#39;0 0 300 480\u0026#39;\u0026gt;\u0026#34;, \u0026#34;\u0026lt;style\u0026gt;.tokens { font: bold 30px sans-serif; }\u0026#34;, \u0026#34;.fee { font: normal 26px sans-serif; }\u0026#34;, \u0026#34;.tick { font: normal 18px sans-serif; }\u0026lt;/style\u0026gt;\u0026#34;, renderBackground(params.owner, params.lowerTick, params.upperTick), renderTop(symbol0, symbol1, params.fee), renderBottom(params.lowerTick, params.upperTick), \u0026#34;\u0026lt;/svg\u0026gt;\u0026#34; ); The template is broken down into multiple steps:\nfirst comes the header, which includes the CSS styles; then the background is rendered; then the top position information is rendered (token symbols and fee); finally, the bottom information is rendered (position ticks). The background is simply two rects. To render them we need to find the unique hue of this token and then we concatenate all the pieces together:\nfunction renderBackground( address owner, int24 lowerTick, int24 upperTick ) internal pure returns (string memory background) { bytes32 key = keccak256(abi.encodePacked(owner, lowerTick, upperTick)); uint256 hue = uint256(key) % 360; background = string.concat( \u0026#39;\u0026lt;rect width=\u0026#34;300\u0026#34; height=\u0026#34;480\u0026#34; fill=\u0026#34;hsl(\u0026#39;, Strings.toString(hue), \u0026#39;,40%,40%)\u0026#34;/\u0026gt;\u0026#39;, \u0026#39;\u0026lt;rect x=\u0026#34;30\u0026#34; y=\u0026#34;30\u0026#34; width=\u0026#34;240\u0026#34; height=\u0026#34;420\u0026#34; rx=\u0026#34;15\u0026#34; ry=\u0026#34;15\u0026#34; fill=\u0026#34;hsl(\u0026#39;, Strings.toString(hue), \u0026#39;,100%,50%)\u0026#34; stroke=\u0026#34;#000\u0026#34;/\u0026gt;\u0026#39; ); } The top template renders token symbols and pool fee:\nfunction renderTop( string memory symbol0, string memory symbol1, uint24 fee ) internal pure returns (string memory top) { top = string.concat( \u0026#39;\u0026lt;rect x=\u0026#34;30\u0026#34; y=\u0026#34;87\u0026#34; width=\u0026#34;240\u0026#34; height=\u0026#34;42\u0026#34;/\u0026gt;\u0026#39;, \u0026#39;\u0026lt;text x=\u0026#34;39\u0026#34; y=\u0026#34;120\u0026#34; class=\u0026#34;tokens\u0026#34; fill=\u0026#34;#fff\u0026#34;\u0026gt;\u0026#39;, symbol0, \u0026#34;/\u0026#34;, symbol1, \u0026#34;\u0026lt;/text\u0026gt;\u0026#34; \u0026#39;\u0026lt;rect x=\u0026#34;30\u0026#34; y=\u0026#34;132\u0026#34; width=\u0026#34;240\u0026#34; height=\u0026#34;30\u0026#34;/\u0026gt;\u0026#39;, \u0026#39;\u0026lt;text x=\u0026#34;39\u0026#34; y=\u0026#34;120\u0026#34; dy=\u0026#34;36\u0026#34; class=\u0026#34;fee\u0026#34; fill=\u0026#34;#fff\u0026#34;\u0026gt;\u0026#39;, feeToText(fee), \u0026#34;\u0026lt;/text\u0026gt;\u0026#34; ); } Fees are rendered as numbers with a fractional part. Since all possible fees are known in advance we don\u0026rsquo;t need to convert integers to fractional numbers and can simply hardcode the values:\nfunction feeToText(uint256 fee) internal pure returns (string memory feeString) { if (fee == 500) { feeString = \u0026#34;0.05%\u0026#34;; } else if (fee == 3000) { feeString = \u0026#34;0.3%\u0026#34;; } } In the bottom part we render position ticks:\nfunction renderBottom(int24 lowerTick, int24 upperTick) internal pure returns (string memory bottom) { bottom = string.concat( \u0026#39;\u0026lt;rect x=\u0026#34;30\u0026#34; y=\u0026#34;342\u0026#34; width=\u0026#34;240\u0026#34; height=\u0026#34;24\u0026#34;/\u0026gt;\u0026#39;, \u0026#39;\u0026lt;text x=\u0026#34;39\u0026#34; y=\u0026#34;360\u0026#34; class=\u0026#34;tick\u0026#34; fill=\u0026#34;#fff\u0026#34;\u0026gt;Lower tick: \u0026#39;, tickToText(lowerTick), \u0026#34;\u0026lt;/text\u0026gt;\u0026#34;, \u0026#39;\u0026lt;rect x=\u0026#34;30\u0026#34; y=\u0026#34;372\u0026#34; width=\u0026#34;240\u0026#34; height=\u0026#34;24\u0026#34;/\u0026gt;\u0026#39;, \u0026#39;\u0026lt;text x=\u0026#34;39\u0026#34; y=\u0026#34;360\u0026#34; dy=\u0026#34;30\u0026#34; class=\u0026#34;tick\u0026#34; fill=\u0026#34;#fff\u0026#34;\u0026gt;Upper tick: \u0026#39;, tickToText(upperTick), \u0026#34;\u0026lt;/text\u0026gt;\u0026#34; ); } Since ticks can be positive and negative, we nee to render them properly (with or without the minus sign):\nfunction tickToText(int24 tick) internal pure returns (string memory tickString) { tickString = string.concat( tick \u0026lt; 0 ? \u0026#34;-\u0026#34; : \u0026#34;\u0026#34;, tick \u0026lt; 0 ? Strings.toString(uint256(uint24(-tick))) : Strings.toString(uint256(uint24(tick))) ); } JSON Rendering # Now, let\u0026rsquo;s return to the render function and render the JSON. First, we need to render a token description:\nfunction render(RenderParams memory params) { ... SVG rendering ... string memory description = renderDescription( symbol0, symbol1, params.fee, params.lowerTick, params.upperTick ); ... Token description is a text string that contains all the same information that we render in token\u0026rsquo;s SVG:\nfunction renderDescription( string memory symbol0, string memory symbol1, uint24 fee, int24 lowerTick, int24 upperTick ) internal pure returns (string memory description) { description = string.concat( symbol0, \u0026#34;/\u0026#34;, symbol1, \u0026#34; \u0026#34;, feeToText(fee), \u0026#34;, Lower tick: \u0026#34;, tickToText(lowerTick), \u0026#34;, Upper text: \u0026#34;, tickToText(upperTick) ); } We can now assemble the JSON metadata:\nfunction render(RenderParams memory params) { string memory image = ...SVG rendering... string memory description = ...description rendering... string memory json = string.concat( \u0026#39;{\u0026#34;name\u0026#34;:\u0026#34;Uniswap V3 Position\u0026#34;,\u0026#39;, \u0026#39;\u0026#34;description\u0026#34;:\u0026#34;\u0026#39;, description, \u0026#39;\u0026#34;,\u0026#39;, \u0026#39;\u0026#34;image\u0026#34;:\u0026#34;data:image/svg+xml;base64,\u0026#39;, Base64.encode(bytes(image)), \u0026#39;\u0026#34;}\u0026#39; ); And, finally, we can return the result:\nreturn string.concat( \u0026#34;data:application/json;base64,\u0026#34;, Base64.encode(bytes(json)) ); Filling the Gap in tokenURI # Now we\u0026rsquo;re ready to return to the tokenURI function in the NFT manager contract and add the actual rendering:\nfunction tokenURI(uint256 tokenId) public view override returns (string memory) { TokenPosition memory tokenPosition = positions[tokenId]; if (tokenPosition.pool == address(0x00)) revert WrongToken(); IUniswapV3Pool pool = IUniswapV3Pool(tokenPosition.pool); return NFTRenderer.render( NFTRenderer.RenderParams({ pool: tokenPosition.pool, owner: address(this), lowerTick: tokenPosition.lowerTick, upperTick: tokenPosition.upperTick, fee: pool.fee() }) ); } Gas Costs # With all its benefits, storing data on-chain has a huge disadvantage: contract deployments become very expensive. When deploying a contract, you pay for the size of the contract, and all the strings and templates increase gas spending significantly. This gets even worse the more advanced your SVGs are: the more there are shapes, CSS styles, animations, etc. the more expensive it gets.\nKeep in mind that the NFT renderer we implemented above is not gas optimized: you can see the repetitive rect and text tag strings that can be extracted into internal functions. I sacrificed gas efficiency for the readability of the contract. In real NFT projects that store all data on-chain, code readability is usually very poor due to heavy gas cost optimizations.\nTesting # The last thing I wanted to focus here is how we can test the NFT images. It\u0026rsquo;s very important to keep all changes in NFT images tracked to ensure no change breaks rendering. For this, we need a way to test the output of tokenURI and its different variations (we can even pre-render the whole collection and have tests to ensure no image get broken during development).\nTo test the output of tokenURI, I added this custom assertion:\nassertTokenURI( nft.tokenURI(tokenId0), \u0026#34;tokenuri0\u0026#34;, \u0026#34;invalid token URI\u0026#34; ); The first argument is the actual output and the second argument is the name of the file that stores the expected one. The assertion loads the content of the file and compares it with the actual one:\nfunction assertTokenURI( string memory actual, string memory expectedFixture, string memory errMessage ) internal { string memory expected = vm.readFile( string.concat(\u0026#34;./test/fixtures/\u0026#34;, expectedFixture) ); assertEq(actual, string(expected), errMessage); } We can do this in Solidity thanks to the vm.readFile() cheat code provided by forge-std library, which is a helper library that comes with Forge. Not only this is simple and convenient, this is also secure: we can configure filesystem permissions to allow only permitted file operations. Specifically, to make the above test work, we need to add this fs_permissions rule to foundry.toml:\nfs_permissions = [{access=\u0026#39;read\u0026#39;,path=\u0026#39;.\u0026#39;}] And this is how you can read the SVG from a tokenURI fixture:\n$ cat test/fixtures/tokenuri0 \\ | awk -F \u0026#39;,\u0026#39; \u0026#39;{print $2}\u0026#39; \\ | base64 -d - \\ | jq -r .image \\ | awk -F \u0026#39;,\u0026#39; \u0026#39;{print $2}\u0026#39; \\ | base64 -d - \u0026gt; nft.svg \\ \u0026amp;\u0026amp; open nft.svg Ensure you have jq tool installed.\n"},{"id":24,"href":"/docs/milestone_5/protocol-fees/","title":"Protocol Fees","section":"Milestone 5. Fees and Price Oracle","content":" \\[ \\] Protocol Fees # While working on the Uniswap implementation, you\u0026rsquo;ve probably asked yourself, \u0026ldquo;How does Uniswap make money?\u0026rdquo; Well, it doesn\u0026rsquo;t (at least as of September 2022).\nIn the implementation we\u0026rsquo;ve built so far, traders pay liquidity providers for providing liquidity, and Uniswap Labs, as the company that developed the DEX, is not part of this process. Neither traders, nor liquidity providers pay Uniswap Labs for using the Uniswap DEX. How come?\nIn fact, there\u0026rsquo;s a way for Uniswap Labs to start making money on the DEX. However, the mechanism hasn\u0026rsquo;t been enabled yet (again, as of September 2022). Each Uniswap pool has protocol fees collection mechanism. Protocol fees are collected from swap fees: a small portion of swap fees is subtracted and saved as protocol fees to later be collected by Factory contract owner (Uniswap Labs). The size of protocol fees is expected to be determined by UNI token holders, but it must be between $1/4$ and $1/10$ (inclusive) of swap fees.\nFor brevity, we\u0026rsquo;re not going to add protocol fees to our implementation, but let\u0026rsquo;s see how they\u0026rsquo;re implemented in Uniswap.\nProtocol fee size is stored in slot0:\n// UniswapV3Pool.sol struct Slot0 { ... // the current protocol fee as a percentage of the swap fee taken on withdrawal // represented as an integer denominator (1/x)% uint8 feeProtocol; ... } And a global accumulator is needed to track accrued fees:\n// accumulated protocol fees in token0/token1 units struct ProtocolFees { uint128 token0; uint128 token1; } ProtocolFees public override protocolFees; Protocol fees are set in the setFeeProtocol function:\nfunction setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external override lock onlyFactoryOwner { require( (feeProtocol0 == 0 || (feeProtocol0 \u0026gt;= 4 \u0026amp;\u0026amp; feeProtocol0 \u0026lt;= 10)) \u0026amp;\u0026amp; (feeProtocol1 == 0 || (feeProtocol1 \u0026gt;= 4 \u0026amp;\u0026amp; feeProtocol1 \u0026lt;= 10)) ); uint8 feeProtocolOld = slot0.feeProtocol; slot0.feeProtocol = feeProtocol0 + (feeProtocol1 \u0026lt;\u0026lt; 4); emit SetFeeProtocol(feeProtocolOld % 16, feeProtocolOld \u0026gt;\u0026gt; 4, feeProtocol0, feeProtocol1); } As you can see, it\u0026rsquo;s allowed to set protocol fees separate for each of the tokens. The values are two uint8 that are packed to be stored in one uint8: feeProtocol1 is shifted to the left by 4 bits (this is identical to multiplying it by 16) and added to feeProtocol0. To unpack feeProtocol0, a remainder of division slot0.feeProtocol by 16 is taken; feeProtocol1 is simply integer division of slot0.feeProtocol by 4. Such packing works because neither feeProtocol0, nor feeProtocol1 can be greater than 10.\nBefore beginning a swap, we need to choose one of the protocol fees depending on swap direction (swap and protocol fees are collected on input tokens):\nfunction swap(...) { ... uint8 feeProtocol = zeroForOne ? (slot0_.feeProtocol % 16) : (slot0_.feeProtocol \u0026gt;\u0026gt; 4); ... To accrue protocol fees, we subtract them from swap fees right after computing swap step amounts:\n... while (...) { (..., step.feeAmount) = SwapMath.computeSwapStep(...); if (cache.feeProtocol \u0026gt; 0) { uint256 delta = step.feeAmount / cache.feeProtocol; step.feeAmount -= delta; state.protocolFee += uint128(delta); } ... } ... After a swap is done, the global protocol fees accumulator needs to be updated:\nif (zeroForOne) { if (state.protocolFee \u0026gt; 0) protocolFees.token0 += state.protocolFee; } else { if (state.protocolFee \u0026gt; 0) protocolFees.token1 += state.protocolFee; } Finally, Factory contract owner can collect accrued protocol fees by calling collectProtocol:\nfunction collectProtocol( address recipient, uint128 amount0Requested, uint128 amount1Requested ) external override lock onlyFactoryOwner returns (uint128 amount0, uint128 amount1) { amount0 = amount0Requested \u0026gt; protocolFees.token0 ? protocolFees.token0 : amount0Requested; amount1 = amount1Requested \u0026gt; protocolFees.token1 ? protocolFees.token1 : amount1Requested; if (amount0 \u0026gt; 0) { if (amount0 == protocolFees.token0) amount0--; protocolFees.token0 -= amount0; TransferHelper.safeTransfer(token0, recipient, amount0); } if (amount1 \u0026gt; 0) { if (amount1 == protocolFees.token1) amount1--; protocolFees.token1 -= amount1; TransferHelper.safeTransfer(token1, recipient, amount1); } emit CollectProtocol(msg.sender, recipient, amount0, amount1); } "},{"id":25,"href":"/docs/milestone_3/slippage-protection/","title":"Slippage Protection","section":"Milestone 3. 跨tick交易","content":" \\[ \\] Slippage Protection # Slippage is a very important issued in decentralized exchanges. Slippage simply means the difference between the price that you see on the screen when initialing a transaction and the actual price the swap is executed at. This difference appears because there\u0026rsquo;s a short (and sometimes long, depending on network congestion and gas costs) delay between when you send a transaction and when it gets mined. In more technical terms, blockchain state changes every block and there\u0026rsquo;s no guarantee that your transaction will be applied at a specific block.\nAnother important problem that slippage protection fixes is sandwich attacks–this is a common type of attacks on decentralized exchange users. During sandwiching, attackers \u0026ldquo;wrap\u0026rdquo; your swap transactions in their two transactions: one goes before your transaction and the other goes after it. In the first transaction, an attacker modifier the state of a pool so that your swap becomes very unprofitable for you and somewhat profitable for the attacker. This is achieved by adjusting pool liquidity so that your trade happens at a lower price. In the second transaction, the attacker reestablishes pool liquidity and the price. As a result, you get much less tokens than expected due to manipulated prices, and the attacker get some profit.\nThe way slippage protection is implemented in decentralized exchanges is by letting user choose how far the actual price is allowed to drop. By default, Uniswap V3 sets slippage tolerance to 0.1%, which means a swap is executed only if the price at the moment of execution is not smaller than 99.9% of the price the user saw in the browser. This is a very tight range and users are allowed to adjust this number, which is useful when volatility is high.\nLet\u0026rsquo;s add slippage protection to our implementation!\nSlippage Protection in Swaps # To protect swaps, we need to add one more parameter to swap function–we want to let user choose a stop price, a price at which swapping will stop. We\u0026rsquo;ll call the parameter sqrtPriceLimitX96:\nfunction swap( address recipient, bool zeroForOne, uint256 amountSpecified, uint160 sqrtPriceLimitX96, bytes calldata data ) public returns (int256 amount0, int256 amount1) { ... if ( zeroForOne ? sqrtPriceLimitX96 \u0026gt; slot0_.sqrtPriceX96 || sqrtPriceLimitX96 \u0026lt; TickMath.MIN_SQRT_RATIO : sqrtPriceLimitX96 \u0026lt; slot0_.sqrtPriceX96 \u0026amp;\u0026amp; sqrtPriceLimitX96 \u0026gt; TickMath.MAX_SQRT_RATIO ) revert InvalidPriceLimit(); ... When selling token $x$ (zeroForOne is true), sqrtPriceLimitX96 must be between the current price and the minimal $\\sqrt{P}$ since selling token $x$ moves the price down. Likewise, when selling token $y$, sqrtPriceLimitX96 must be between the current price and the maximal $\\sqrt{P}$ because price moves up.\nIn the while loop, we want to satisfy two conditions: full swap amount is filled and current price isn\u0026rsquo;t equal to sqrtPriceLimitX96:\n.. while ( state.amountSpecifiedRemaining \u0026gt; 0 \u0026amp;\u0026amp; state.sqrtPriceX96 != sqrtPriceLimitX96 ) { ... Which means that Uniswap V3 pools don\u0026rsquo;t fail when slippage tolerance gets hit and simply executes swap partially.\nAnother place where we need to consider sqrtPriceLimitX96 is when calling SwapMath.computeSwapStep:\n(state.sqrtPriceX96, step.amountIn, step.amountOut) = SwapMath .computeSwapStep( state.sqrtPriceX96, ( zeroForOne ? step.sqrtPriceNextX96 \u0026lt; sqrtPriceLimitX96 : step.sqrtPriceNextX96 \u0026gt; sqrtPriceLimitX96 ) ? sqrtPriceLimitX96 : step.sqrtPriceNextX96, state.liquidity, state.amountSpecifiedRemaining ); Here, we want to ensure that computeSwapStep never calculates swap amounts outside of sqrtPriceLimitX96–this guarantees that the current price will never cross the limiting price.\nSlippage Protection in Minting # Adding liquidity also requires slippage protection. This comes from the fact that price cannot be changed when adding liquidity (liquidity must be proportional to current price), thus liquidity providers also suffer from slippage. Unlike swap function however, we\u0026rsquo;re not forced to implement slippage protection in Pool contract–recall that Pool contract is a core contract and we don\u0026rsquo;t want to put unnecessary logic into it. This is why we made the Manager contract, and it\u0026rsquo;s in the Manager contract where we\u0026rsquo;ll implement slippage protection.\nThe Manager contract is a wrapper contract that makes calls to Pool contract more convenient. To implement slippage protection in the mint function, we can simply check the amounts of tokens taken by Pool and compare them to some minimal amounts chosen by user. Additionally, we can free users from calculating $\\sqrt{P_{lower}}$ and $\\sqrt{P_{upper}}$, as well as liquidity, and calculate these in Manager.mint().\nOur updated mint function will now take more parameters, so let\u0026rsquo;s group them in a struct:\n// src/UniswapV3Manager.sol contract UniswapV3Manager { struct MintParams { address poolAddress; int24 lowerTick; int24 upperTick; uint256 amount0Desired; uint256 amount1Desired; uint256 amount0Min; uint256 amount1Min; } function mint(MintParams calldata params) public returns (uint256 amount0, uint256 amount1) { ... amount0Min and amount1Min are the amounts that are calculated based on slippage tolerance. They must be smaller than the desired amounts, with the gap controlled by the slippage tolerance setting. Liquidity provider expect to provide amounts not smaller than amount0Min and amount1Min.\nNext, we calculate $\\sqrt{P_{lower}}$, $\\sqrt{P_{upper}}$, and liquidity:\n... IUniswapV3Pool pool = IUniswapV3Pool(params.poolAddress); (uint160 sqrtPriceX96, ) = pool.slot0(); uint160 sqrtPriceLowerX96 = TickMath.getSqrtRatioAtTick( params.lowerTick ); uint160 sqrtPriceUpperX96 = TickMath.getSqrtRatioAtTick( params.upperTick ); uint128 liquidity = LiquidityMath.getLiquidityForAmounts( sqrtPriceX96, sqrtPriceLowerX96, sqrtPriceUpperX96, params.amount0Desired, params.amount1Desired ); ... LiquidityMath.getLiquidityForAmounts is a new function, we\u0026rsquo;ll discuss it in the next chapter.\nNext step is to provide liquidity to the pool and check the amounts returned by the pool: if they\u0026rsquo;re too low, we revert.\n(amount0, amount1) = pool.mint( msg.sender, params.lowerTick, params.upperTick, liquidity, abi.encode( IUniswapV3Pool.CallbackData({ token0: pool.token0(), token1: pool.token1(), payer: msg.sender }) ) ); if (amount0 \u0026lt; params.amount0Min || amount1 \u0026lt; params.amount1Min) revert SlippageCheckFailed(amount0, amount1); That\u0026rsquo;s it!\n"},{"id":26,"href":"/docs/milestone_2/tick-bitmap-index/","title":"Tick Bitmap Index","section":"Milestone 2. 第二笔交易","content":" \\[ \\] Tick Bitmap Index # (译者注：由于bitmap也是数据结构中的常见名词，所以在此不做翻译)\n作为我们开始动态交易的第一步，我们需要建立一个ticks的索引。在前一个milestone中，我们手动计算并硬编码了目标位置的tick：\nfunction swap(address recipient, bytes calldata data) public returns (int256 amount0, int256 amount1) { int24 nextTick = 85184; ... } 当流动性在不同的价格区间中时，我们很难简单地计算出目标tick。事实上，我们需要根据不同区间中的流动性来找到它。因此，我们需要对于所有拥有流动性的tick建立一个索引，之后使用这个索引来寻找tick直到“填满”当前交易所需的流动性。在本小节中，我们将会实现一个这样的索引。\nBitmap # Bitmap是一个用压缩的方式提供数据索引的常用数据结构。一个bitmap实际上就是一个0和1构成的数组，其中的每一位的位置和元素内容都代表某种外部的信息。每个元素可以是0或者1，可以被看做是一个flag：当值为0的时候，flag没有设置；当值为1的时候，flag被设置。这个方法受欢迎的原因是整个数组可以作为二进制被存在一个数字中。\n例如，数组111101001101001就是数字31337。这个数字需要两个字节来存储（0x7a69），两字节能够存储16个flag（1字节=8位）。\nUniswap V3 使用这个技术来存储关于tick初始化的信息，也即哪个tick有流动性。当flag设置为(1)，对应的tick有流动性；当flag设置为(0)，对应的tick没有被初始化。让我们来看一下如何实现。\nTickBitmap合约 # 在池子合约中，tick index存储为一个状态变量：\ncontract UniswapV3Pool { using TickBitmap for mapping(int16 =\u0026gt; uint256); mapping(int16 =\u0026gt; uint256) public tickBitmap; ... } 这里的存储方式是一个mapping，key的类型是int16，value的类型是uint256。想象一个无穷的0/1数组：\n数组中每个元素都对应一个tick。为了更好地在数组中寻址，我们把数组按照字的大小划分：每个子数组为256位。为了找到数组中某个tick的位置，我们使用如下函数：\nfunction position(int24 tick) private pure returns (int16 wordPos, uint8 bitPos) { wordPos = int16(tick \u0026gt;\u0026gt; 8); bitPos = uint8(uint24(tick % 256)); } 即：我们首先找到对应的字所在的位置，然后再找到字中的位的位置。\u0026gt;\u0026gt;8即除以256。除以256的商为字的位置，余数为位的位置。\n举个例子，我们来计算一下我们某个tick的位置：\ntick = 85176 word_pos = tick \u0026gt;\u0026gt; 8 # or tick // 2**8 bit_pos = tick % 256 print(f\u0026#34;Word {word_pos}, bit {bit_pos}\u0026#34;) # Word 332, bit 184 翻转flag # 当在池子中添加流动性时，我们需要在bitmap中设置一些tick的flag：下界一个上界一个。我们通过flipTick方法来实现：\nfunction flipTick( mapping(int16 =\u0026gt; uint256) storage self, int24 tick, int24 tickSpacing ) internal { require(tick % tickSpacing == 0); // ensure that the tick is spaced (int16 wordPos, uint8 bitPos) = position(tick / tickSpacing); uint256 mask = 1 \u0026lt;\u0026lt; bitPos; self[wordPos] ^= mask; } 直到本书的后面章节之前，tickSpacing的值一直为1.\n找到对应的tick位置之后，我们需要生成一个掩码(mask)。一个掩码是一个仅有某一位（tick对应的位）为1的数字。为了计算掩码，我们只需要计算2**bit_pos (等于 1 \u0026lt;\u0026lt; bit_pos)：\nmask = 2**bit_pos # or 1 \u0026lt;\u0026lt; bit_pos print(bin(mask)) #0b10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 接下来，为了翻转一个flag，我们将掩码与对应的word进行异或：\nword = (2**256) - 1 # set word to all ones print(bin(word ^ mask)) #0b11111111111111111111111111111111111111111111111111111111111111111111111-\u0026gt;0\u0026lt;-1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111 可以看到第184位被翻转成了0\n找到下一个tick # 接下来是通过bitmap索引来寻找带有流动性的tick。\n在swap过程中，我们需要找到现在tick左边或者右边的下一个有流动性的tick。在前一章中，我们手动计算并硬编码这个值。但现在我们需要使用bitmap索引来找到这个值。我们会在 TickMath.nextInitializedTickWithinOneWord 方法中实现它。在这个函数中，需要实现两个场景：\n当卖出token $x$ (在这里即ETH)时，找到在同一个word内当前tick的右边下一个有流动性的tick。 当卖出token $y$ (在这里即USDC)时，找到在同一个word内当前tick的左边下一个有流动性的tick。 这分别对应两个方向交易时价格的移动：\n注意到，在代码中，方向是相反的：当购买token $x$时，我们实际上在搜寻左边的流动性tick；当卖出token $x$时，我们搜寻右边的tick。这仅仅在word内部成立，而word之间的顺序还是正序的。\n如果当前word内不存在有流动性的tick，我们将会在下一个循环中，在相邻的word中继续寻找。\n现在让我们来实现：\nfunction nextInitializedTickWithinOneWord( mapping(int16 =\u0026gt; uint256) storage self, int24 tick, int24 tickSpacing, bool lte ) internal view returns (int24 next, bool initialized) { int24 compressed = tick / tickSpacing; ... 第一个参数让这个函数成为mapping(int16 =\u0026gt; uint256)的一个方法 tick代表现在的tick tickSpaceing在本章节中一直为1 lte是一个设置方向的flag。为true时，我们是卖出token $x$，在右边寻找下一个tick；false时相反。 if (lte) { (int16 wordPos, uint8 bitPos) = position(compressed); uint256 mask = (1 \u0026lt;\u0026lt; bitPos) - 1 + (1 \u0026lt;\u0026lt; bitPos); uint256 masked = self[wordPos] \u0026amp; mask; ... 当卖出 $x$时，我们：\n获得现在tick的对应位置 求出一个掩码，当前位及所有右边的位为1 将掩码覆盖到当前word上，得出右边的所有位 ... initialized = masked != 0; next = initialized ? (compressed - int24(uint24(bitPos - BitMath.mostSignificantBit(masked)))) * tickSpacing : (compressed - int24(uint24(bitPos))) * tickSpacing; ... 接下来，masked不为0表示右边至少有一个tick对应的位为1。如果有这样的tick，那右边就有流动性；否则就没有（在当前word中）。根据结果，我们要么求出下一个有流动性的tick位置，或者下一个word的最左边一位——这让我们能够在下一个循环中搜索下一个word里面的有流动性的tick。\n... } else { (int16 wordPos, uint8 bitPos) = position(compressed + 1); uint256 mask = ~((1 \u0026lt;\u0026lt; bitPos) - 1); uint256 masked = self[wordPos] \u0026amp; mask; ... 类似地，当卖出$y$时：\n获取下一个tick的位置 求出一个不同的掩码，当前位置所有左边的位为1 应用这个掩码，获得左边的所有位 同样，如果当前word左边没有有流动性的tick，返回上一个word的最右边一位：\n... initialized = masked != 0; // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick next = initialized ? (compressed + 1 + int24(uint24((BitMath.leastSignificantBit(masked) - bitPos)))) * tickSpacing : (compressed + 1 + int24(uint24((type(uint8).max - bitPos)))) * tickSpacing; } 这样就完成了！\n正如你所见，nextInitializedTickWithinOneWord 并不一定真正找到了我们想要的tick——它的搜索范围仅仅包括当前word。事实上，我们并不希望在这个函数里循环遍历所有的word，因为我们并没有传入边界的参数。这个函数会在swap中运行地很好——我们马上就会看到。\n"},{"id":27,"href":"/docs/introduction/dev-environment/","title":"开发环境","section":"Milestone 0. 简介","content":" 开发环境 # 本书中，我们会搭建两个应用：\n链上：一套部署在以太坊上的智能合约 链下：一个与智能合约交互的前端应用 尽管本书把前端应用作为其中一部分，但不是我们的主要关注点。我们搭建前端仅仅为了展示智能合约是如何集成到前端应用中的。因为，前端部分是可选读内容，但在本书代码仓库中也提供者这部分的代码\n以太坊简介 # 以太坊是一个允许任何人在上面运行应用的区块链。它与一个传统云服务的主要区别在于：\n维持这个应用不需要付费，部署应用需要付费 应用代码是不可变的，在其部署后你没有办法再进行修改 用户调用你的应用需要花费gas（手续费） 为了更好地理解这些区别，我们来看一下以太坊的构建。\n以太坊的核心（其他区块链也是同理）是一个数据库。这个数据库中最有价值的数据是账户状态。以太坊中的每个账户包含一个地址，以及以下数据：\n余额：账户的以太坊(ether)余额 代码：部署在这个地址上的智能合约的字节码 存储：智能合约存储数据的空间 nonce：一个用来防止重放攻击的整数序号 （译者注：Ethereum和ether的中文译名均为以太坊，读者注意区分。Ethereum指的是这条区块链，ether指的是该链上的原生代币）\n以太坊的主要任务是安全地维护这些数据，防止未经授权的更改。\n同时，以太坊也是一个网络，网络中的每个计算机都独立地构建和维持这些状态。网络的主要目标是能够去中心化地访问数据库：没有任何单个权威机构可以单方面修改任何数据。这是通过叫做*共识(consensus)*的机制来实现的，即网络中节点遵守的一系列规则。如果有节点违反了规则，它将会被从这个网络中排除。\n有趣的是，区块链也可以使用MSQL！只是可能会存在一定的性能问题。以太坊中使用的是LevelDB，一个高效的KV数据库。\n每个以太坊节点运行EVM，以太坊虚拟机。虚拟机是一个能够执行其他程序的程序，EVM则是执行智能合约程序的程序。用户通过交易(transactions)与合约交互，除了能够简单的发送ether，交易也能够调用智能合约，需要传输的数据包括：\n一个合约函数的签名 函数参数 交易被打包进区块，区块被矿工挖出。网络中的每个节点都可以验证每一个区块中的每一笔交易。\n某种意义上来说，智能合约与JSON APIs有一定类似，区别就是你调用的是智能合约函数。与API的后端类似，智能合约也执行程序逻辑，并且也可能更改智能合约中存储的数据。与API不同的是，你需要发送一笔交易来改变区块链的状态，并且你需要为每一笔交易付费。\n最后，以太坊节点也实现了一套JSON-RPC API。我们可以通过这个API与节点进行交互：获取账户余额、估算gas费、获取区块和交易、发送交易、执行不上链的智能合约调用（仅能读数据）。在这里你可以获得一个可用端点的列表。\n交易也是通过这个API发送的, 参见 eth_sendTransaction.\n本地开发环境 # 我们将要搭建智能合约并且在以太坊上运行它们，这意味着我们需要一个节点。在本地测试和运行合约也需要一个节点。曾经这使得智能合约开发十分麻烦，因为在一个真实节点上运行大量的测试会十分缓慢。不过现在已经有了很多快速简洁的解决方案。例如Truffle 和 Hardhat。不过这些工具的问题在于我们需要用JavaScript来写测试以及与区块链的交互，这事因为Truffle和Hardhat都运行了一个本地节点，并且使用JavaScript的Web3库来与节点交互。\n我们将会选择一个新的框架，Foundry。\nFoundry # Foundry是一套用于以太坊应用开发的工具包。我们将会使用以下这些工具：\nForge，一个Solidity的测试框架. Anvil，一个本地以太坊节点。我们将会用它来部署我们的合约，并且与前端app交互。 Cast, 一个非常好用的CLI工具。 Forge使智能合约开发更加容易。当使用Forge开发时，我们不需要运行一个本地节点来进行测试；Forge会在其内置的EVM上运行测试，大大加快了速度，不再需要给节点发送交易和挖出区块。除此以外，Forge还能够使用Solidity编写测试！Forge也内置了机制方便我们模拟区块链的各种状态：修改某个账户余额，从其他地址执行合约，把合约部署在任意地址等等。\n然而，我们仍然需要一个本地节点来部署合约。在这里我们将会使用Anvil。前端应用可以使用JavaScript的Web3库来与以太坊节点进行交互。\nEthers.js # Ethers.js 是一个与Ethereum交互的JavaScript库. 这是Dapp开发中使用的两个最流行的JS库之一(另一个是web3.js)。这些库让我们可以使用JSON-API与以太坊节点交互，并且也有各种功能丰富的函数来帮助开发者更容易地开发应用。\nMetaMask # MetaMask是一个浏览器中的以太坊钱包。它是一个浏览器插件，可以安全地创建和存储私钥。Metamask也是最常用的以太坊钱包应用，我们将使用它来与我们的本地运行的节点进行交互。\nReact # React 是前端开发中使用的一个著名的JS库. 本书并不要求会React，我们将会提供一个模板。、\n准备开发环境 # 创建一个新的文件夹，并在其中运行 forge init ：\n$ mkdir uniswapv3clone $ cd uniswapv3clone $ forge init 如果你使用Visual Studio Code进行开发，可以在forge init 中加入 --vscode 这个flas：forge init --vscode。Forge会在初始化时对于VSCode进行特别设置。\nForge会在src, test, 和script创建样例合约，这些都可以删掉\n设置前端开发环境:\n$ npx create-react-app ui "},{"id":28,"href":"/docs/milestone_1/first-swap/","title":"第一笔交易","section":"Milestone 1. 第一笔交易","content":" \\[ \\] 第一笔交易 # 现在我们已经有了流动性，我们可以进行我们的第一笔交易了！\n计算交易数量 # 首先，我们需要知道如何计算交易出入的数量。同样，我们在这小节中也会硬编码我们希望交易的USDC数额，这里我们选择42，也即花费42USDC购买ETH\n在决定了我们希望投入的资金量之后，我们需要计算我们会获得多少token。在Uniswap V2中，我们会使用现在池子的资产数量来计算，但是在V3中我们有$L$和$\\sqrt{P}$，并且我们知道在交易过程中，$L$保持不变而只有$\\sqrt{P}$发生变化（当在同一区间内进行交易时，V3的表现和V2一致）。我们还知道如下公式：\n$$L = \\frac{\\Delta y}{\\Delta \\sqrt{P}}$$\n并且，在这里我们知道了$\\Delta y$！它正是我们希望投入的42USDC。因此，我们可以根据公式得出投入的 42USDC 会对价格造成多少影响：\n$$\\Delta \\sqrt{P} = \\frac{\\Delta y}{L}$$\n在V3中，我们选择我们希望交易导致的价格变动（回忆一下，交易使得现价沿着曲线移动）。知道了目标价格(target price)，合约可以计算出投入token的数量和输出token的数量。\n我们将数字代入上述公式：\n$$\\Delta \\sqrt{P} = \\frac{42 \\enspace USDC}{1517882343751509868544} = 2192253463713690532467206957$$\n把差价加到现在的$\\sqrt{P}$，我们就能得到目标价格：\n$$\\sqrt{P_{target}} = \\sqrt{P_{current}} + \\Delta \\sqrt{P}$$\n$$\\sqrt{P_{target}} = 5604469350942327889444743441197$$\n在Python中进行相应计算:\namount_in = 42 * eth price_diff = (amount_in * q96) // liq price_next = sqrtp_cur + price_diff print(\u0026#34;New price:\u0026#34;, (price_next / q96) ** 2) print(\u0026#34;New sqrtP:\u0026#34;, price_next) print(\u0026#34;New tick:\u0026#34;, price_to_tick((price_next / q96) ** 2)) # New price: 5003.913912782393 # New sqrtP: 5604469350942327889444743441197 # New tick: 85184 知道了目标价格，我们就能计算出投入token的数量和获得token的数量：\n$$ x = \\frac{L(\\sqrt{p_b}-\\sqrt{p_a})}{\\sqrt{p_b}\\sqrt{p_a}}$$ $$ y = L(\\sqrt{p_b}-\\sqrt{p_a}) $$\n用Python:\namount_in = calc_amount1(liq, price_next, sqrtp_cur) amount_out = calc_amount0(liq, price_next, sqrtp_cur) print(\u0026#34;USDC in:\u0026#34;, amount_in / eth) print(\u0026#34;ETH out:\u0026#34;, amount_out / eth) # USDC in: 42.0 # ETH out: 0.008396714242162444 我们使用另一个公式验证一下：\n$$\\Delta x = \\Delta \\frac{1}{\\sqrt{P}} L$$\n使用上述公式，在知道价格变动和流动性数量的情况下，我们能求出我们购买了多少ETH，也即$\\Delta x$。一个需要注意的点是： $\\Delta \\frac{1}{\\sqrt{P}}$ 不等于 $\\frac{1}{\\Delta \\sqrt{P}}$！前者才是ETH价格的变动，并且能够用如下公式计算：\n$$\\Delta \\frac{1}{\\sqrt{P}} = \\frac{1}{\\sqrt{P_{target}}} - \\frac{1}{\\sqrt{P_{current}}}$$\n我们知道了公式里面的所有数值，接下来将其带入即可（可能会在屏幕显示上有些问题）：\n$$\\Delta \\frac{1}{\\sqrt{P}} = \\frac{1}{5604469350942327889444743441197} - \\frac{1}{5602277097478614198912276234240}$$\n$$\\Delta \\frac{1}{\\sqrt{P}} = -0.00000553186106731426$$\n接下来计算 $\\Delta x$:\n$$\\Delta x = -0.00000553186106731426 * 1517882343751509868544 = -8396714242162698 $$\n即 0.008396714242162698 ETH，这与我们第一次算出来的数量非常接近！注意到这个结果是负数，因为我们是从池子中移出ETH。\n实现swap # 交易在swap函数中实现：\nfunction swap(address recipient) public returns (int256 amount0, int256 amount1) { ... 此时，它仅仅接受一个recipient参数，即放出token的接收者。\n首先，我们需要计算出目标价格和对应tick，以及token的数量。同样，我们将会在这里硬编码我们之前计算出来的值：\n... int24 nextTick = 85184; uint160 nextPrice = 5604469350942327889444743441197; amount0 = -0.008396714242162444 ether; amount1 = 42 ether; ... 接下来，我们需要更新现在的tick和对应的sqrtP：\n... (slot0.tick, slot0.sqrtPriceX96) = (nextTick, nextPrice); ... 然后，合约把对应的token发送给recipient并且让调用者将需要的token转移到本合约：\n... IERC20(token0).transfer(recipient, uint256(-amount0)); uint256 balance1Before = balance1(); IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback( amount0, amount1 ); if (balance1Before + uint256(amount1) \u0026lt; balance1()) revert InsufficientInputAmount(); ... 我们使用callback函数来将控制流转移到调用者，让它转入token，之后我们需要通过检查确认caller转入了正确的数额。\n最后，合约释放出一个swap事件，使得该笔交易能够被监听到。这个事件包含了所有有关这笔交易的信息：\n... emit Swap( msg.sender, recipient, amount0, amount1, slot0.sqrtPriceX96, liquidity, slot0.tick ); 这样就完成了！这个函数的功能仅仅是将一些token发送到了指定的接收地址，并且从调用者处接受一定数量的另一种token。随着本书的进展，这个函数会变得越来越复杂。\n测试交易 # 现在，我们来测试swap函数。在相同的测试文件中（译者注：UniswapV3Pool.t.sol），创建testSwapBuyEth函数并进行初始化设置。准备阶段的参数与testMintSuccess一致：\nfunction testSwapBuyEth() public { TestCaseParams memory params = TestCaseParams({ wethBalance: 1 ether, usdcBalance: 5000 ether, currentTick: 85176, lowerTick: 84222, upperTick: 86129, liquidity: 1517882343751509868544, currentSqrtP: 5602277097478614198912276234240, shouldTransferInCallback: true, mintLiqudity: true }); (uint256 poolBalance0, uint256 poolBalance1) = setupTestCase(params); ... 我们不会测试流动性是否正确添加到了池子里，因为之前已经有过针对此功能的测试样例了\n在测试中，我们需要42 USDC：\ntoken1.mint(address(this), 42 ether); 交易之前，我们还需要实现callback函数，来确保能够将钱转给池子合约：\nfunction uniswapV3SwapCallback(int256 amount0, int256 amount1) public { if (amount0 \u0026gt; 0) { token0.transfer(msg.sender, uint256(amount0)); } if (amount1 \u0026gt; 0) { token1.transfer(msg.sender, uint256(amount1)); } } 由于交易中的数额可以为正或负（从池子中拿走的数量），在callback中我们只发出数额为正的对应token，也即我们希望卖出的token。\n现在我们可以调用swap了：\n(int256 amount0Delta, int256 amount1Delta) = pool.swap(address(this)); 函数返回了在本次交易中涉及到的两种token数量，我们需要验证一下它们是否正确：\nassertEq(amount0Delta, -0.008396714242162444 ether, \u0026#34;invalid ETH out\u0026#34;); assertEq(amount1Delta, 42 ether, \u0026#34;invalid USDC in\u0026#34;); 接下来，我们需要验证token的确从调用者（译者注：也即本测试合约）处转出：\nassertEq( token0.balanceOf(address(this)), uint256(userBalance0Before - amount0Delta), \u0026#34;invalid user ETH balance\u0026#34; ); assertEq( token1.balanceOf(address(this)), 0, \u0026#34;invalid user USDC balance\u0026#34; ); 并且被发送到了池子合约中：\nassertEq( token0.balanceOf(address(pool)), uint256(int256(poolBalance0) + amount0Delta), \u0026#34;invalid pool ETH balance\u0026#34; ); assertEq( token1.balanceOf(address(pool)), uint256(int256(poolBalance1) + amount1Delta), \u0026#34;invalid pool USDC balance\u0026#34; ); 最后，我们验证池子的状态是否正确更新：\n(uint160 sqrtPriceX96, int24 tick) = pool.slot0(); assertEq( sqrtPriceX96, 5604469350942327889444743441197, \u0026#34;invalid current sqrtP\u0026#34; ); assertEq(tick, 85184, \u0026#34;invalid current tick\u0026#34;); assertEq( pool.liquidity(), 1517882343751509868544, \u0026#34;invalid current liquidity\u0026#34; ); 注意到，在这里交易并没有改变池子流动性——在后面的某个章节，我们会看到它将如何改变\n练习 # 写一个测试样例，失败并报错InsufficientInputAmount。要记得，这里还有一个隐藏的bug🙂\n"},{"id":29,"href":"/docs/milestone_3/liquidity-calculation/","title":"Liquidity Calculation","section":"Milestone 3. 跨tick交易","content":" \\[ \\] Liquidity Calculation # Of the whole math of Uniswap V3, what we haven\u0026rsquo;t yet implemented in Solidity is liquidity calculation. In the Python script, we have these functions:\ndef liquidity0(amount, pa, pb): if pa \u0026gt; pb: pa, pb = pb, pa return (amount * (pa * pb) / q96) / (pb - pa) def liquidity1(amount, pa, pb): if pa \u0026gt; pb: pa, pb = pb, pa return amount * q96 / (pb - pa) Let\u0026rsquo;s implement them in Solidity so we could calculate liquidity in the Manager.mint() function.\nImplementing Liquidity Calculation for Token X # The functions we\u0026rsquo;re going to implement allow us to calculate liquidity ($L = \\sqrt{xy}$) when token amounts and price ranges are known. Luckily, we already know all the formulas. Let\u0026rsquo;s recall this one:\n$$\\Delta x = \\Delta \\frac{1}{\\sqrt{P}}L$$\nIn a previous chapter, we used this formula to calculate swap amounts ($\\Delta x$ in this case) and now we\u0026rsquo;re going to use it to find $L$:\n$$L = \\frac{\\Delta x}{\\Delta \\frac{1}{\\sqrt{P}}}$$\nOr, after simplifying it: $$L = \\frac{\\Delta x \\sqrt{P_u} \\sqrt{P_l}}{\\sqrt{P_u} - \\sqrt{P_l}}$$\nWe derived this formula in Liquidity Amount Calculation.\nIn Solidity, we\u0026rsquo;ll again use PRBMath to handle overflows when multiplying and then dividing:\nfunction getLiquidityForAmount0( uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint256 amount0 ) internal pure returns (uint128 liquidity) { if (sqrtPriceAX96 \u0026gt; sqrtPriceBX96) (sqrtPriceAX96, sqrtPriceBX96) = (sqrtPriceBX96, sqrtPriceAX96); uint256 intermediate = PRBMath.mulDiv( sqrtPriceAX96, sqrtPriceBX96, FixedPoint96.Q96 ); liquidity = uint128( PRBMath.mulDiv(amount0, intermediate, sqrtPriceBX96 - sqrtPriceAX96) ); } Implementing Liquidity Calculation for Token Y # Similarly, we\u0026rsquo;ll use the other formula from Liquidity Amount Calculation to find $L$ when amount of $y$ and price range is known: $$\\Delta y = \\Delta\\sqrt{P} L$$ $$L = \\frac{\\Delta y}{\\sqrt{P_u}-\\sqrt{P_l}}$$\nfunction getLiquidityForAmount1( uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint256 amount1 ) internal pure returns (uint128 liquidity) { if (sqrtPriceAX96 \u0026gt; sqrtPriceBX96) (sqrtPriceAX96, sqrtPriceBX96) = (sqrtPriceBX96, sqrtPriceAX96); liquidity = uint128( PRBMath.mulDiv( amount1, FixedPoint96.Q96, sqrtPriceBX96 - sqrtPriceAX96 ) ); } I hope this is clear!\nFinding Fair Liquidity # You might be wondering why there are two ways of calculating $L$ while we have always had only one $L$, which is calculated as $L = \\sqrt{xy}$, and which of these ways is correct. The answer is: they\u0026rsquo;re both correct.\nIn the above formulas, we calculate $L$ based on different parameters: price range and the amount of either token. Different price ranges and different token amounts will result in different values of $L$. And there\u0026rsquo;s a scenario where we need to calculate both of the $L$\u0026rsquo;s and pick one of them. Recall this piece from mint function:\nif (slot0_.tick \u0026lt; lowerTick) { amount0 = Math.calcAmount0Delta(...); } else if (slot0_.tick \u0026lt; upperTick) { amount0 = Math.calcAmount0Delta(...); amount1 = Math.calcAmount1Delta(...); liquidity = LiquidityMath.addLiquidity(liquidity, int128(amount)); } else { amount1 = Math.calcAmount1Delta(...); } It turns out, we also need to follow this logic when calculating liquidity:\nif we\u0026rsquo;re calculating liquidity for a range that\u0026rsquo;s below current price, we use the $\\Delta x$ version on the formula; when calculation liquidity for a range that\u0026rsquo;s above current price, we use the $\\Delta y$ one; when a price range includes the current price, we calculate both and pick the smaller of them. Again, we discussed these ideas in Liquidity Amount Calculation.\nLet\u0026rsquo;s implement this logic now. When current price is below the lower bound of a price range:\nfunction getLiquidityForAmounts( uint160 sqrtPriceX96, uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint256 amount0, uint256 amount1 ) internal pure returns (uint128 liquidity) { if (sqrtPriceAX96 \u0026gt; sqrtPriceBX96) (sqrtPriceAX96, sqrtPriceBX96) = (sqrtPriceBX96, sqrtPriceAX96); if (sqrtPriceX96 \u0026lt;= sqrtPriceAX96) { liquidity = getLiquidityForAmount0( sqrtPriceAX96, sqrtPriceBX96, amount0 ); When current price is within a range, we\u0026rsquo;re picking the smaller $L$:\n} else if (sqrtPriceX96 \u0026lt;= sqrtPriceBX96) { uint128 liquidity0 = getLiquidityForAmount0( sqrtPriceX96, sqrtPriceBX96, amount0 ); uint128 liquidity1 = getLiquidityForAmount1( sqrtPriceAX96, sqrtPriceX96, amount1 ); liquidity = liquidity0 \u0026lt; liquidity1 ? liquidity0 : liquidity1; And finally:\n} else { liquidity = getLiquidityForAmount1( sqrtPriceAX96, sqrtPriceBX96, amount1 ); } Done.\n"},{"id":30,"href":"/docs/milestone_5/price-oracle/","title":"Price Oracle","section":"Milestone 5. Fees and Price Oracle","content":" \\[ \\] Price Oracle # The final mechanism we\u0026rsquo;re going to add to our DEX is a price oracle. Even though it\u0026rsquo;s not essential to a DEX (there are DEXes that don\u0026rsquo;t implement a price oracle), it\u0026rsquo;s still an important feature of Uniswap and something that\u0026rsquo;s interesting to learn about.\nWhat is Price Oracle? # Price oracle is a mechanism that provides asset prices to blockchain. Since blockchains are isolated ecosystems, there\u0026rsquo;s no direct way of querying external data, e.g. fetching asset prices from centralized exchanges via API. Another, a very hard one, problem is data validity and authenticity: when fetching prices from an exchange, how do you know they\u0026rsquo;re real? You have to trust the source. But the internet is not often secure and, sometimes, prices can be manipulated, DNS records can be hijacked, API servers can go down, etc. All these difficulties need to be addressed so we could have reliable and correct on-chain prices.\nOne of the first working solution of the above mentioned problems was Chainlink. Chainlink runs a decentralized network of oracles that fetch asset prices from centralized exchanges via APIs, average them, and provide them on-chain in a tamper-proof way. Basically, Chainlink is a set of contracts with one state variable, asset price, that can be read by anyone (any other contract or user) but can be written to only by oracles.\nThis is one way of looking at price oracles. There\u0026rsquo;s another.\nIf we have native on-chain exchanges, why would we need to fetch prices from outside? This is how the Uniswap price oracle works. Thanks to arbitraging and high liquidity, asset prices on Uniswap are close to those on centralized exchanges. So, instead of using centralized exchanges as the source of truth for asset prices, we can use Uniswap, and we don\u0026rsquo;t need to solve the problems related to delivering data on-chain (we also don\u0026rsquo;t need to trust to data providers).\nHow Uniswap Price Oracle Works # Uniswap simply keeps the record of all previous swap prices. That\u0026rsquo;s it. But instead of tracking actual prices, Uniswap tracks the accumulated price, which is the sum of prices at each second in the history of a pool contract.\n$$a_{i} = \\sum_{i=1}^t p_{i}$$\nThis approach allows to find time-weighted average price between two points in time ($t_1$ and $t_2$) by simply getting the accumulated prices at these points ($a_{t_1}$ and $a_{t_2}$), subtracting one from the other, and dividing by the number of seconds between the two points:\n$$p_{t_1,t_2} = \\frac{a_{t_2} - a_{t_1}}{t_2 - t_1}$$\nThis is how it worked in Uniswap V2. In V3, it\u0026rsquo;s slightly different. The price that\u0026rsquo;s accumulated is the current tick (which is $log_{1.0001}$ of the price):\n$$a_{i} = \\sum_{i=1}^t log_{1.0001}P(i)$$\nAnd instead of averaging prices, geometric mean is taken:\n$$ P_{t_1,t_2} = \\left( \\prod_{i=t_1}^{t_2} P_i \\right) ^ \\frac{1}{t_2-t_1} $$\nTo find the time-weighted geometric mean price between two points in time, we take the accumulated values at these time points, subtract one from the other, divide by the number of seconds between the two points, and calculate $1.0001^{x}$:\n$$ log_{1.0001}{(P_{t_1,t_2})} = \\frac{\\sum_{i=t_1}^{t_2} log_{1.0001}(P_i)}{t_2-t_1}$$ $$ = \\frac{a_{t_2} - a_{t_1}}{t_2-t_1}$$\n$$P_{t_1,t_2} = 1.0001^{\\frac{a_{t_2} - a_{t_1}}{t_2-t_1}}$$\nUniswap V2 didn\u0026rsquo;t store historical accumulated prices, which required referring to a third-party blockchain data indexing service to find a historical price when calculating an average one. Uniswap V3, on the other hand, allows to store up to 65,535 historical accumulated prices, which makes it much easier to calculate any historical time-weighter geometric price.\nPrice Manipulation Mitigation # Another important topic is price manipulation and how it\u0026rsquo;s mitigated in Uniswap.\nIt\u0026rsquo;s theoretically possible to manipulate a pool\u0026rsquo;s price to your advantage: for example, buy a big amount of tokens to raise its price and get a profit on a third-party DeFi service that uses Uniswap price oracles, then trade the tokens back to the real price. To mitigate such attacks, Uniswap tracks prices at the end of a block, after the last trade of a block. This removes the possibility of in-block price manipulations.\nTechnically, prices in the Uniswap oracle are updated at the beginning of each block, and each price is calculated before the first swap in a block.\nPrice Oracle Implementation # Alright, let\u0026rsquo;s get to code.\nObservations and Cardinality # We\u0026rsquo;ll begin by creating the Oracle library contract and the Observation structure:\n// src/lib/Oracle.sol library Oracle { struct Observation { uint32 timestamp; int56 tickCumulative; bool initialized; } ... } An observation is a slot that stores a recorded price. It stores a price, the timestamp when this price was recorded, and the initialized flag that is set to true when the observation is activated (not all observations are activated by default). A pool contract can store up to 65,535 observations:\n// src/UniswapV3Pool.sol contract UniswapV3Pool is IUniswapV3Pool { using Oracle for Oracle.Observation[65535]; ... Oracle.Observation[65535] public observations; } However, since storing that many instances of Observation requires a lot of gas (someone would have to pay for writing each of them to contract\u0026rsquo;s storage), a pool by default can store only 1 observation, which gets overwritten each time a new price is recorded. The number of activated observations, the cardinality of observations, can be increased at any time by anyone who\u0026rsquo;s willing to pay for that. To manage cardinality, we need a few extra state variables:\n... struct Slot0 { // Current sqrt(P) uint160 sqrtPriceX96; // Current tick int24 tick; // Most recent observation index uint16 observationIndex; // Maximum number of observations uint16 observationCardinality; // Next maximum number of observations uint16 observationCardinalityNext; } ... observationIndex tracks the index of the most recent observation; observationCardinality tracks the number of activated observations; observationCardinalityNext track the next cardinality the array of observations can expand to. Observations are stored in a fixed-length array that expands when a new observation is saved and observationCardinalityNext is greater than observationCardinality (which signals that cardinality can be expanded). If the array cannot be expanded (next cardinality value equals to the current one), oldest observations get overwritten, i.e. observation is stored at index 0, next one is stored at index 1, and so on.\nWhen pool is created, observationCardinality and observationCardinalityNext are set to 1:\n// src/UniswapV3Pool.sol contract UniswapV3Pool is IUniswapV3Pool { function initialize(uint160 sqrtPriceX96) public { ... (uint16 cardinality, uint16 cardinalityNext) = observations.initialize( _blockTimestamp() ); slot0 = Slot0({ sqrtPriceX96: sqrtPriceX96, tick: tick, observationIndex: 0, observationCardinality: cardinality, observationCardinalityNext: cardinalityNext }); } } // src/lib/Oracle.sol library Oracle { ... function initialize(Observation[65535] storage self, uint32 time) internal returns (uint16 cardinality, uint16 cardinalityNext) { self[0] = Observation({ timestamp: time, tickCumulative: 0, initialized: true }); cardinality = 1; cardinalityNext = 1; } ... } Writing Observations # In swap function, when current price is changed, an observation is written to the observations array:\n// src/UniswapV3Pool.sol contract UniswapV3Pool is IUniswapV3Pool { function swap(...) public returns (...) { ... if (state.tick != slot0_.tick) { ( uint16 observationIndex, uint16 observationCardinality ) = observations.write( slot0_.observationIndex, _blockTimestamp(), slot0_.tick, slot0_.observationCardinality, slot0_.observationCardinalityNext ); ( slot0.sqrtPriceX96, slot0.tick, slot0.observationIndex, slot0.observationCardinality ) = ( state.sqrtPriceX96, state.tick, observationIndex, observationCardinality ); } ... } } Notice that the tick that\u0026rsquo;s observed here is slot0_.tick (not state.stick), i.e. the price before the swap! It\u0026rsquo;s updated with a new price in the next statement. This is the price manipulation mitigation we discussed earlier: Uniswap tracks prices before the first trade in the block and after the last trade in the previous block.\nAlso notice that each observation is identified by _blockTimestamp(), i.e. the current block timestamp. This means that if there\u0026rsquo;s already an observation for the current block, a price is not recorded. If there are no observations for the current block (i.e. this is the first swap in the block), a price is recorded. This is part of the price manipulation mitigation mechanism.\n// src/lib/Oracle.sol function write( Observation[65535] storage self, uint16 index, uint32 timestamp, int24 tick, uint16 cardinality, uint16 cardinalityNext ) internal returns (uint16 indexUpdated, uint16 cardinalityUpdated) { Observation memory last = self[index]; if (last.timestamp == timestamp) return (index, cardinality); if (cardinalityNext \u0026gt; cardinality \u0026amp;\u0026amp; index == (cardinality - 1)) { cardinalityUpdated = cardinalityNext; } else { cardinalityUpdated = cardinality; } indexUpdated = (index + 1) % cardinalityUpdated; self[indexUpdated] = transform(last, timestamp, tick); } Here we see that an observation is skipped when there\u0026rsquo;s already an observation made at the current block. If there\u0026rsquo;s no such observation though, we\u0026rsquo;re saving a new one and trying to expand the cardinality when possible. The modulo operator (%) ensures that observation index stays within the range $[0, cardinality)$ and resets to 0 when the upper bound is reached.\nNow, let\u0026rsquo;s look at the transform function:\nfunction transform( Observation memory last, uint32 timestamp, int24 tick ) internal pure returns (Observation memory) { uint56 delta = timestamp - last.timestamp; return Observation({ timestamp: timestamp, tickCumulative: last.tickCumulative + int56(tick) * int56(delta), initialized: true }); } What we\u0026rsquo;re calculating here is the accumulated price: current tick gets multiplied by the number of the seconds since the last observation and gets added to the last accumulated price.\nIncrease of Cardinality # Let\u0026rsquo;s now see how cardinality is expanded.\nAnyone at any time can increase the cardinality of observations of a pool and pay for the gas required to do so. For this, we\u0026rsquo;ll add a new public function to Pool contract:\n// src/UniswapV3Pool.sol function increaseObservationCardinalityNext( uint16 observationCardinalityNext ) public { uint16 observationCardinalityNextOld = slot0.observationCardinalityNext; uint16 observationCardinalityNextNew = observations.grow( observationCardinalityNextOld, observationCardinalityNext ); if (observationCardinalityNextNew != observationCardinalityNextOld) { slot0.observationCardinalityNext = observationCardinalityNextNew; emit IncreaseObservationCardinalityNext( observationCardinalityNextOld, observationCardinalityNextNew ); } } And a new function to Oracle:\n// src/lib/Oracle.sol function grow( Observation[65535] storage self, uint16 current, uint16 next ) internal returns (uint16) { if (next \u0026lt;= current) return current; for (uint16 i = current; i \u0026lt; next; i++) { self[i].timestamp = 1; } return next; } In the grow function, we\u0026rsquo;re allocating new observations by setting the timestamp field of each of them to some non- zero value. Notice that self is a storage variable, assigning values to its elements will update the array counter and write the values to contract\u0026rsquo;s storage.\nReading Observations # We\u0026rsquo;ve finally come to the trickiest part of this chapter: reading of observations. Before moving on, let\u0026rsquo;s review how observations are stored to get a better picture.\nObservations are stored in a fixed-length array that can be expanded:\nAs we noted above, observations are expected to overflow: if a new observation doesn\u0026rsquo;t fit into the array, writing continues starting at index 0, i.e. oldest observations get overwritten:\nThere\u0026rsquo;s no guarantee that an observation will be stored for every block because swaps don\u0026rsquo;t happen in every block. Thus, there will be blocks we don\u0026rsquo;t know prices at, and such periods of missing observations can be long. Of course, we don\u0026rsquo;t want to have gaps in the prices reported by the oracle, and this is why we\u0026rsquo;re using time-weighted average prices (TWAP)–so we could have averaged prices in the periods where there were no observations. TWAP allows us to interpolate prices, i.e. to draw a line between two observations–each point on the line will be a price at a specific timestamp between the two observations.\nSo, reading observations means finding observations by timestamps and interpolating missing observations, taking into consideration that the observations array is allowed to overflow (e.g. the oldest observation can come after the most recent one in the array). Since we\u0026rsquo;re not indexing the observations by timestamps (to save gas), we\u0026rsquo;ll need to use the binary search algorithm to efficient search. But not always.\nLet\u0026rsquo;s break it down into smaller steps and begin by implementing observe function in Oracle:\nfunction observe( Observation[65535] storage self, uint32 time, uint32[] memory secondsAgos, int24 tick, uint16 index, uint16 cardinality ) internal view returns (int56[] memory tickCumulatives) { tickCumulatives = new int56[](secondsAgos.length); for (uint256 i = 0; i \u0026lt; secondsAgos.length; i++) { tickCumulatives[i] = observeSingle( self, time, secondsAgos[i], tick, index, cardinality ); } } The function takes current block timestamp, the list of time points we want to get prices at (secondsAgo), current tick, observations index, and cardinality.\nMoving to the observeSingle function:\nfunction observeSingle( Observation[65535] storage self, uint32 time, uint32 secondsAgo, int24 tick, uint16 index, uint16 cardinality ) internal view returns (int56 tickCumulative) { if (secondsAgo == 0) { Observation memory last = self[index]; if (last.timestamp != time) last = transform(last, time, tick); return last.tickCumulative; } ... } When most recent observation is requested (0 seconds passed), we can return it right away. If it wasn\u0026rsquo;t record in the current block, transform it to consider the current block and the current tick.\nIf an older time point is requested, we need to make several checks before switching to the binary search algorithm:\nif the requested time point is the last observation, we can return the accumulated price at the latest observation; if the requested time point is after the last observation, we can call transform to find the accumulated price at this point, knowing the last observed price and the current price; if the requested time point is before the last observation, we have to use the binary search. Let\u0026rsquo;s go straight to the third point:\nfunction binarySearch( Observation[65535] storage self, uint32 time, uint32 target, uint16 index, uint16 cardinality ) private view returns (Observation memory beforeOrAt, Observation memory atOrAfter) { ... The function takes the current block timestamp (time), the timestamp of the price point requested (target), as well as the current observations index and cardinality. It returns the range between two observations in which the requested time point is located.\nTo initialize the binary search algorithm, we set the boundaries:\nuint256 l = (index + 1) % cardinality; // oldest observation uint256 r = l + cardinality - 1; // newest observation uint256 i; Recall that the observations array is expected to overflow, that\u0026rsquo;s why we\u0026rsquo;re using the modulo operator here.\nThen we spin up an infinite loop, in which we check the middle point of the range: if it\u0026rsquo;s not initialized (there\u0026rsquo;s no observation), we\u0026rsquo;re continuing with the next point:\nwhile (true) { i = (l + r) / 2; beforeOrAt = self[i % cardinality]; if (!beforeOrAt.initialized) { l = i + 1; continue; } ... If the point is initialized, we call it the left boundary of the range we want the requested time point to be included in. And we\u0026rsquo;re trying to find the right boundary (atOrAfter):\n... atOrAfter = self[(i + 1) % cardinality]; bool targetAtOrAfter = lte(time, beforeOrAt.timestamp, target); if (targetAtOrAfter \u0026amp;\u0026amp; lte(time, target, atOrAfter.timestamp)) break; ... If we\u0026rsquo;ve found the boundaries, we return them. If not, we continue our search:\n... if (!targetAtOrAfter) r = i - 1; else l = i + 1; } After finding a range of observations the requested time point belongs to, we need to calculate the price at the requested time point:\n// function observeSingle() { ... uint56 observationTimeDelta = atOrAfter.timestamp - beforeOrAt.timestamp; uint56 targetDelta = target - beforeOrAt.timestamp; return beforeOrAt.tickCumulative + ((atOrAfter.tickCumulative - beforeOrAt.tickCumulative) / int56(observationTimeDelta)) * int56(targetDelta); ... This is as simple as finding the average rate of change within the range and multiplying it by the number of seconds that has passed between the lower bound of the range and the time point we need. This is the interpolation we discussed earlier.\nThe last thing we need to implement here is a public function in Pool contract that reads and returns observations:\n// src/UniswapV3Pool.sol function observe(uint32[] calldata secondsAgos) public view returns (int56[] memory tickCumulatives) { return observations.observe( _blockTimestamp(), secondsAgos, slot0.tick, slot0.observationIndex, slot0.observationCardinality ); } Interpreting Observations # Let\u0026rsquo;s now see how to interpret observations.\nThe observe function we just added returns an array of accumulated prices, and we want to know how to convert them to actual prices. I\u0026rsquo;ll demonstrate this in a test of the observe function.\nIn the test, I run multiple swaps in different directions and at different blocks:\nfunction testObserve() public { ... pool.increaseObservationCardinalityNext(3); vm.warp(2); pool.swap(address(this), false, swapAmount, sqrtP(6000), extra); vm.warp(7); pool.swap(address(this), true, swapAmount2, sqrtP(4000), extra); vm.warp(20); pool.swap(address(this), false, swapAmount, sqrtP(6000), extra); ... vm.warp is a cheat-code provided by Foundry: it forwards to a block with the specified timestamp. 2, 7, 20 – these are block timestamps.\nThe first swap is made at the block with timestamp 2, the second one is made at timestamp 7, and the third one is made at timestamp 20. We can then read the observations:\n... secondsAgos = new uint32[](4); secondsAgos[0] = 0; secondsAgos[1] = 13; secondsAgos[2] = 17; secondsAgos[3] = 18; int56[] memory tickCumulatives = pool.observe(secondsAgos); assertEq(tickCumulatives[0], 1607059); assertEq(tickCumulatives[1], 511146); assertEq(tickCumulatives[2], 170370); assertEq(tickCumulatives[3], 85176); ... The earliest observed price is 0, which is the initial observation that\u0026rsquo;s set when the pool is deployed. However, since the cardinality was set to 3 and we made 3 swaps, it was overwritten by the last observation. During the first swap, tick 85176 was observed, which is the initial price of the pool–recall that the price before a swap is observed. Because the very first observation was overwritten, this is the oldest observation now. Next returned accumulated price is 170370, which is 85176 + 85194. The former is the previous accumulator value, the latter is the price after the first swap that was observed during the second swap. Next returned accumulated price is 511146, which is (511146 - 170370) / (17 - 13) = 85194, the accumulated price between the second and the third swap. Finally, the most recent observation is 1607059, which is (1607059 - 511146) / (20 - 7) = 84301, which is ~4581 USDC/ETH, the price after the second swap that was observed during the third swap. And here\u0026rsquo;s an example that involves interpolation: the time points requested are not the time points of the swaps:\nsecondsAgos = new uint32[](5); secondsAgos[0] = 0; secondsAgos[1] = 5; secondsAgos[2] = 10; secondsAgos[3] = 15; secondsAgos[4] = 18; tickCumulatives = pool.observe(secondsAgos); assertEq(tickCumulatives[0], 1607059); assertEq(tickCumulatives[1], 1185554); assertEq(tickCumulatives[2], 764049); assertEq(tickCumulatives[3], 340758); assertEq(tickCumulatives[4], 85176); This results in prices: 4581.03, 4581.03, 4747.6, 5008.91, which are the average prices within the requested intervals.\nHere\u0026rsquo;s how to compute those values in Python:\nvals = [1607059, 1185554, 764049, 340758, 85176] secs = [0, 5, 10, 15, 18] [1.0001**((vals[i] - vals[i+1]) / (secs[i+1] - secs[i])) for i in range(len(vals)-1)] "},{"id":31,"href":"/docs/milestone_4/user-interface/","title":"User Interface","section":"Milestone 4. Multi-pool Swaps","content":" User Interface # After introducing swap paths, we can significantly simplify the internals of our web app. First of all, every swap now uses a path since path doesn\u0026rsquo;t have to contain multiple pools. Second, it\u0026rsquo;s now easier to change the direction of swap: we can simply reverse the path. And, thanks to the unified pool address generation via CREATE2 and unique salts, we no longer need to store pool addresses and care about tokens order.\nHowever, we cannot integrate multi-pool swaps in the web app without adding one crucial algorithm. Ask yourself the question: \u0026ldquo;How to find a path between two tokens that don\u0026rsquo;t have a pool?\u0026rdquo;\nAutoRouter # Uniswap implements what\u0026rsquo;s called AutoRouter, an algorithm that find shortest path between two tokens. Moreover, it also splits one payment into multiple smaller payments to find the best average exchange rate. The profit can be as big as 36.84% compared to trades that are not split. This sounds great, however, we\u0026rsquo;re not going to build such an advanced algorithm. Instead, we\u0026rsquo;ll build something simpler.\nA Simple Router Design # Suppose we have a whole bunch of pools:\nHow do we find a shortest path between two tokens in such a mess?\nThe most suitable solution for such kind of tasks is based on a graph. A graph is a data structure that consists of nodes (objects representing something) and edges (links connecting nodes). We can turn that mess of pools into a graph where each node is a token (that has a pool) and each edge is a pool this token belongs to. So a pool represented as a graph is two nodes connected with an edge. And the above pools become this graph:\nThe biggest advantage graphs give us is the ability to traverse its nods, from one node to another, to find paths. Specifically, we\u0026rsquo;ll use A* search algorithm. Feel free learning about how the algorithm works, but, in our app, we\u0026rsquo;ll use a library to make our life easier. The set of libraries we\u0026rsquo;ll use is: ngraph.ngraph for building graphs and ngraph.path for finding paths (it\u0026rsquo;s the latter that implements A* search algorithm, as well as some others).\nIn the UI app, let\u0026rsquo;s create a path finder. This will be a class that, when instantiated, turns a list of pairs into a graph to later use the graph to find a shortest path between two tokens.\nimport createGraph from \u0026#39;ngraph.graph\u0026#39;; import path from \u0026#39;ngraph.path\u0026#39;; class PathFinder { constructor(pairs) { this.graph = createGraph(); pairs.forEach((pair) =\u0026gt; { this.graph.addNode(pair.token0.address); this.graph.addNode(pair.token1.address); this.graph.addLink(pair.token0.address, pair.token1.address, pair.tickSpacing); this.graph.addLink(pair.token1.address, pair.token0.address, pair.tickSpacing); }); this.finder = path.aStar(this.graph); } ... In the constructor, we\u0026rsquo;re creating an empty graph and fill it with linked nodes. Each node is a token address and links have associated data, which is tick spacings–we\u0026rsquo;ll be able to extract this information from paths found by A*. After initializing a graph, we instantiate A* algorithm implementation.\nNext, we need to implement a function that will find a path between tokens and turn it into an array of token addresses and tick spacings:\nfindPath(fromToken, toToken) { return this.finder.find(fromToken, toToken).reduce((acc, node, i, orig) =\u0026gt; { if (acc.length \u0026gt; 0) { acc.push(this.graph.getLink(orig[i - 1].id, node.id).data); } acc.push(node.id); return acc; }, []).reverse(); } this.finder.find(fromToken, toToken) returns a list of nodes and, unfortunately, doesn\u0026rsquo;t contain the information about edges between them (we store tick spacings in edges). Thus, we\u0026rsquo;re calling this.graph.getLink(previousNode, currentNode) to find edges.\nNow, whenever user changes input or output token, we can call pathFinder.findPath(token0, token1) to build a new path.\n"},{"id":32,"href":"/docs/milestone_1/manager-contract/","title":"管理合约","section":"Milestone 1. 第一笔交易","content":" 管理合约(Manager Contract) # 在部署我们的池子合约之前，仍然有一个问题需要解决。我们之前提到过，Uniswap V3合约由两部分构成：\n核心合约(core contracts)实现了最核心的功能，不提供用户友好的交互接口 外围合约(periphery contracts)为核心合约实现了用户友好的接口 池子合约是核心合约，它并不需要用户友好或者实现灵活功能。它需要调用者进行所有的计算并且提供合适的参数。同时，它也没有使用ERC20的transferFrom函数来从调用者处转账，而是使用了两个callback函数：\nuniswapV3MintCallback，当铸造流动性的时候被调用 uniswapV3SwapCallback，当交易token的时候被调用 在我们的测试中，我们在测试合约中实现了这些函数。由于只有合约才能实现callback函数，池子合约并不能直接被普通用户(EOA)调用。这对核心合约是没问题的，但是我们接下来会解决它🙂。\n我们下一步的目标是将这个池子合约部署在一个本地的区块链上，并且使用一个前端应用与其交互。因此我们需要创建一个合约，能够让非合约的地址也与池子进行交互。让我们来实现吧！\n工作流程 # 下面我们描述了管理合约的功能：\n为了铸造流动性，我们需要approve对应的token给管理合约。 我们会调用管理合约的mint函数来铸造流动性，参数为铸造需要的参数以及池子的合约地址 管理合约会调用池子的mint函数，并且会实现uniswapV3MintCallback。由于我们之前的approve，管理合约会从我们的账户中把token转到池子合约 为了交易token，我们也需要approve对应的token 我们会调用管理合约的swap函数，并且与mint过程类似，它会调用池子合约的对应函数。管理者合约会把我们的token转到赤字中，池子进行对应的交易，然后把得到的token发回给我们。 综上，管理合约主要作为用户和池子之间的中介来运行。\n向callback传递数据 # 在实现管理合约之前，我们还需要更新我们的池子合约。\n管理者合约需要能够与任何一个流动性池适配，并且能够允许任何地址调用它。为了达到这一点，我们需要对callback进行升级：我们需要将池子的地址和用户的地址作为参数传递。下面是我们对于uniswapV3MintCallback的之前的实现（测试合约中的）：\nfunction uniswapV3MintCallback(uint256 amount0, uint256 amount1) public { if (transferInMintCallback) { token0.transfer(msg.sender, amount0); token1.transfer(msg.sender, amount1); } } 关键点：\n这个函数转移的token是属于这个测试合约的——而我们希望使用transferFrom来从管理合约的调用者出转出token 这个函数需要知道token0和token1，但这两个变量会随着不同池子而变化。 想法：我们需要改变callback的参数，来将用户和池子的合约地址传进去\n接下来看一下swap的callback：\nfunction uniswapV3SwapCallback(int256 amount0, int256 amount1) public { if (amount0 \u0026gt; 0 \u0026amp;\u0026amp; transferInSwapCallback) { token0.transfer(msg.sender, uint256(amount0)); } if (amount1 \u0026gt; 0 \u0026amp;\u0026amp; transferInSwapCallback) { token1.transfer(msg.sender, uint256(amount1)); } } 同样，它从测试合约处转钱，并且已知token0和token1。\n为了将这些参数传递给callback，我们需要首先将它们传递给mint和swap函数（因为callback函数是被这两个函数调用的）。然而，由于这些额外的数据并不会被上述两个函数本身使用，为了避免参数的混淆，我们会使用abi.encode()来编码这些参数。\n定义一下这些额外数据的结构：\n// src/UniswapV3Pool.sol ... struct CallbackData { address token0; address token1; address payer; } ... 接下来把编码后的数据传入callback：\nfunction mint( address owner, int24 lowerTick, int24 upperTick, uint128 amount, bytes calldata data // \u0026lt;--- New line ) external returns (uint256 amount0, uint256 amount1) { ... IUniswapV3MintCallback(msg.sender).uniswapV3MintCallback( amount0, amount1, data // \u0026lt;--- New line ); ... } function swap(address recipient, bytes calldata data) // \u0026lt;--- `data` added public returns (int256 amount0, int256 amount1) { ... IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback( amount0, amount1, data // \u0026lt;--- New line ); ... } 现在，我们可以在测试合约的callback函数中解析对应的数据：\nfunction uniswapV3MintCallback( uint256 amount0, uint256 amount1, bytes calldata data ) public { if (transferInMintCallback) { UniswapV3Pool.CallbackData memory extra = abi.decode( data, (UniswapV3Pool.CallbackData) ); IERC20(extra.token0).transferFrom(extra.payer, msg.sender, amount0); IERC20(extra.token1).transferFrom(extra.payer, msg.sender, amount1); } } 尝试自己动手更新代码的其余部分。如果觉得有困难，可以参考此处\n实现管理合约 # 除了实现callback函数之外，管理合约其实没什么别的功能：它仅仅是把调用重新指向池子合约。这个管理合约现在还非常非常简单：\npragma solidity ^0.8.14; import \u0026#34;../src/UniswapV3Pool.sol\u0026#34;; import \u0026#34;../src/interfaces/IERC20.sol\u0026#34;; contract UniswapV3Manager { function mint( address poolAddress_, int24 lowerTick, int24 upperTick, uint128 liquidity, bytes calldata data ) public { UniswapV3Pool(poolAddress_).mint( msg.sender, lowerTick, upperTick, liquidity, data ); } function swap(address poolAddress_, bytes calldata data) public { UniswapV3Pool(poolAddress_).swap(msg.sender, data); } function uniswapV3MintCallback(...) {...} function uniswapV3SwapCallback(...) {...} } callback函数与上述测试合约中的相同，除了没有transferInMintCallback和transferInSwapCallback这两个flag，因为管理合约总会转钱。\n现在，我们已经彻底完成了，可以准备部署和进行前端交互了！\n"},{"id":33,"href":"/docs/milestone_2/generalize-minting/","title":"通用mint","section":"Milestone 2. 第二笔交易","content":" \\[ \\] 通用mint # 现在，我们可以更新mint函数来直接在Solidity中进行计算而不需要手动计算并硬编码了。\n初始化tick与更新 # 还记得在mint函数中，我们更新TickInfo这个mapping来存储tick中可用的流动性信息。现在，我们将会使用新的bitmap索引来进行这一步——我们之后会用这个新的索引来在交易中寻找下一个可用tick。\n首先，我们需要更新Tick.update函数：\n// src/lib/Tick.sol function update( mapping(int24 =\u0026gt; Tick.Info) storage self, int24 tick, uint128 liquidityDelta ) internal returns (bool flipped) { ... flipped = (liquidityAfter == 0) != (liquidityBefore == 0); ... } 现在，它会返回一个flipped flag，当流动性被添加到一个空的tick或整个tick的流动性被耗尽时为true。\n接下来，在mint函数中，我们更新bitmao索引：\n// src/UniswapV3Pool.sol ... bool flippedLower = ticks.update(lowerTick, amount); bool flippedUpper = ticks.update(upperTick, amount); if (flippedLower) { tickBitmap.flipTick(lowerTick, 1); } if (flippedUpper) { tickBitmap.flipTick(upperTick, 1); } ... 再次说明，在Milestone 4之前，TickSpacing参数的值会始终为1.\nToken数量计算 # mint函数中最大的变化就是token数量的计算。在milestone 1中，我们硬编码了这些值：\namount0 = 0.998976618347425280 ether; amount1 = 5000 ether; 现在，我们将使用milestone 1中同样的公式，在Solidity中计算它。回顾一下这些公式：\n$$\\Delta x = \\frac{L(\\sqrt{p(i_u)} - \\sqrt{p(i_c)})}{\\sqrt{p(i_u)}\\sqrt{p(i_c)}}$$ $$\\Delta y = L(\\sqrt{p(i_c)} - \\sqrt{p(i_l)})$$\n$\\Delta x$ 代表 token0 的数量, 即 token $x$。让我们在Solidity中进行实现：\n// src/lib/Math.sol function calcAmount0Delta( uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint128 liquidity ) internal pure returns (uint256 amount0) { if (sqrtPriceAX96 \u0026gt; sqrtPriceBX96) (sqrtPriceAX96, sqrtPriceBX96) = (sqrtPriceBX96, sqrtPriceAX96); require(sqrtPriceAX96 \u0026gt; 0); amount0 = divRoundingUp( mulDivRoundingUp( (uint256(liquidity) \u0026lt;\u0026lt; FixedPoint96.RESOLUTION), (sqrtPriceBX96 - sqrtPriceAX96), sqrtPriceBX96 ), sqrtPriceAX96 ); } 这个函数的功能与Python脚本中的calc_amount0一致。\n第一步是将两个价格排序来保证减法时不会溢出。接下来，我们将liquidity转换成Q96.64格式的数字，只需要乘以 2**96。下一步，根据公式，我们将其乘以价格之差并除以两个价格（先除以大的，再除以小的）。两个除法的顺序并不重要，但是我们的除法要分两步进行，因为分母的惩罚可能会导致溢出。\n我们使用了 mulDivRoundingUp 函数来在一步中进行乘除。这个函数是基于 PRBMath 库中的 mulDiv：\nfunction mulDivRoundingUp( uint256 a, uint256 b, uint256 denominator ) internal pure returns (uint256 result) { result = PRBMath.mulDiv(a, b, denominator); if (mulmod(a, b, denominator) \u0026gt; 0) { require(result \u0026lt; type(uint256).max); result++; } } mulmod 是Solidity的一个函数，将两个数a和b相乘，乘积除以denominator，返回余数。如果余数为正，我们将结果上取整。\n接下来是 $\\Delta y$：\nfunction calcAmount1Delta( uint160 sqrtPriceAX96, uint160 sqrtPriceBX96, uint128 liquidity ) internal pure returns (uint256 amount1) { if (sqrtPriceAX96 \u0026gt; sqrtPriceBX96) (sqrtPriceAX96, sqrtPriceBX96) = (sqrtPriceBX96, sqrtPriceAX96); amount1 = mulDivRoundingUp( liquidity, (sqrtPriceBX96 - sqrtPriceAX96), FixedPoint96.Q96 ); } 这个函数与Python脚本中的calc_amount1一致。\n同样我们使用mulDivRoundingUp来防止乘法过程中的溢出。\n现在它们都完成了！我们现在可以使用这些函数来计算token数量了：\n// src/UniswapV3Pool.sol function mint(...) { ... Slot0 memory slot0_ = slot0; amount0 = Math.calcAmount0Delta( slot0_.sqrtPriceX96, TickMath.getSqrtRatioAtTick(upperTick), amount ); amount1 = Math.calcAmount1Delta( slot0_.sqrtPriceX96, TickMath.getSqrtRatioAtTick(lowerTick), amount ); ... } 其余的一切都保持不变。测试脚本中的数字需要更新，因为取整的缘故会与我们一开始手动计算的略有不同。\n"},{"id":34,"href":"/docs/milestone_3/more-on-fixed-point-numbers/","title":"A Little Bit More on Fixed-point Numbers","section":"Milestone 3. 跨tick交易","content":" \\[ \\] A Little Bit More on Fixed-point Numbers # In this bonus chapter, I\u0026rsquo;d like to show you how to convert prices to ticks in Solidity. We don\u0026rsquo;t need to do this in the main contracts, but it\u0026rsquo;s helpful to have such function in tests so we don\u0026rsquo;t hardcode ticks and could write something like tick(5000)–this makes code easier to read because it\u0026rsquo;s more convenient for us to think in prices, not tick indexes.\nRecall that, to find ticks, we use TickMath.getTickAtSqrtRatio function, which takes $\\sqrt{P}$ as its argument, and the $\\sqrt{P}$ is a Q64.96 fixed-point number. In smart contract tests, we need to check $\\sqrt{P}$ many times in many different test cases: mostly after mints and swaps. Instead of hard coding actual values, it might be cleaner to use a helper function like sqrtP(5000) that converts prices to $\\sqrt{P}$.\nSo, what\u0026rsquo;s the problem?\nThe problem is that Solidity doesn\u0026rsquo;t natively support the square root operation, which means we need a third-party library. Another problem is that prices are often relatively small numbers, like 10, 5000, 0.01, etc., and we don\u0026rsquo;t want to lose precision when taking square root.\nYou probably remember that we used PRBMath earlier in the book to implement multiply-then-divide operation that doesn\u0026rsquo;t overflow during multiplication. If you check PRBMath.sol contract, you\u0026rsquo;ll notice sqrt function. However, the function doesn\u0026rsquo;t support fixed-point numbers, as the function description says. You can give it a try and see that PRBMath.sqrt(5000) results in 70, which is an integer number with lost precision (without the fractional part).\nIf you check prb-math repo, you\u0026rsquo;ll see these contracts: PRBMathSD59x18.sol and PRBMathUD60x18.sol. Aha! These are fixed-point number implementations. Let\u0026rsquo;s pick the latter and see how it goes: PRBMathUD60x18.sqrt(5000 * PRBMathUD60x18.SCALE) returns 70710678118654752440. This looks interesting! PRBMathUD60x18 is a library that implements fixed-numbers with 18 decimal places in the fractional part. So the number we got is actually 70.710678118654752440 (use cast --from-wei 70710678118654752440).\nHowever, we cannot use this number!\nThere are fixed-point numbers and fixed-point numbers. The Q64.96 fixed-point number used by Uniswap V3 is a binary number–64 and 96 signify binary places. But PRBMathUD60x18 implements a decimal fixed-point number (UD in the contract name means \u0026ldquo;unsigned, decimal\u0026rdquo;), where 60 and 18 signify decimal places. This difference is quite significant.\nLet\u0026rsquo;s see how to convert an arbitrary number (42) to either of the above fixed-point numbers:\nQ64.96: $42 * 2^{96}$ or, using bitwise left shift, 2 \u0026lt;\u0026lt; 96. The result is 3327582825599102178928845914112. UD60.18: $42 * 10^{18}$. The result is 42000000000000000000. Let\u0026rsquo;s now see how to convert numbers with the fractional part (42.1337):\nQ64.96: $421337 * 2^{92}$ or 421337 \u0026lt;\u0026lt; 92. The result is 2086359769329537075540689212669952. UD60.18: $421337 * 10^{14}$. The result is 42133700000000000000. The second variant makes more sense to us because it uses the decimal system, which we learned in our childhood. The first variant uses the binary system and it\u0026rsquo;s much harder for us to read.\nBut the biggest problem with different variants is that it\u0026rsquo;s hard to convert between them.\nThis all means that we need a different library, one that implements a binary fixed-point number and sqrt function for it. Luckily, there\u0026rsquo;s such library: abdk-libraries-solidity. The library implemented Q64.64, not exactly what we need (not 96 bits in the fractional part) but this is not a problem.\nHere\u0026rsquo;s how we can implement the price-to-tick function using the new library:\nfunction tick(uint256 price) internal pure returns (int24 tick_) { tick_ = TickMath.getTickAtSqrtRatio( uint160( int160( ABDKMath64x64.sqrt(int128(int256(price \u0026lt;\u0026lt; 64))) \u0026lt;\u0026lt; (FixedPoint96.RESOLUTION - 64) ) ) ); } ABDKMath64x64.sqrt takes Q64.64 numbers so we need to convert price to such number. The price is expected to not have the fractional part, so we\u0026rsquo;re shifting it by 64 bits. The sqrt function also returns a Q64.64 number but TickMath.getTickAtSqrtRatio takes a Q64.96 number–this is why we need to shift the result of the square root operation by 96 - 64 bits to the left.\n"},{"id":35,"href":"/docs/milestone_4/tick-rounding/","title":"Tick Rounding","section":"Milestone 4. Multi-pool Swaps","content":" \\[ \\] Tick Rounding # Let\u0026rsquo;s review some other changes we need to make to support different tick spacings.\nTick spacing greater than 1 won\u0026rsquo;t allow users to select arbitrary price ranges: tick indexes must be multiples of a tick spacing. For example, for tick spacing 60 we can have ticks: 0, 60, 120, 180, etc. Thus, when user picks a range, we need to \u0026ldquo;round\u0026rdquo; it so its boundaries are multiples of pool\u0026rsquo;s tick spacing.\nnearestUsableTick in JavaScript # In the Uniswap V3 SDK, the function that does that is called nearestUsableTick:\n/** * Returns the closest tick that is nearest a given tick and usable for the given tick spacing * @param tick the target tick * @param tickSpacing the spacing of the pool */ export function nearestUsableTick(tick: number, tickSpacing: number) { invariant(Number.isInteger(tick) \u0026amp;\u0026amp; Number.isInteger(tickSpacing), \u0026#39;INTEGERS\u0026#39;) invariant(tickSpacing \u0026gt; 0, \u0026#39;TICK_SPACING\u0026#39;) invariant(tick \u0026gt;= TickMath.MIN_TICK \u0026amp;\u0026amp; tick \u0026lt;= TickMath.MAX_TICK, \u0026#39;TICK_BOUND\u0026#39;) const rounded = Math.round(tick / tickSpacing) * tickSpacing if (rounded \u0026lt; TickMath.MIN_TICK) return rounded + tickSpacing else if (rounded \u0026gt; TickMath.MAX_TICK) return rounded - tickSpacing else return rounded } At its core, it\u0026rsquo;s just:\nMath.round(tick / tickSpacing) * tickSpacing Where Math.round is rounding to the nearest integer: when the fractional part is less than 0.5, it rounds to the lower integer; when it\u0026rsquo;s greater than 0.5 it rounds to the greater integer; and when it\u0026rsquo;s 0.5, it rounds to the greater integer as well.\nSo, in the web app, we\u0026rsquo;ll use nearestUsableTick when building mint parameters:\nconst mintParams = { tokenA: pair.token0.address, tokenB: pair.token1.address, tickSpacing: pair.tickSpacing, lowerTick: nearestUsableTick(lowerTick, pair.tickSpacing), upperTick: nearestUsableTick(upperTick, pair.tickSpacing), amount0Desired, amount1Desired, amount0Min, amount1Min } In reality, it should be called whenever user adjusts a price range because we want the user to see the actual price that will be created. In our simplified app, we do it less user-friendly.\nHowever, we also want to have a similar function in Solidity tests, but neither of the math libraries we\u0026rsquo;re using implements it.\nnearestUsableTick in Solidity # In our smart contract tests, we need a way to round ticks and convert rounded prices to sqrtP. In a previous chapter, we chose to use ABDKMath64x64 to handle fixed-point numbers math in tests. The library, however, doesn\u0026rsquo;t implement the rounding function we need to port nearestUsableTick, so we\u0026rsquo;ll need to implement it ourselves:\nfunction divRound(int128 x, int128 y) internal pure returns (int128 result) { int128 quot = ABDKMath64x64.div(x, y); result = quot \u0026gt;\u0026gt; 64; // Check if remainder is greater than 0.5 if (quot % 2**64 \u0026gt;= 0x8000000000000000) { result += 1; } } The function does multiple things:\nit divides two Q64.64 numbers; it then rounds the result to the decimal one (result = quot \u0026gt;\u0026gt; 64), the fractional part is lost at this point (i.e. the result is rounded down); it then divides the quotient by $2^{64}$, takes the remainder, and compares it with 0x8000000000000000 (which is 0.5 in Q64.64); if the remainder is greater or equal to 0.5, it rounds the result to the greater integer. What we get is an integer rounded according to the rules of Math.round from JavaScript. We can then re-implement nearestUsableTick:\nfunction nearestUsableTick(int24 tick_, uint24 tickSpacing) internal pure returns (int24 result) { result = int24(divRound(int128(tick_), int128(int24(tickSpacing)))) * int24(tickSpacing); if (result \u0026lt; TickMath.MIN_TICK) { result += int24(tickSpacing); } else if (result \u0026gt; TickMath.MAX_TICK) { result -= int24(tickSpacing); } } That\u0026rsquo;s it!\n"},{"id":36,"href":"/docs/milestone_5/user-interface/","title":"User Interface","section":"Milestone 5. Fees and Price Oracle","content":" User Interface # In this milestone, we\u0026rsquo;ve added the ability to remove liquidity from a pool and collect accumulated fees. Thus, we need to reflect these changes in the user interface to allow users to remove liquidity.\nFetching Positions # To let user choose how much liquidity to remove, we first need to fetch user\u0026rsquo;s positions from a pool. To makes this easier, we can add a helper function to the Manager contract, which will return user position in a specific pool:\nfunction getPosition(GetPositionParams calldata params) public view returns ( uint128 liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, uint128 tokensOwed0, uint128 tokensOwed1 ) { IUniswapV3Pool pool = getPool(params.tokenA, params.tokenB, params.fee); ( liquidity, feeGrowthInside0LastX128, feeGrowthInside1LastX128, tokensOwed0, tokensOwed1 ) = pool.positions( keccak256( abi.encodePacked( params.owner, params.lowerTick, params.upperTick ) ) ); } This will free us from calculating a pool address and a position key on the front end.\nThen, after user typed in a position range, we can try fetching a position:\nconst getAvailableLiquidity = debounce((amount, isLower) =\u0026gt; { const lowerTick = priceToTick(isLower ? amount : lowerPrice); const upperTick = priceToTick(isLower ? upperPrice : amount); const params = { tokenA: token0.address, tokenB: token1.address, fee: fee, owner: account, lowerTick: nearestUsableTick(lowerTick, feeToSpacing[fee]), upperTick: nearestUsableTick(upperTick, feeToSpacing[fee]), } manager.getPosition(params) .then(position =\u0026gt; setAvailableAmount(position.liquidity.toString())) .catch(err =\u0026gt; console.error(err)); }, 500); Getting Pool Address # Since we need to call burn and collect on a pool, we still need to compute pool\u0026rsquo;s address on the front end. Recall that pool addresses are compute using the CREATE2 opcode, which requires a salt and the hash of contract\u0026rsquo;s code. Luckily, Ether.js has getCreate2Address function that allows to compute CREATE2 in JavaScript:\nconst sortTokens = (tokenA, tokenB) =\u0026gt; { return tokenA.toLowerCase() \u0026lt; tokenB.toLowerCase ? [tokenA, tokenB] : [tokenB, tokenA]; } const computePoolAddress = (factory, tokenA, tokenB, fee) =\u0026gt; { [tokenA, tokenB] = sortTokens(tokenA, tokenB); return ethers.utils.getCreate2Address( factory, ethers.utils.keccak256( ethers.utils.solidityPack( [\u0026#39;address\u0026#39;, \u0026#39;address\u0026#39;, \u0026#39;uint24\u0026#39;], [tokenA, tokenB, fee] )), poolCodeHash ); } However, pool\u0026rsquo;s codehash has to be hard coded because we don\u0026rsquo;t want to store its code on the front end to calculate the hash. So, we\u0026rsquo;ll use Forge to get the hash:\n$ forge inspect UniswapV3Pool bytecode| xargs cast keccak 0x... And then use the output value in a JS constant:\nconst poolCodeHash = \u0026#34;0x9dc805423bd1664a6a73b31955de538c338bac1f5c61beb8f4635be5032076a2\u0026#34;; Removing Liquidity # After obtaining liquidity amount and pool address, we\u0026rsquo;re ready to call burn:\nconst removeLiquidity = (e) =\u0026gt; { e.preventDefault(); if (!token0 || !token1) { return; } setLoading(true); const lowerTick = nearestUsableTick(priceToTick(lowerPrice), feeToSpacing[fee]); const upperTick = nearestUsableTick(priceToTick(upperPrice), feeToSpacing[fee]); pool.burn(lowerTick, upperTick, amount) .then(tx =\u0026gt; tx.wait()) .then(receipt =\u0026gt; { if (!receipt.events[0] || receipt.events[0].event !== \u0026#34;Burn\u0026#34;) { throw Error(\u0026#34;Missing Burn event after burning!\u0026#34;); } const amount0Burned = receipt.events[0].args.amount0; const amount1Burned = receipt.events[0].args.amount1; return pool.collect(account, lowerTick, upperTick, amount0Burned, amount1Burned) }) .then(tx =\u0026gt; tx.wait()) .then(() =\u0026gt; toggle()) .catch(err =\u0026gt; console.error(err)); } If burning was successful, we immediately call collect to collect the token amounts that were freed during burning.\n"},{"id":37,"href":"/docs/milestone_2/generalize-swapping/","title":"通用swap","section":"Milestone 2. 第二笔交易","content":" \\[ \\] 通用swap # 本节将会是这个milestone中最难的一个部分。在更新代码之前，我们首先需要知道Uniswap V3中的swap是如何工作的。\n我们可以把一笔交易看作是满足一个订单：一个用户提交了一个订单，需要从池子中购买一定数量的某种token。池子会使用可用的流动性来将投入的token数量“转换”成输出的token数量。如果在当前价格区间中没有足够的流动性，它将会尝试在其他价格区间中寻找流动性（使用我们前一节实现的函数）。\n现在，我们要实现swap函数内部的逻辑，但仍然保证交易可以在当前价格区间内完成——跨tick的交易将会在下一个milestone中实现。\nfunction swap( address recipient, bool zeroForOne, uint256 amountSpecified, bytes calldata data ) public returns (int256 amount0, int256 amount1) { ... 在swap函数中，我们新增了两个参数：zeroForOne 和 amountSpecified。zeroForOne 是用来控制交易方向的 flag：当设置为true，是用 token0 兑换 token1；false则相反。例如，如果token0 是ETH，token1 是USDC，将 zeroForOne 设置为true意味着用 USDC 购买 ETH。amountSpecified 是用户希望卖出的token数量。\n填满订单 # 由于在Uniswap V3中，流动性存储在不同的价格区间中，池子合约需要找到“填满当前订单”所需要的所有流动性。这个操作是通过沿着某个方向遍历所有初始化的tick来实现的。\n在继续之前，我们需要定义两个新的结构体：\nstruct SwapState { uint256 amountSpecifiedRemaining; uint256 amountCalculated; uint160 sqrtPriceX96; int24 tick; } struct StepState { uint160 sqrtPriceStartX96; int24 nextTick; uint160 sqrtPriceNextX96; uint256 amountIn; uint256 amountOut; } SwapState 维护了当前swap的状态。amoutSpecifiedRemaining 跟踪了还需要从池子中获取的token数量：当这个数量为0时，这笔订单就被填满了。amountCalculated 是由合约计算出的输出数量。sqrtPriceX96 和 tick 是交易结束后的价格和tick。\nStepState 维护了当前交易“一步”的状态。这个结构体跟踪“填满订单”过程中一个循环的状态。sqrtPriceStartX96 跟踪循环开始时的价格。nextTick 是能够为交易提供流动性的下一个已初始化的tick，sqrtPriceNextX96 是下一个tick 的价格。amountIn 和 amountOut 是当前循环中流动性能够提供的数量。\n在我们实现跨tick的交易后（也即不发生在一个价格区间中的交易），关于循环方面会有更清晰的了解\n// src/UniswapV3Pool.sol function swap(...) { Slot0 memory slot0_ = slot0; SwapState memory state = SwapState({ amountSpecifiedRemaining: amountSpecified, amountCalculated: 0, sqrtPriceX96: slot0_.sqrtPriceX96, tick: slot0_.tick }); ... 在填满一个订单之前，我们首先初始化 SwapState 的实例。我们将会循环直到 amoutSpecified 变成0，也即池子拥有足够的流动性来买用户的 amountSpecified 数量的token。\n... while (state.amountSpecifiedRemaining \u0026gt; 0) { StepState memory step; step.sqrtPriceStartX96 = state.sqrtPriceX96; (step.nextTick, ) = tickBitmap.nextInitializedTickWithinOneWord( state.tick, 1, zeroForOne ); step.sqrtPriceNextX96 = TickMath.getSqrtRatioAtTick(step.nextTick); 在循环中，我们设置一个价格区间为这笔交易提供流动性的价格区间。这个区间是从 state.sqrtPriceX96 到 step.sqrtPriceNextX96，后者是下一个初始化的tick对应的价格（从上一章实现的nextInitializedTickWithinOneWord 中获取）。\n(state.sqrtPriceX96, step.amountIn, step.amountOut) = SwapMath .computeSwapStep( state.sqrtPriceX96, step.sqrtPriceNextX96, liquidity, state.amountSpecifiedRemaining ); 接下来，我们计算当前价格区间能够提供的流动性的数量，以及交易达到的目标价格。\nstate.amountSpecifiedRemaining -= step.amountIn; state.amountCalculated += step.amountOut; state.tick = TickMath.getTickAtSqrtRatio(state.sqrtPriceX96); } 循环中的最后一步就是更新SwapState。step.amountIn 是这个价格区间可以从用户手中买走的token数量了；step.amountOut 是相应的池子卖给用户的数量。state.sqrtPriceX96 是交易结束后的现价（因为交易会改变价格）。\nSwapMath 合约 # 接下来，让我们更深入研究一下 SwapMath.computeSwapStep：\n// src/lib/SwapMath.sol function computeSwapStep( uint160 sqrtPriceCurrentX96, uint160 sqrtPriceTargetX96, uint128 liquidity, uint256 amountRemaining ) internal pure returns ( uint160 sqrtPriceNextX96, uint256 amountIn, uint256 amountOut ) { ... 这是整个swap的核心逻辑所在。这个函数计算了一个价格区间内部的交易数量以及对应的流动性。它的返回值是：新的现价、输入token数量、输出token数量。尽管输入token数量是由用户提供的，我们仍然需要进行计算在对于 computeSwapStep 的一次调用中可以处理多少用户提供的token。\nbool zeroForOne = sqrtPriceCurrentX96 \u0026gt;= sqrtPriceTargetX96; sqrtPriceNextX96 = Math.getNextSqrtPriceFromInput( sqrtPriceCurrentX96, liquidity, amountRemaining, zeroForOne ); 通过检查价格大小我们来确认交易的方向。知道交易方向后，我们就可以计算交易amountRemaining数量token之后的价格。在下面我们还会回过头来看这个函数。\n找到新的价格后，我们根据之前已有的函数能够计算出输入和输出的数量（与mint里面用到的，根据流动性计算token数量的函数相同）：\namountIn = Math.calcAmount0Delta( sqrtPriceCurrentX96, sqrtPriceNextX96, liquidity ); amountOut = Math.calcAmount1Delta( sqrtPriceCurrentX96, sqrtPriceNextX96, liquidity ); And swap the amounts if the direction is opposite:\nif (!zeroForOne) { (amountIn, amountOut) = (amountOut, amountIn); } 这就是 computeSwapStep的全部！\n通过交易数量获取价格 # 接下来我们来看 Math.getNextSqrtPriceFromInput 函数——这个函数根据现在的 $\\sqrt{P}$、流动性、和输入数量，计算出交易后新的 $\\sqrt{P}$。\n一个好消息是我们已经知道了相关的公式。回忆一下，我们之前在 Python 中计算 price_next\n# When amount_in is token0 price_next = int((liq * q96 * sqrtp_cur) // (liq * q96 + amount_in * sqrtp_cur)) # When amount_in is token1 price_next = sqrtp_cur + (amount_in * q96) // liq 我们会在Solidity中实现上述功能：\n// src/lib/Math.sol function getNextSqrtPriceFromInput( uint160 sqrtPriceX96, uint128 liquidity, uint256 amountIn, bool zeroForOne ) internal pure returns (uint160 sqrtPriceNextX96) { sqrtPriceNextX96 = zeroForOne ? getNextSqrtPriceFromAmount0RoundingUp( sqrtPriceX96, liquidity, amountIn ) : getNextSqrtPriceFromAmount1RoundingDown( sqrtPriceX96, liquidity, amountIn ); } 这个函数仅仅是分别处理了两个方向的功能。我们会分别在两个不同的函数中进行实现：\nfunction getNextSqrtPriceFromAmount0RoundingUp( uint160 sqrtPriceX96, uint128 liquidity, uint256 amountIn ) internal pure returns (uint160) { uint256 numerator = uint256(liquidity) \u0026lt;\u0026lt; FixedPoint96.RESOLUTION; uint256 product = amountIn * sqrtPriceX96; if (product / amountIn == sqrtPriceX96) { uint256 denominator = numerator + product; if (denominator \u0026gt;= numerator) { return uint160( mulDivRoundingUp(numerator, sqrtPriceX96, denominator) ); } } return uint160( divRoundingUp(numerator, (numerator / sqrtPriceX96) + amountIn) ); } 在这个函数中，我们实现了两个公式。在第一个return 那里，实现了我们Python中提到的公式。这事最精确的公式，凡是它可能会在 amountIn 与 sqrtPriceX96 相乘时产生溢出。公式是：\n$$\\sqrt{P_{target}} = \\frac{\\sqrt{P}L}{\\Delta x \\sqrt{P} + L}$$\n当它可能产生溢出时，我们使用另一个替代的公式，精确度会更低但是不会溢出：\n$$\\sqrt{P_{target}} = \\frac{L}{\\Delta x + \\frac{L}{\\sqrt{P}}}$$\n其实也仅仅是把第一个公式上下同时除以$\\sqrt{P}$得到的。\n另一个函数的实现会简单一些：\nfunction getNextSqrtPriceFromAmount1RoundingDown( uint160 sqrtPriceX96, uint128 liquidity, uint256 amountIn ) internal pure returns (uint160) { return sqrtPriceX96 + uint160((amountIn \u0026lt;\u0026lt; FixedPoint96.RESOLUTION) / liquidity); } 完成swap # 现在，让我们回到swap函数并且完成它。\n到目前为止，我们已经能够沿着下一个初始化过的tick进行循环、填满用户指定的amoutSpecified、计算输入和输出数量，并且找到新的价格和tick。由于在本章节中我们只实现在一个价格区间内的交易，这些功能就已经足够了。我们现在只需要去更新合约状态、将token发送给用户，并从用户处获得token。\nif (state.tick != slot0_.tick) { (slot0.sqrtPriceX96, slot0.tick) = (state.sqrtPriceX96, state.tick); } 首先，我们设置新的价格和tick。由于这个操作需要对合约的存储进行写操作，我们仅仅会在新的tick不同的时候进行更新，来节省gas。\n(amount0, amount1) = zeroForOne ? ( int256(amountSpecified - state.amountSpecifiedRemaining), -int256(state.amountCalculated) ) : ( -int256(state.amountCalculated), int256(amountSpecified - state.amountSpecifiedRemaining) ); 接下来，我们根据交易的方向来获得循环中计算出的对应数量。\nif (zeroForOne) { IERC20(token1).transfer(recipient, uint256(-amount1)); uint256 balance0Before = balance0(); IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback( amount0, amount1, data ); if (balance0Before + uint256(amount0) \u0026gt; balance0()) revert InsufficientInputAmount(); } else { IERC20(token0).transfer(recipient, uint256(-amount0)); uint256 balance1Before = balance1(); IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback( amount0, amount1, data ); if (balance1Before + uint256(amount1) \u0026gt; balance1()) revert InsufficientInputAmount(); } 接下来，我们根据交易方向与用户交换token。这个部分和我们在milestone 1中实现的部分一样，除了要考虑交易方向之外。\n现在Swap已经完成了！\n测试 # 测试的改变并不大，我们仅仅需要把amoutSpecified 和 zeroForOne 传参给swap函数。输出的数量会略微有不同，因为这里是用Solidity计算的。\n我们现在也可以测试相反方向的交易了！此测试留作作业给读者完成（记得选择一个较小的金额，来确保交易发生在同一个价格区间）。如果遇到困难，可以参考作者的测试。\n"},{"id":38,"href":"/docs/milestone_1/deployment/","title":"部署合约","section":"Milestone 1. 第一笔交易","content":" \\[ \\] 部署 # 我们的第一版合约已经完成了。现在，让我们来看看如何把它部署在一个本地以太坊网络上，方便我们之后用前端app交互。\n选择本地网络 # 智能合约的开发需要运行一个本地的网络来在开发过程中进行部署和测试。这样的网络需要具有以下特点：\n真实的区块链。它必须是一个真实的区块链网络而不是一个模拟器，我们希望我们的合约如果能够在这样的网络上正常工作那也一定能在主网上正常工作 速度。我们希望我们的交易能够快速被执行，这样我们能快速迭代。 以太币。为了支付gas费，我们需要一些eth，因此我们希望这个网络能够允许我们生成任意数量的eth cheat code。除了提供标准的API，我们还希望这个网络能让我们做更多的事，例如：在任何地址上部署合约，以任何地址执行交易，直接修改合约状态等等。 今天，有许多的工具能够提供这样的功能：\nTruffle套件中的Ganache Hardhat，一套智能合约开发环境，除了包含本地网络节点以外还有很多有用的工具 Foundry中的Anvil 所有这些解决方案都能够满足我们的需求。尽管如此，项目现在都逐渐从Ganache（最早的解决方案）迁移到Hardhat（目前使用最广的方案），而Foundry也成为开发者的新宠。Foundry也是上述三个方案中唯一使用Solidity来编写测试的框架（其他框架都使用JavaScript）。除此以外，Foundry还允许使用Solidity来编写部署脚本。因此，由于我们想在各处都使用Solidity，我们会使用 Anvil 来运行一个本地区块链，并且使用Solidity编写部署脚本。\n运行本地区块链 # Anvil不需要进行配置，我们可以直接在命令行运行：\n$ anvil _ _ (_) | | __ _ _ __ __ __ _ | | / _` | | \u0026#39;_ \\ \\ \\ / / | | | | | (_| | | | | | \\ V / | | | | \\__,_| |_| |_| \\_/ |_| |_| 0.1.0 (d89f6af 2022-06-24T00:15:17.897682Z) https://github.com/foundry-rs/foundry ... Listening on 127.0.0.1:8545 Anvil运行一个以太坊节点，所以它实际上并不是个网络，但也没什么问题。默认配置下它会创建10个账户，每个有10000ETH。它会把这些账户和对应私钥打印在命令行，我们会使用其中一个来部署合约和与其交互。\nAnvil在127.0.0.1:8545开放了JSON-RPC API接口——这个接口是与以太坊节点交互的主要方式。你可以在这里找到完整的API文档。在这里，你可以用curl与其交互：\n$ curl -X POST -H \u0026#39;Content-Type: application/json\u0026#39; \\ --data \u0026#39;{\u0026#34;id\u0026#34;:1,\u0026#34;jsonrpc\u0026#34;:\u0026#34;2.0\u0026#34;,\u0026#34;method\u0026#34;:\u0026#34;eth_chainId\u0026#34;}\u0026#39; \\ http://127.0.0.1:8545 {\u0026#34;jsonrpc\u0026#34;:\u0026#34;2.0\u0026#34;,\u0026#34;id\u0026#34;:1,\u0026#34;result\u0026#34;:\u0026#34;0x7a69\u0026#34;} $ curl -X POST -H \u0026#39;Content-Type: application/json\u0026#39; \\ --data \u0026#39;{\u0026#34;id\u0026#34;:1,\u0026#34;jsonrpc\u0026#34;:\u0026#34;2.0\u0026#34;,\u0026#34;method\u0026#34;:\u0026#34;eth_getBalance\u0026#34;,\u0026#34;params\u0026#34;:[\u0026#34;0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266\u0026#34;,\u0026#34;latest\u0026#34;]}\u0026#39; \\ http://127.0.0.1:8545 {\u0026#34;jsonrpc\u0026#34;:\u0026#34;2.0\u0026#34;,\u0026#34;id\u0026#34;:1,\u0026#34;result\u0026#34;:\u0026#34;0x21e19e0c9bab2400000\u0026#34;} 你也可以使用cast（foundry中的另一个组件）来访问：\n$ cast chain-id 31337 $ cast balance 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266 10000000000000000000000 现在，我们来将池子合约和管理合约都部署在本地网络上。\n第一次部署 # 根本上来讲，部署一个合约意味着：\n将源代码编译成EVM字节码 发送一个包含这些字节码的交易 新建一个地址，执行字节码中构造函数的部分，将初始化的字节码存放在该地址。这一步是由以太坊节点自动完成的，在这笔交易被打包上链时。 部署通常包含很多个步骤：准备参数，部署辅助合约，部署主合约，初始化合约等等。脚本能帮助我们自动化完成这些步骤，并且我们现在能用Solidity来编写脚本！\n创建 scripts/DeployDevelopment.sol 文件，写入以下内容：\n// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.14; import \u0026#34;forge-std/Script.sol\u0026#34;; contract DeployDevelopment is Script { function run() public { ... } } 它看起来与测试合约十分相似，唯一的差别在于它继承自Script合约而不是Test。并且按照惯例，我们需要定义一个run函数作为部署脚本的主体。在run函数中，我们首先定义部署需要的参数：\nuint256 wethBalance = 1 ether; uint256 usdcBalance = 5042 ether; int24 currentTick = 85176; uint160 currentSqrtP = 5602277097478614198912276234240; 这些正是我们之前用过的值。这里我们需要铸造5042个USDC——其中5000个用来提供流动性，42个用来交易。\n接下来，我们定义一系列在部署过程中需要执行的交易（每一步都是独立的交易）。我们使用startBroadcast/endBroadcast这个 cheat code:\nvm.startBroadcast(); ... vm.stopBroadcast(); 这些cheat code可以在forge的文档中找到，我们是从继承的forge-std/Script.sol里面得到这些功能的。\n在broadcast() cheat code后面，或者startBroadcast()/stopBroadcast()之间的所有语句都会被转化成交易，这些交易会被发送到执行这个脚本的节点。\n在这两个cheat code之间，我们开始真正的部署步骤。首先需要部署两种token：\nERC20Mintable token0 = new ERC20Mintable(\u0026#34;Wrapped Ether\u0026#34;, \u0026#34;WETH\u0026#34;, 18); ERC20Mintable token1 = new ERC20Mintable(\u0026#34;USD Coin\u0026#34;, \u0026#34;USDC\u0026#34;, 18); 没有token我们就无法部署池子，因此需要先部署token合约 （译者注：由于原生代币ETH没有approve功能，因此在这里使用的是WETH。在各种金融协议中，原生ETH通常都被单独拿出来处理）\n由于我们是在本地网络上进行部署，我们需要自行部署对应的token。在主网上和公开测试网上(Ropsten, Goerli, Sepolia)，这些token已经被部署。因此，如果想要在这些网络上进行部署，我们需要写网络特定的部署脚本。\n接下来就是部署池子合约：\nUniswapV3Pool pool = new UniswapV3Pool( address(token0), address(token1), currentSqrtP, currentTick ); 然后部署管理合约：\nUniswapV3Manager manager = new UniswapV3Manager(); 最后，我们给我们自己的地址铸造一些token用来之后交易：\ntoken0.mint(msg.sender, wethBalance); token1.mint(msg.sender, usdcBalance); 在Foundry脚本中，msg.sender是在broadcast块中发送交易的地址。我们可以在运行脚本的时候对其进行设置。\n在脚本的最后，使用console.log打印出对应的地址信息：\nconsole.log(\u0026#34;WETH address\u0026#34;, address(token0)); console.log(\u0026#34;USDC address\u0026#34;, address(token1)); console.log(\u0026#34;Pool address\u0026#34;, address(pool)); console.log(\u0026#34;Manager address\u0026#34;, address(manager)); 现在我们来运行这个脚本（确保Anvil在另一个窗口中正在运行）：\n$ forge script scripts/DeployDevelopment.s.sol --broadcast --fork-url http://localhost:8545 --private-key $PRIVATE_KEY --broadcast 启动交易的广播。它并不是默认开启的因为并不是每一个脚本都需要发送交易。--fork-url设置我们要发送交易的节点地址。--private-key设置调用者的钱包：需要私钥来签名交易。我们可以选择之前Anvil启动时在命令行打印出来的任何一个私钥。作者选择了第一个地址和私钥。\n部署需要消耗几秒钟。最后，你会看到它发送了一系列的交易。它同时也将交易收据存在了broadcast文件夹。在Anvil运行的窗口里，你也能看到很多行例如eth_sendRawTransaction, eth_getTransactionByHash, 和 eth_getTransactionReceipt这样的信息——在你向Anvil发送交易后，Forge使用 JSON-RPC API来检查它们的状态并且获得交易执行的结果（收据）。\n恭喜！你刚刚成功部署了一个智能合约！\n与合约交互，ABI # 现在，让我们来看看我们如何与已经部署的合约交互。\n每个合约都由一系列的public函数开放。以池子合约为例，包含mint(...) 和 swap(...)。除此之外，Solidity为每一个public的变量创建了getter，所以我们也可以调用token0()，token1()，positions()等等，来访问对应变量的值。然而，由于合约都被编译成字节码，函数名在编译过程中丢失并且不存储在区块链上。在链上，每个函数都用一个函数选择器(selector)来表示，即函数签名哈希的前4字节。伪代码即为：\nhash(\u0026#34;transfer(address,address,uint256)\u0026#34;)[0:4] EVM 使用的是 Keccak 哈希算法，标准化名字为SHA-3。特别地，Solidity中的哈希函数名字为keccak256。\n根据以上信息，我们展示两种对于部署的合约进行调用的方法：一种使用curl来进行底层的调用，一种使用cast。\nToken余额 # 我们来检查一下部署者地址种的WETH余额。这个函数的签名是balanceOf(address)（在ERC-20标准种定义），为了计算这个函数的ID（即选择器），我们计算哈希并取前4字节：\n$ cast keccak \u0026#34;balanceOf(address)\u0026#34;| cut -b 1-10 0x70a08231 要把地址作为参数传递进去，我们把它附在函数选择器的后面（在左边padding到32个字节，因为地址在函数调用中占32字节）：\n0x70a08231000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266\n0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266 是我们要查看余额的地址。这是本书选择的部署者的地址，也是Anvil创建时的第一个地址。\n接下来，我们会使用eth_call JSON-RPC 方法来进行这个调用。注意到，这一步不需要发送一个交易——我们仅仅是从合约中读取数据。\n$ params=\u0026#39;{\u0026#34;from\u0026#34;:\u0026#34;0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266\u0026#34;,\u0026#34;to\u0026#34;:\u0026#34;0xe7f1725e7734ce288f8367e1bb143e90bb3f0512\u0026#34;,\u0026#34;data\u0026#34;:\u0026#34;0x70a08231000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266\u0026#34;}\u0026#39; $ curl -X POST -H \u0026#39;Content-Type: application/json\u0026#39; \\ --data \u0026#39;{\u0026#34;id\u0026#34;:1,\u0026#34;jsonrpc\u0026#34;:\u0026#34;2.0\u0026#34;,\u0026#34;method\u0026#34;:\u0026#34;eth_call\u0026#34;,\u0026#34;params\u0026#34;:[\u0026#39;\u0026#34;$params\u0026#34;\u0026#39;,\u0026#34;latest\u0026#34;]}\u0026#39; \\ http://127.0.0.1:8545 {\u0026#34;jsonrpc\u0026#34;:\u0026#34;2.0\u0026#34;,\u0026#34;id\u0026#34;:1,\u0026#34;result\u0026#34;:\u0026#34;0x00000000000000000000000000000000000000000000011153ce5e56cf880000\u0026#34;} \u0026ldquo;to\u0026rdquo; 地址是 USDC token 的地址，它是在上一步部署脚本运行时打印出的日志里面的地址。\n以太坊节点返回的结果是字节流，为了理解结果我们需要知道返回值的类型。在balanceOf函数中，返回值的类型是uint256。用cast可以把结果转换成十进制然后转换成ethers单位：\n$ cast --to-dec 0x00000000000000000000000000000000000000000000011153ce5e56cf880000| cast --from-wei 5042.000000000000000000 余额是正确的，我们在自己的地址中有 5042 USDC。\n现在的tick和价格 # 上述例子展示了底层的合约调用。通常来说，你永远不会使用curl来发起调用，而是使用某个更友好的工具或库。cast在这里也能够帮助我们简化这一过程。\n我们来使用cast获得当前合约的tick和price:\n$ cast call POOL_ADDRESS \u0026#34;slot0()\u0026#34;| xargs cast --abi-decode \u0026#34;a()(uint160,int24)\u0026#34; 5602277097478614198912276234240 85176 如此容易！第一个值就是我们的$\\sqrt{P}$，第二个值就是现在的tick。\n由于 --abi-decode 需要完整的函数签名，我们必须声明一个函数名 \u0026ldquo;a()\u0026quot;，尽管我们只希望解码函数的输出。\nABI # 为了简化与合约的交易，Solidity编译器可以输出ABI，Application Binary Interface（应用二进制接口）。\nABI是一个包含了合约中所有public方法和事件的 JSON 文件。文件的目的在于使得编码函数参数和解码函数输出都更加容易。我们可以通过Forge来获取ABI：\n$ forge inspect UniswapV3Pool abi 可以看一看生成的文件，来更好地理解ABI意味着什么。\n"},{"id":39,"href":"/docs/milestone_3/flash-loans/","title":"Flash Loans","section":"Milestone 3. 跨tick交易","content":" Flash Loans # Both Uniswap V2 and V3 implement flash loans: unlimited and uncollateralized loans that must be repaid in the same transaction. Pools basically give users arbitrary amounts of tokens that they request, but, by the end of the call, the amounts must be repaid, with a small fee on top.\nThe fact that flash loans must be repaid in the same transaction means that flash loans cannot be taken by regular users: as a user, you cannot program custom logic in transactions. Flash loans can only be taken and repaid by smart contracts.\nFlash loans is a powerful financial instrument in DeFi. While it\u0026rsquo;s often used to exploit vulnerabilities in DeFi protocols (by inflating pool balances and abusing flawed state management), it\u0026rsquo;s has many good applications (e.g. leveraged positions management on lending protocols)–this is why DeFi applications that store liquidity provide permissionless flash loans.\nImplementing Flash Loans # In Uniswap V2 flash loans were part of the swapping functionality: it was possible to borrow tokens during a swap, but you had to return them or an equal amount of the other pool token, in the same transaction. In V3, flash loans are separated from swapping–it\u0026rsquo;s simply a function that gives the caller an amount of tokens they requested, calls a callback on the caller, and ensures a flash loan was repaid:\nfunction flash( uint256 amount0, uint256 amount1, bytes calldata data ) public { uint256 balance0Before = IERC20(token0).balanceOf(address(this)); uint256 balance1Before = IERC20(token1).balanceOf(address(this)); if (amount0 \u0026gt; 0) IERC20(token0).transfer(msg.sender, amount0); if (amount1 \u0026gt; 0) IERC20(token1).transfer(msg.sender, amount1); IUniswapV3FlashCallback(msg.sender).uniswapV3FlashCallback(data); require(IERC20(token0).balanceOf(address(this)) \u0026gt;= balance0Before); require(IERC20(token1).balanceOf(address(this)) \u0026gt;= balance1Before); emit Flash(msg.sender, amount0, amount1); } The function sends tokens to the caller and then calls uniswapV3FlashCallback on it–this is where the caller is expected to repay the loan. Then the function ensures that its balances haven\u0026rsquo;t decreased. Notice that custom data is allowed to be passed to the callback.\nHere\u0026rsquo;s an example of the callback implementation:\nfunction uniswapV3FlashCallback(bytes calldata data) public { (uint256 amount0, uint256 amount1) = abi.decode( data, (uint256, uint256) ); if (amount0 \u0026gt; 0) token0.transfer(msg.sender, amount0); if (amount1 \u0026gt; 0) token1.transfer(msg.sender, amount1); } In this implementation, we\u0026rsquo;re simply sending tokens back to the pool (I used this callback in flash function tests). In reality, it can use the loaned amounts to perform some operations on other DeFi protocols. But it always must repay the loan in this callback.\nAnd that\u0026rsquo;s it!\n"},{"id":40,"href":"/docs/milestone_2/quoter-contract/","title":"报价合约","section":"Milestone 2. 第二笔交易","content":" 报价合约 # 为了让我们的池子合约能够集成到前端，我们需要一种方式能够在交易之前就计算出对应的数量。用户会输入它们希望卖出的token数量，然后就能计算并且展示出它们会获得的token数量。我们将通过报价合约来实现这一功能。\n由于Uniswap V3中的流动性是分散在多个价格区间中的，我们不能够仅仅通过一个公式计算出对应数量（像在Uniswap V2中那样）。Uniswap V3的设计需要我们用一种不同的方法：为了获得交易数量，我们初始化一个真正的交易，并且在callback函数中打断它，获取到之前计算出的对应数量。也就是，我们将会模拟一笔真实的交易来计算输出数量！\n我们会创建这样一个辅助合约：\ncontract UniswapV3Quoter { struct QuoteParams { address pool; uint256 amountIn; bool zeroForOne; } function quote(QuoteParams memory params) public returns ( uint256 amountOut, uint160 sqrtPriceX96After, int24 tickAfter ) { ... Quoter 合约仅实现了一个public的函数——quote。Quoter是一个对于所有池子的通用合约，因此它将池子地址作为一个参数。其他参数（amountIn 和 zeroForOne）都是模拟swap需要的参数。\ntry IUniswapV3Pool(params.pool).swap( address(this), params.zeroForOne, params.amountIn, abi.encode(params.pool) ) {} catch (bytes memory reason) { return abi.decode(reason, (uint256, uint160, int24)); } 这个函数唯一实现的功能是调用池子合约的 swap 函数。这个调用应当revert（即抛出异常）——我们将会在callback中实现这一点。当revert发生的时候，对应的reason会解码并且返回。quote永远不会revert。注意到，在data字段，我们仅仅传入和合约的地址——因为在callback函数中，我们需要用它来获取对应池子的slot0。\nfunction uniswapV3SwapCallback( int256 amount0Delta, int256 amount1Delta, bytes memory data ) external view { address pool = abi.decode(data, (address)); uint256 amountOut = amount0Delta \u0026gt; 0 ? uint256(-amount1Delta) : uint256(-amount0Delta); (uint160 sqrtPriceX96After, int24 tickAfter) = IUniswapV3Pool(pool) .slot0(); 在swap的callback中，我们收集我们想要的值：输出数量，新的价格以及对应的tick。接下来，我们将会把这些值保存下来并且revert：\nassembly { let ptr := mload(0x40) mstore(ptr, amountOut) mstore(add(ptr, 0x20), sqrtPriceX96After) mstore(add(ptr, 0x40), tickAfter) revert(ptr, 96) } 为了节约gas，这部分使用Yul来实现，这是一个在Solidity内部写内联汇编的语言。让我们来逐句分析一下：\nmload(0x40) 读取下一个可用memory slot的指针（EVM中的memory组织成32字节的slot形式）； 在这个memory slot，mstore(ptr, amountOut) 写入 amountOut 。 mstore(add(ptr, 0x20), sqrtPriceX96After) 在 amountOut 后面写入 sqrtPriceX96After。 mstore(add(ptr, 0x40), tickAfter) 在 sqrtPriceX96After 后面写入 tickAfter。 revert(ptr, 96) 会revert这个调用，并且返回ptr指向位置的96字节数据。 所以，我们实际上就是把我们需要的值的字节表示连接起来（也就是abi.encode()做的事）。注意到偏移永远是32字节，即使 sqrtPriceX96After 大小只有20字节(uint160)，tickAfter 大小只有3字节(uint24)。这也是为什么我们能够使用 abi.decode() 来解码数据：因为 abi.encode() 就是把所有的数编码成32字节。\n这样就完成了~\n回顾 # 我们来回顾一下以便于更好地理解这个算法：\nquote 调用一个池子的 swap 函数，参数是输入的token数量和交易方向。 swap 进行一个真正的交易，运行一个循环来填满用户需要的数量。 为了从用户那里获得token，swap 会调用caller 的 callback 函数。 调用者（报价合约）实现了callback，在其中它 revert 并且附带了输出数量、新的价格、新的tick这些信息。 revert 一直向上传播到最初的 quote 调用 在 quote 中，这个 revert 被捕获，reason 被解码并作为了 quote 调用的返回值。 希望上面的解释能让你对这个流程更加清晰！\nQuoter的限制 # 这样的设计有一个非常明显的限制之处：由于 quote 调用了池子合约的 swap 函数，而 swap 函数既不是 pure 的也不是 view 的（因为它修改了合约状态），quoter 也同样不能成为一个 pure 或者 view 的函数，即使它永远都不会修改合约的状态。但是，我们却能够把 quote 作为一个 getter 函数来使用，仅仅读取合约的数据而没有写。这样的不同之处意味着，EVM会使用 CALL opcode 而不是 CALLSTATIC。这不算是一个太大的问题，因为 Quoter 总会 revert，并且revert会重置调用中修改的一切合约状态——这保证了 quote 并不会修改池子合约的任何状态（也即没有实际的交易发生）。\n另一个有些不同的点在于，当我们使用某个库调用 quote 函数时通常会触发一个交易。为了解决这个问题，我们需要强制这个库使用 static call。我们将会在下一小节中看到我们如何在 Ethers.js 中实现这一点。\n"},{"id":41,"href":"/docs/milestone_1/user-interface/","title":"用户界面","section":"Milestone 1. 第一笔交易","content":" \\[ \\] 用户界面 # 现在，我们可以进行这个milestone的最后一步了——搭建一个UI！\n由于搭建前端app并不是本书的主要目的，本书将不会讲解如何从头搭建一个这样的前端，而是展示如何使用MetaMask与智能合约进行交互。\n如果你希望自己尝试这个app，在本地运行它，你可以在代码仓库中的 ui文件夹找到对应代码。这就是一个简单的React应用，本地运行只需要在App.js中设置合约地址，然后运行yarn start。\n相关工具一览 # 什么是MetaMask？ # MetaMask是一个浏览器插件的以太坊钱包。它能够创建和存储私钥、展示账户余额、允许链接到不同网络、发送和接受以太或其他token——钱包能做的所有事情几乎都可以在其中实现。\n除此之外，MetaMask还能够作为signer和provider来运行。作为provider，它链接到一个以太坊节点，并且提供一个接口来使用对应节点的JSON-RPC API。作为一个signer，它提供了一个能够进行安全交易签名的接口，因此能够使用钱包中的私钥来签名任意交易。 （译者注：signer和provider都是js库中的常用名词，因此在这里不作翻译） 常用库 # 事实上，MetaMask也并没有提供那么多的功能：它仅仅是能够管理账户和发送交易。我们需要其他一些库来使得与合约的交互更加容易，并且能更轻松地解析EVM相关的数据。\n这样的库有很多，其中最流行的两个是 web3.js 和 ethers.js。选择哪一个取决于你的个人喜好。对本书作者来说，选择 Ethers.js 因为其与合约交互的接口更加清晰\n工作流 # 现在，让我们看一下如何使用 MetaMask + Ethers.js 来实现交互。\n连接到本地节点 # 为了能够发送交易和获取区块链数据，MetaMask链接到一个以太坊节点。为了与我们的合约交互，我们需要钱包链接到本地的Anvil节点。打开MetaMask，点击网络列表——添加网络，增加一个网络，RPC URL为http://localhost:8545。钱包将会自动检测对应的chain ID（在Anvil中为31331）.\n链接到本地节点之后，我们需要导入一个私钥。在MetaMask中，点击地址列表——导入账户，把之前选择的地址对应的私钥粘贴在这里。然后进入资产列表，导入两种token的地址。现在你可以在MetaMask上看到两种token的余额了。\nMetaMask实际上有一些bug。一个我经常遇到的bug是，当它连接到本地节点时，它通常会缓存链状态。因此每次重启节点的时候，你有可能会看到旧的余额和状态。解决方法是：打开高级设置，点击“重置账户”。每次重启节点后你可能都需要进行这个步骤。\n链接到MetaMask # 并不是每一个网站都能够访问到你在MetaMask中的地址。一个网站首先需要链接到MetaMask。当一个新的网站想要连接MetaMask时，你会看到一个弹窗来请求许可。\n前端连接MetaMask的方式如下：\n// ui/src/contexts/MetaMask.js const connect = () =\u0026gt; { if (typeof (window.ethereum) === \u0026#39;undefined\u0026#39;) { return setStatus(\u0026#39;not_installed\u0026#39;); } Promise.all([ window.ethereum.request({ method: \u0026#39;eth_requestAccounts\u0026#39; }), window.ethereum.request({ method: \u0026#39;eth_chainId\u0026#39; }), ]).then(function ([accounts, chainId]) { setAccount(accounts[0]); setChain(chainId); setStatus(\u0026#39;connected\u0026#39;); }) .catch(function (error) { console.error(error) }); } window.ethereum 是MetaMask提供的一个对象，是与MetaMask进行交互的接口。如果它是 undefined，说明没有安装MetaMask。如果它是有定义的，我们向MetaMask发送两个请求：eth_requestAccounts 和 eth_chainId。事实上，eth_requestAccounts 把一个网站连接到MetaMask。它向MetaMask请求一个地址，之后MetaMask向用户请求许可。用户能够选择它可以连接的钱包地址。\neth_chainId 会请求MetaMask连接到的节点的 chain ID 。在获取地址和chain ID之后，通常可以把它展示在前端页面：\n提供流动性 # 为了向池子中提供流动性，我们需要搭建一个表单，要求用户填入希望质押的token数量。在点击 “Submit” 之后，前端会构建一个交易调用管理合约的mint函数并且把用户填入的数量作为参数传递。我们来看一下这个功能如何实现。\nEther.js 提供了 Contract 接口来与合约交互。它让这个过程变得十分简单，因为它替我们完成了编码函数参数、创建一个合法交易、把数据交给MetaMask这几个步骤。对于我们来说，调用合约就像调用一个JS对象的异步方法一样。\n让我们来看看如何建立一个 Contract 的实例：\ntoken0 = new ethers.Contract( props.config.token0Address, props.config.ABIs.ERC20, new ethers.providers.Web3Provider(window.ethereum).getSigner() ); 一个Contract实例是一个地址和部署在这个地址上的合约的ABI。我们需要ABI来与合约进行交互。第三个参数是由MetaMask提供的signer接口——用来让JS合约调用MetaMask签名交易。\n现在，我们添加一个函数，来为池子增加流动性：\nconst addLiquidity = (account, { token0, token1, manager }, { managerAddress, poolAddress }) =\u0026gt; { const amount0 = ethers.utils.parseEther(\u0026#34;0.998976618347425280\u0026#34;); const amount1 = ethers.utils.parseEther(\u0026#34;5000\u0026#34;); // 5000 USDC const lowerTick = 84222; const upperTick = 86129; const liquidity = ethers.BigNumber.from(\u0026#34;1517882343751509868544\u0026#34;); const extra = ethers.utils.defaultAbiCoder.encode( [\u0026#34;address\u0026#34;, \u0026#34;address\u0026#34;, \u0026#34;address\u0026#34;], [token0.address, token1.address, account] ); ... 第一项就是要准备参数。我们还是使用之前手动计算出来的值。\n接下来，我们需要允许允许管理合约操作我们的token。首先检查一下现在的许可情况：\nPromise.all( [ token0.allowance(account, managerAddress), token1.allowance(account, managerAddress) ] ) 然后我们会检查现在的许可是否足够完成这笔交易。如果不够，我们需要发送一个approve交易，让用户同意管理合约花费他的一定数量的token。在确保用户approve足够的数量之后，我们调用manager.mint来添加流动性：\n.then(([allowance0, allowance1]) =\u0026gt; { return Promise.resolve() .then(() =\u0026gt; { if (allowance0.lt(amount0)) { return token0.approve(managerAddress, amount0).then(tx =\u0026gt; tx.wait()) } }) .then(() =\u0026gt; { if (allowance1.lt(amount1)) { return token1.approve(managerAddress, amount1).then(tx =\u0026gt; tx.wait()) } }) .then(() =\u0026gt; { return manager.mint(poolAddress, lowerTick, upperTick, liquidity, extra) .then(tx =\u0026gt; tx.wait()) }) .then(() =\u0026gt; { alert(\u0026#39;Liquidity added!\u0026#39;); }); }) lt 是BigNumber的一个方法。Ethers.js 使用 BigNumber来代表uint256类型，因为JavaScript本身精度不足。这也是我们希望有一个库的原因。\n除了token许可的部分以外，这跟测试合约基本一致。\n上述代码中的token0, token1, 和 manager 都是Contract的实例。approve 和 mint 都是合约函数，是从我们初始化合约时提供的ABI中动态生成的。当调用这些方法时，Ethers.js会：\n编码函数参数； 构建一个交易； 将交易传递给MetaMask并请求签名；用户看到MetaMask弹窗并点击“确认”； 将交易发送给MetaMask连接的节点； 返回包含这笔交易完整信息的一个对象。 交易对象包含一个wait函数，我们调用它来等待一个交易上链——这能够让我们等待这一笔交易成功再执行下一笔交易。\n以太坊对于交易顺序有严格要求。还记得nonce嘛？它是账户级别对于交易的index。每一笔新的交易都会增加这个index，并且以太坊只有在上一笔交易（nonce更小的交易）执行完成后才会执行下一笔交易。\n交易Token # 在交易token时，我们使用相同的模式：从用户输入获取参数，检查许可，调用管理合约的swap。\nconst swap = (amountIn, account, { tokenIn, manager, token0, token1 }, { managerAddress, poolAddress }) =\u0026gt; { const amountInWei = ethers.utils.parseEther(amountIn); const extra = ethers.utils.defaultAbiCoder.encode( [\u0026#34;address\u0026#34;, \u0026#34;address\u0026#34;, \u0026#34;address\u0026#34;], [token0.address, token1.address, account] ); tokenIn.allowance(account, managerAddress) .then((allowance) =\u0026gt; { if (allowance.lt(amountInWei)) { return tokenIn.approve(managerAddress, amountInWei).then(tx =\u0026gt; tx.wait()) } }) .then(() =\u0026gt; { return manager.swap(poolAddress, extra).then(tx =\u0026gt; tx.wait()) }) .then(() =\u0026gt; { alert(\u0026#39;Swap succeeded!\u0026#39;); }).catch((err) =\u0026gt; { console.error(err); alert(\u0026#39;Failed!\u0026#39;); }); } 唯一新出现的函数就只有 ethers.utils.parseEther()，用来把ether单位的数值转换成wei单位，以太坊中的最小单位（译者注：也即合约中使用的单位）。\n订阅更新 # 对于一个去中心化的应用，反应当前的区块链状态时很重要的。例如，在一个去中心化的交易市场中，正确地计算现在的价格是很重要的；过时的数据可能会导致滑点(slippage)并使得交易失败。\n当开发池子合约的时候，我们学习过event，它能够作为区块链数据的索引：无论何时智能合约的状态发生改变都发出一个event是种好习惯，因为event 能够作为索引帮助快速搜索需要的信息。我们现在需要做的，就是订阅合约的event来保证前端app的实时更新。让我们来实现这部分吧！\n如果你在之前看过了上一章forge生成的ABI，你会发现其中也包含event的描述：名字和参数。很棒的是：[Ethers.js会处理它们]并且为我们提供一个接口来订阅新的event。我们来看一下它是怎么工作的。\n订阅事件需要使用on(EVENT_NAME, handler)函数。callback会接受event的所有值和event本身来作为参数：\nconst subscribeToEvents = (pool, callback) =\u0026gt; { pool.on(\u0026#34;Mint\u0026#34;, (sender, owner, tickLower, tickUpper, amount, amount0, amount1, event) =\u0026gt; callback(event)); pool.on(\u0026#34;Swap\u0026#34;, (sender, recipient, amount0, amount1, sqrtPriceX96, liquidity, tick, event) =\u0026gt; callback(event)); } 如果想要筛选和拿到之前的event，我们可以使用queryFilter：\nPromise.all([ pool.queryFilter(\u0026#34;Mint\u0026#34;, \u0026#34;earliest\u0026#34;, \u0026#34;latest\u0026#34;), pool.queryFilter(\u0026#34;Swap\u0026#34;, \u0026#34;earliest\u0026#34;, \u0026#34;latest\u0026#34;), ]).then(([mints, swaps]) =\u0026gt; { ... }); 你可能注意到，event中的一些参数被标注为indexed——这样的域能够被以太坊节点作为索引，允许通过某些域的值来搜索事件。例如，Swap事件有sender 和 recipient两个域被标注为indexed，因此我们可以通过交易的发送者和接收者来搜索对应交易。Ethers.js当然也提供了这个功能：\nconst swapFilter = pool.filters.Swap(sender, recipient); const swaps = await pool.queryFilter(swapFilter, fromBlock, toBlock); OK！现在我们彻底完成了milestone 1!\n🎉🍾🍾🍾🎉 "},{"id":42,"href":"/docs/milestone_3/user-interface/","title":"User Interface","section":"Milestone 3. 跨tick交易","content":" \\[ \\] User Interface # We\u0026rsquo;re now ready to update the UI with the changes we made in this milestone. We\u0026rsquo;ll add two new features:\nAdd Liquidity dialog window; slippage tolerance in swapping. Add Liquidity Dialog # This change will finally remove hard coded liquidity amounts from our code and will allow use to add liquidity at arbitrary ranges.\nThe dialog is a simple component with a couple of inputs. We can even re-use addLiquidity function from previous implementation. However, now we need to convert prices to tick indices in JavaScript: we want users to type in prices but the contracts expect ticks. To make our job easier, we\u0026rsquo;ll use the official Uniswap V3 SDK for that.\nTo convert price to $\\sqrt{P}$, we can use encodeSqrtRatioX96 function. The function takes two amounts as input and calculates a price by dividing one by the other. Since we only want to convert $\\sqrt{P}$ to price, we can pass 1 as amount0:\nconst priceToSqrtP = (price) =\u0026gt; encodeSqrtRatioX96(price, 1); To convert price to tick index, we can use TickMath.getTickAtSqrtRatio function. This is an implementation of the Solidity TickMath library in JavaScript:\nconst priceToTick = (price) =\u0026gt; TickMath.getTickAtSqrtRatio(priceToSqrtP(price)); So we can now convert prices typed in by users to ticks:\nconst lowerTick = priceToTick(lowerPrice); const upperTick = priceToTick(upperPrice); Another thing we need to add here is slippage protection. For simplicity, I made it a hard coded value and set it to 0.5%. Here\u0026rsquo;s how to use slippage tolerance to calculate minimal amounts:\nconst slippage = 0.5; const amount0Desired = ethers.utils.parseEther(amount0); const amount1Desired = ethers.utils.parseEther(amount1); const amount0Min = amount0Desired.mul((100 - slippage) * 100).div(10000); const amount1Min = amount1Desired.mul((100 - slippage) * 100).div(10000); Slippage Tolerance in Swapping # Even though we\u0026rsquo;re the only user of the application and thus will never have problems with slippage during development, let\u0026rsquo;s add an input to control slippage tolerance during swaps.\nWhen swapping, slippage protection is implemented via limiting price–a price we don\u0026rsquo;t to go above or below during a swap. This means that we need to know this price before sending a swap transaction. However, we don\u0026rsquo;t need to calculate it on the front end because Quoter contract does this for us:\nfunction quote(QuoteParams memory params) public returns ( uint256 amountOut, uint160 sqrtPriceX96After, int24 tickAfter ) { ... } And we\u0026rsquo;re calling Quoter to calculate swap amounts.\nSo, to calculate limiting price we need to take sqrtPriceX96After and subtract slippage tolerance from it–this will be the price we don\u0026rsquo;t want to go below during a swap.\nconst limitPrice = priceAfter.mul((100 - parseFloat(slippage)) * 100).div(10000); And that\u0026rsquo;s it!\n"},{"id":43,"href":"/docs/milestone_2/user-interface/","title":"用户界面","section":"Milestone 2. 第二笔交易","content":" 用户界面 # 现在，我们可以让我们的web应用看起来更像一个真正的DEX了。我们可以移除那些硬编码的数额，并且允许用户输入任意的数量。同样，我们还可以让用户在任意一个方向交易，所以我们需要一个按钮来改变交易方向。在更新之后，swap 的表单长这样：\n\u0026lt;form className=\u0026#34;SwapForm\u0026#34;\u0026gt; \u0026lt;SwapInput amount={zeroForOne ? amount0 : amount1} disabled={!enabled || loading} readOnly={false} setAmount={setAmount_(zeroForOne ? setAmount0 : setAmount1, zeroForOne)} token={zeroForOne ? pair[0] : pair[1]} /\u0026gt; \u0026lt;ChangeDirectionButton zeroForOne={zeroForOne} setZeroForOne={setZeroForOne} disabled={!enabled || loading} /\u0026gt; \u0026lt;SwapInput amount={zeroForOne ? amount1 : amount0} disabled={!enabled || loading} readOnly={true} token={zeroForOne ? pair[1] : pair[0]} /\u0026gt; \u0026lt;button className=\u0026#39;swap\u0026#39; disabled={!enabled || loading} onClick={swap_}\u0026gt;Swap\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; 每个输入都根据交易方向赋值给一个变量，交易方向由 zeroForOne 这个状态来控制。下面的输入空间总是只读的，因为这部分的数字是由报价合约计算出来。\nsetAmount_ 函数做了两件事：更新上面输入框中的值，调用报价合约来计算下面输入框中的值\nconst updateAmountOut = debounce((amount) =\u0026gt; { if (amount === 0 || amount === \u0026#34;0\u0026#34;) { return; } setLoading(true); quoter.callStatic .quote({ pool: config.poolAddress, amountIn: ethers.utils.parseEther(amount), zeroForOne: zeroForOne }) .then(({ amountOut }) =\u0026gt; { zeroForOne ? setAmount1(ethers.utils.formatEther(amountOut)) : setAmount0(ethers.utils.formatEther(amountOut)); setLoading(false); }) .catch((err) =\u0026gt; { zeroForOne ? setAmount1(0) : setAmount0(0); setLoading(false); console.error(err); }) }) const setAmount_ = (setAmountFn) =\u0026gt; { return (amount) =\u0026gt; { amount = amount || 0; setAmountFn(amount); updateAmountOut(amount) } } 注意到，我们对 quoter 使用了 callStatic —— 这就是我们在上一小节讨论到的：我们需要强制 Ethers.js 进行 static call。如果不这样，由于 quote 不是 pure 或者 view 的，Ethers.js 会尝试发送一个交易。\n这样就完成了！现在的UI允许任意数量和任意方向的交易了。\n"}]