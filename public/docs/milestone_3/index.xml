<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Milestone 3. 跨tick交易 on Uniswap V3 Book 中文版</title>
    <link>https://uniswapv3book.com/docs/milestone_3/</link>
    <description>Recent content in Milestone 3. 跨tick交易 on Uniswap V3 Book 中文版</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language><atom:link href="https://uniswapv3book.com/docs/milestone_3/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>简介</title>
      <link>https://uniswapv3book.com/docs/milestone_3/introduction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_3/introduction/</guid>
      <description>跨tick交易 # 我们现在已经完成了Uniswap V3实现的很大一部分，并且已经很接近原版了！然而，我们的实现仅仅支持在同一个价格区间内的交易——这也是我们在这一个milestone中来改进的点。
在这个milestone中，我们会：
更新mint函数，使得能够在不同的价格区间提供流动性 更新swap函数，使得在当前价格区间流动性不足时能够跨价格区间交易 学习如何在智能合约中计算流动性 在mint和swap函数中实现花店控制 更新前端用户界面，使得能够在不同价格区间添加流动性 增加对于定点数运算的一些了解 在这个milestone中，我们将彻底完成swap这个Uniswap中最核心的功能！
让我们开始吧。
本章的完整代码可以参考这个Github分支
这个milestone也对于已有的合约做了许多修改，你可以在这里看到在上一个milestone基础上进行的改动
如果你关于本章有任何问题，欢迎在本章的Github Discussion提问和交流！</description>
    </item>
    
    <item>
      <title>不同价格区间</title>
      <link>https://uniswapv3book.com/docs/milestone_3/different-ranges/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_3/different-ranges/</guid>
      <description>\[ \] 不同价格区间 # 在我们之前的实现中，我们仅仅创建包含现价的价格区间：
// src/UniswapV3Pool.sol function mint( ... amount0 = Math.calcAmount0Delta( slot0_.sqrtPriceX96, TickMath.getSqrtRatioAtTick(upperTick), amount ); amount1 = Math.calcAmount1Delta( slot0_.sqrtPriceX96, TickMath.getSqrtRatioAtTick(lowerTick), amount ); liquidity += uint128(amount); ... } 从这段代码中你也可以看到，我们总是会更新流动性tracker（跟踪现在可用的流动性，即在现价时候可用的流动性）。
然而，在现实中，也可以创建低于或高于现价的价格区间。Uniswap V3的设计允许LP提供当前不可用的流动性。这些流动性只有当现价进入这些“休眠”的流动性取件时才会被“注入”。
以下是几种可能存在的价格区间情况：
活跃价格区间，也即包含现价的价格区间 低于现价的价格区间，该价格区间的上界tick低于现价tick 高于现价的价格区间，该价格区间的下界tick高于现价tick 限价单 # 一个有趣的事实是：非活跃的流动性（所在区间不包含现价）可以被看做是限价单(limit orders)。
在交易中，限价单是一种当价格突破用户设定的某个点的时候才会被执行的订单。例如，你希望放一个限价单，当ETH价格低于$1000的时候买入一个ETH。类似地，你可以使用限价单来出售资产。在Uniswap V3中，你可以通过在非活跃价格区间提供流动性来达到类似的目的。让我们来看一下它如何工作：
如果你在低于或高于现价的位置提供流动性（整个价格区间都低于/高于现价），那么你提供的流动性将完全由一种资产组成——两种资产中较便宜的那一种。在我们的例子中，我们的池子是把ETH作为 token $x$，把USDC作为 token $y$ ，我们的价格定义为：
$$P = \frac{y}{x}$$
如果我们把流动性放置在低于现价的区间，那么流动性将只会由USDC组成，因为当我们添加流动性的时候USDC的价格低于现价。类似地，如果我们高于现价的区间提供流动性，那么流动性将完全由ETH组成，因为ETH的价格低于现价。
回顾一下我们在简介中的图表：
如果我们购买这个区间中所有可用的ETH，这个区间内将只会由另一种token组成，USDC，并且价格将会沿着曲线移动到最右边。这个价格，也即 $\frac{y}{x}$，会升高。如果有一个价格区间在当前区间的右边，它将需要提供ETH的流动性，并且仅包含ETH：它需要为接下来的交易提供ETH。如果我们持续购买并且拉高价格，我们可能会继续“耗尽”下一个价格区间，也即买走它所有的ETH并卖出USDC。同样，这个区间会以全部是USDC而中止，现价移出这个区间。
类似地，如果我们购买USDC，我们会使得价格向左移动并且从池子中移出USDC。下一个价格区间会仅包含USDC代币来满足需求，并且类似地，如果我们继续买光这个区间的所有USDC，它也会以仅包含ETH而中止。
注意到一个有趣的点：当跨越整个价格区间时，其中的流动性从一种token交易为另外一种。并且如果我们设置一个相当窄的价格区间，价格会快速越过整个区间，我们就得到了一个限价单！例如，如果我们想在某个低价点购入ETH，我们可以在一个低价区间提供仅包含USDC的流动性，等待价格越过这个区间。在这之后，我们就可以移出流动性，所有的USDC都转换成了ETH！
希望这个例子没有让你感到困惑，我觉得这是一个理解价格区间动态变化的很好的例子。
更新mint函数 # 为了支持上面提到的各种价格区间，我们需要知道现价究竟是低于、位于，还是高于用户提供的价格区间，并且计算相应的token数量。如果价格区间高于现价，我们希望它的流动性仅仅由 token $x$ 组成：
// src/UniswapV3Pool.sol function mint( ... if (slot0_.</description>
    </item>
    
    <item>
      <title>Cross-Tick Swaps</title>
      <link>https://uniswapv3book.com/docs/milestone_3/cross-tick-swaps/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_3/cross-tick-swaps/</guid>
      <description>\[ \] Cross-Tick Swaps # Cross-tick swaps is probably the most advanced feature of Uniswap V3. Luckily, we have already implemented almost everything we need to make cross-tick swaps. Let&amp;rsquo;s see how cross-tick swaps work before implementing them.
How Cross-Tick Swaps Work # A common Uniswap V3 pool is a pool with many overlapping (and outstanding) price ranges. Each pool tracks current $\sqrt{P}$ and tick. When users swap tokens they move current price and tick to the left or to the right, depending on swap direction.</description>
    </item>
    
    <item>
      <title>Slippage Protection</title>
      <link>https://uniswapv3book.com/docs/milestone_3/slippage-protection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_3/slippage-protection/</guid>
      <description>\[ \] Slippage Protection # Slippage is a very important issued in decentralized exchanges. Slippage simply means the difference between the price that you see on the screen when initialing a transaction and the actual price the swap is executed at. This difference appears because there&amp;rsquo;s a short (and sometimes long, depending on network congestion and gas costs) delay between when you send a transaction and when it gets mined.</description>
    </item>
    
    <item>
      <title>Liquidity Calculation</title>
      <link>https://uniswapv3book.com/docs/milestone_3/liquidity-calculation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_3/liquidity-calculation/</guid>
      <description>\[ \] Liquidity Calculation # Of the whole math of Uniswap V3, what we haven&amp;rsquo;t yet implemented in Solidity is liquidity calculation. In the Python script, we have these functions:
def liquidity0(amount, pa, pb): if pa &amp;gt; pb: pa, pb = pb, pa return (amount * (pa * pb) / q96) / (pb - pa) def liquidity1(amount, pa, pb): if pa &amp;gt; pb: pa, pb = pb, pa return amount * q96 / (pb - pa) Let&amp;rsquo;s implement them in Solidity so we could calculate liquidity in the Manager.</description>
    </item>
    
    <item>
      <title>A Little Bit More on Fixed-point Numbers</title>
      <link>https://uniswapv3book.com/docs/milestone_3/more-on-fixed-point-numbers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_3/more-on-fixed-point-numbers/</guid>
      <description>\[ \] A Little Bit More on Fixed-point Numbers # In this bonus chapter, I&amp;rsquo;d like to show you how to convert prices to ticks in Solidity. We don&amp;rsquo;t need to do this in the main contracts, but it&amp;rsquo;s helpful to have such function in tests so we don&amp;rsquo;t hardcode ticks and could write something like tick(5000)–this makes code easier to read because it&amp;rsquo;s more convenient for us to think in prices, not tick indexes.</description>
    </item>
    
    <item>
      <title>Flash Loans</title>
      <link>https://uniswapv3book.com/docs/milestone_3/flash-loans/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_3/flash-loans/</guid>
      <description>Flash Loans # Both Uniswap V2 and V3 implement flash loans: unlimited and uncollateralized loans that must be repaid in the same transaction. Pools basically give users arbitrary amounts of tokens that they request, but, by the end of the call, the amounts must be repaid, with a small fee on top.
The fact that flash loans must be repaid in the same transaction means that flash loans cannot be taken by regular users: as a user, you cannot program custom logic in transactions.</description>
    </item>
    
    <item>
      <title>User Interface</title>
      <link>https://uniswapv3book.com/docs/milestone_3/user-interface/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_3/user-interface/</guid>
      <description>\[ \] User Interface # We&amp;rsquo;re now ready to update the UI with the changes we made in this milestone. We&amp;rsquo;ll add two new features:
Add Liquidity dialog window; slippage tolerance in swapping. Add Liquidity Dialog # This change will finally remove hard coded liquidity amounts from our code and will allow use to add liquidity at arbitrary ranges.
The dialog is a simple component with a couple of inputs.</description>
    </item>
    
  </channel>
</rss>
