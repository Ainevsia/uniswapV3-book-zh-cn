<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Milestone 2. 第二笔交易 on Uniswap V3 Book 中文版</title>
    <link>https://uniswapv3book.com/docs/milestone_2/</link>
    <description>Recent content in Milestone 2. 第二笔交易 on Uniswap V3 Book 中文版</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language><atom:link href="https://uniswapv3book.com/docs/milestone_2/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>简介</title>
      <link>https://uniswapv3book.com/docs/milestone_2/introduction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_2/introduction/</guid>
      <description>第二笔交易 # OK，现在才是真正的开始。到目前为止，我们的实现看起来过于手动并且静态。我们手动计算了所有参数，硬编码了各种数量，来让学习曲线不那么陡峭；现在我们准备要让它真正地自动化工作了。我们将会实现第二笔交易，这次的交易是相反的方向：卖出ETH来获得USDC。为了达到这个目的，我们需要大幅度改进我们目前的合约：
我们需要在Solidity中实现数学运算。但是，由于Solidity仅支持整数除法，在Solidity中实现数学运算会比较困难。我们将使用第三方库来完成这部分 我们需要让用户能够选择交易的方向，并且池子合约需要支持双向的交易。我们将会改进合约，离跨价格区间的交易更进一步，而我们将在下一个milestone真正实现它。 最后，我们需要更新我们的UI来实现双向的交易以及获取金额的计算。这需要我们实现另一个合约，报价合约(Quoter)。 在本章节的最后，我们将会获得一个几乎和真正DEX类似的app！
让我们开始吧
本章节的所有代码可以在这个Github branch找到
本章会对我们之前实现的合约进行大量的更新。 在这里你可以看到与上一个milestone的所有代码差别</description>
    </item>
    
    <item>
      <title>输出金额计算</title>
      <link>https://uniswapv3book.com/docs/milestone_2/output-amount-calculation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_2/output-amount-calculation/</guid>
      <description>\[ \] 输出金额计算 # 我们的Uniswap数学公式中还缺最后一个组成部分：计算卖出 ETH (即 token $x$ )时获得的资产数量。在前一章中，我们有一个类似的公式计算购买ETH(购买 token $x$)的场景：
$$\Delta \sqrt{P} = \frac{\Delta y}{L}$$
这个公式计算卖出token $y$时的价格变化。我们把这个差价加到现价上面，来得到目标价格：
$$\sqrt{P_{target}} = \sqrt{P_{current}} + \Delta \sqrt{P}$$
现在，我们需要一个类似的公式来计算卖出 token $x$（在本案例中为 ETH）买入 token $y$（在本案例中为 USDC）时的目标价格（在本案例中为卖出 ETH）。
回忆一下，token $x$ 的变化可以如下计算：
$$\Delta x = \Delta \frac{1}{\sqrt{P}}L$$
从上面公式，我们可以推导出目标价格：
$$\Delta x = (\frac{1}{\sqrt{P_{target}}} - \frac{1}{\sqrt{P_{current}}}) L$$ $$= \frac{L}{\sqrt{P_{target}}} - \frac{L}{\sqrt{P_{current}}}$$
$$\ \sqrt{P_{target}} = \frac{\sqrt{P}L}{\Delta x \sqrt{P} + L}$$
知道了目标价格，我们就能够用前一章类似的方式计算出输出的金额
更新一下对应的Python脚本
# Swap ETH for USDC amount_in = 0.</description>
    </item>
    
    <item>
      <title>Solidity中的数学运算</title>
      <link>https://uniswapv3book.com/docs/milestone_2/math-in-solidity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_2/math-in-solidity/</guid>
      <description>\[ \] Solidity中的数学运算 # 由于Solidity不支持浮点数，在其中的运算会有些复杂。Solidity拥有整数(integer)和无符号整数(unsigned integer)类型，这并不足够让我们实现复杂的数学运算。
另一个困难之处在于gas消耗：一个算法越复杂，它消耗的gas就越多。因此，如果我们需要比较高级的数学运算（例如exp, ln, sqrt），我们会希望它们尽可能节省gas。
还有一个很大的问题是溢出。当进行uint256类型的乘法时，有溢出的风险：结果的数据可能会超出256位。
所有的上述困难都让我们不得不使用那些实现了高级数学运算并进行了gas优化的第三方库。如果库里面没有我们需要的算法，我们就需要自己来实现，这将会是一个很困难的任务。
重用数学库 # 在我们的Uniswap V3实现中，我们会使用两个第三方数学库：
PRBMath，一个包含了复杂的定点数运算的库。我们会使用其中的mulDiv函数来处理乘除法过程中可能的溢出 TickMath，来自原始的Uniswap V3仓库。这个合约实现了两个函数，getSqrtRatioAtTick 和 getTickAtSqrtRatio，功能是在tick和$\sqrt{P}$之间相互转换。 我们先关注第二个库。在我们的合约中，我们需要将tick转换成对应的$\sqrt{P}$，或者反过来。对应的公式为：
$$\sqrt{P(i)} = \sqrt{1.0001^i} = 1.0001^{\frac{i}{2}}$$
$$i = log_{\sqrt{1.0001}}\sqrt{P(i)}$$
这些是非常复杂的数学运算（至少在Solidity中是这样）并且它们需要很高的精度，因为我们不希望取整的问题干扰我们的价格计算。为了能实现更高的精度和gas优化，我们需要特定的实现。
如果你看一下getSqrtRatioAtTick和getTickAtSqrtRatio的代码，你会发现它们非常复杂：其中有大量的magic number（像0xfffcb933bd6fad37aa2d162d1a594001这样），乘法以及位运算。在当前阶段，我们不会试图分析这些代码或者尝试重新实现它们，因为这会是另一个不同的且复杂的主题。我们在这里仅仅使用它们。在后续的章节中，我们可能会深入探讨这部分代码。</description>
    </item>
    
    <item>
      <title>Tick Bitmap Index</title>
      <link>https://uniswapv3book.com/docs/milestone_2/tick-bitmap-index/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_2/tick-bitmap-index/</guid>
      <description>\[ \] Tick Bitmap Index # (译者注：由于bitmap也是数据结构中的常见名词，所以在此不做翻译)
作为我们开始动态交易的第一步，我们需要建立一个ticks的索引。在前一个milestone中，我们手动计算并硬编码了目标位置的tick：
function swap(address recipient, bytes calldata data) public returns (int256 amount0, int256 amount1) { int24 nextTick = 85184; ... } 当流动性在不同的价格区间中时，我们很难简单地计算出目标tick。事实上，我们需要根据不同区间中的流动性来找到它。因此，我们需要对于所有拥有流动性的tick建立一个索引，之后使用这个索引来寻找tick直到“填满”当前交易所需的流动性。在本小节中，我们将会实现一个这样的索引。
Bitmap # Bitmap是一个用压缩的方式提供数据索引的常用数据结构。一个bitmap实际上就是一个0和1构成的数组，其中的每一位的位置和元素内容都代表某种外部的信息。每个元素可以是0或者1，可以被看做是一个flag：当值为0的时候，flag没有设置；当值为1的时候，flag被设置。这个方法受欢迎的原因是整个数组可以作为二进制被存在一个数字中。
例如，数组111101001101001就是数字31337。这个数字需要两个字节来存储（0x7a69），两字节能够存储16个flag（1字节=8位）。
Uniswap V3 使用这个技术来存储关于tick初始化的信息，也即哪个tick有流动性。当flag设置为(1)，对应的tick有流动性；当flag设置为(0)，对应的tick没有被初始化。让我们来看一下如何实现。
TickBitmap合约 # 在池子合约中，tick index存储为一个状态变量：
contract UniswapV3Pool { using TickBitmap for mapping(int16 =&amp;gt; uint256); mapping(int16 =&amp;gt; uint256) public tickBitmap; ... } 这里的存储方式是一个mapping，key的类型是int16，value的类型是uint256。想象一个无穷的0/1数组：
数组中每个元素都对应一个tick。为了更好地在数组中寻址，我们把数组按照字的大小划分：每个子数组为256位。为了找到数组中某个tick的位置，我们使用如下函数：
function position(int24 tick) private pure returns (int16 wordPos, uint8 bitPos) { wordPos = int16(tick &amp;gt;&amp;gt; 8); bitPos = uint8(uint24(tick % 256)); } 即：我们首先找到对应的字所在的位置，然后再找到字中的位的位置。&amp;gt;&amp;gt;8即除以256。除以256的商为字的位置，余数为位的位置。</description>
    </item>
    
    <item>
      <title>通用mint</title>
      <link>https://uniswapv3book.com/docs/milestone_2/generalize-minting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_2/generalize-minting/</guid>
      <description>\[ \] 通用mint # 现在，我们可以更新mint函数来直接在Solidity中进行计算而不需要手动计算并硬编码了。
初始化tick与更新 # 还记得在mint函数中，我们更新TickInfo这个mapping来存储tick中可用的流动性信息。现在，我们将会使用新的bitmap索引来进行这一步——我们之后会用这个新的索引来在交易中寻找下一个可用tick。
首先，我们需要更新Tick.update函数：
// src/lib/Tick.sol function update( mapping(int24 =&amp;gt; Tick.Info) storage self, int24 tick, uint128 liquidityDelta ) internal returns (bool flipped) { ... flipped = (liquidityAfter == 0) != (liquidityBefore == 0); ... } 现在，它会返回一个flipped flag，当流动性被添加到一个空的tick或整个tick的流动性被耗尽时为true。
接下来，在mint函数中，我们更新bitmao索引：
// src/UniswapV3Pool.sol ... bool flippedLower = ticks.update(lowerTick, amount); bool flippedUpper = ticks.update(upperTick, amount); if (flippedLower) { tickBitmap.flipTick(lowerTick, 1); } if (flippedUpper) { tickBitmap.flipTick(upperTick, 1); } ... 再次说明，在Milestone 4之前，TickSpacing参数的值会始终为1.</description>
    </item>
    
    <item>
      <title>通用swap</title>
      <link>https://uniswapv3book.com/docs/milestone_2/generalize-swapping/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_2/generalize-swapping/</guid>
      <description>\[ \] 通用swap # 本节将会是这个milestone中最难的一个部分。在更新代码之前，我们首先需要知道Uniswap V3中的swap是如何工作的。
我们可以把一笔交易看作是满足一个订单：一个用户提交了一个订单，需要从池子中购买一定数量的某种token。池子会使用可用的流动性来将投入的token数量“转换”成输出的token数量。如果在当前价格区间中没有足够的流动性，它将会尝试在其他价格区间中寻找流动性（使用我们前一节实现的函数）。
现在，我们要实现swap函数内部的逻辑，但仍然保证交易可以在当前价格区间内完成——跨tick的交易将会在下一个milestone中实现。
function swap( address recipient, bool zeroForOne, uint256 amountSpecified, bytes calldata data ) public returns (int256 amount0, int256 amount1) { ... 在swap函数中，我们新增了两个参数：zeroForOne 和 amountSpecified。zeroForOne 是用来控制交易方向的 flag：当设置为true，是用 token0 兑换 token1；false则相反。例如，如果token0 是ETH，token1 是USDC，将 zeroForOne 设置为true意味着用 USDC 购买 ETH。amountSpecified 是用户希望卖出的token数量。
填满订单 # 由于在Uniswap V3中，流动性存储在不同的价格区间中，池子合约需要找到“填满当前订单”所需要的所有流动性。这个操作是通过沿着某个方向遍历所有初始化的tick来实现的。
在继续之前，我们需要定义两个新的结构体：
struct SwapState { uint256 amountSpecifiedRemaining; uint256 amountCalculated; uint160 sqrtPriceX96; int24 tick; } struct StepState { uint160 sqrtPriceStartX96; int24 nextTick; uint160 sqrtPriceNextX96; uint256 amountIn; uint256 amountOut; } SwapState 维护了当前swap的状态。amoutSpecifiedRemaining 跟踪了还需要从池子中获取的token数量：当这个数量为0时，这笔订单就被填满了。amountCalculated 是由合约计算出的输出数量。sqrtPriceX96 和 tick 是交易结束后的价格和tick。</description>
    </item>
    
    <item>
      <title>报价合约</title>
      <link>https://uniswapv3book.com/docs/milestone_2/quoter-contract/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_2/quoter-contract/</guid>
      <description>报价合约 # 为了让我们的池子合约能够集成到前端，我们需要一种方式能够在交易之前就计算出对应的数量。用户会输入它们希望卖出的token数量，然后就能计算并且展示出它们会获得的token数量。我们将通过报价合约来实现这一功能。
由于Uniswap V3中的流动性是分散在多个价格区间中的，我们不能够仅仅通过一个公式计算出对应数量（像在Uniswap V2中那样）。Uniswap V3的设计需要我们用一种不同的方法：为了获得交易数量，我们初始化一个真正的交易，并且在callback函数中打断它，获取到之前计算出的对应数量。也就是，我们将会模拟一笔真实的交易来计算输出数量！
我们会创建这样一个辅助合约：
contract UniswapV3Quoter { struct QuoteParams { address pool; uint256 amountIn; bool zeroForOne; } function quote(QuoteParams memory params) public returns ( uint256 amountOut, uint160 sqrtPriceX96After, int24 tickAfter ) { ... Quoter 合约仅实现了一个public的函数——quote。Quoter是一个对于所有池子的通用合约，因此它将池子地址作为一个参数。其他参数（amountIn 和 zeroForOne）都是模拟swap需要的参数。
try IUniswapV3Pool(params.pool).swap( address(this), params.zeroForOne, params.amountIn, abi.encode(params.pool) ) {} catch (bytes memory reason) { return abi.decode(reason, (uint256, uint160, int24)); } 这个函数唯一实现的功能是调用池子合约的 swap 函数。这个调用应当revert（即抛出异常）——我们将会在callback中实现这一点。当revert发生的时候，对应的reason会解码并且返回。quote永远不会revert。注意到，在data字段，我们仅仅传入和合约的地址——因为在callback函数中，我们需要用它来获取对应池子的slot0。
function uniswapV3SwapCallback( int256 amount0Delta, int256 amount1Delta, bytes memory data ) external view { address pool = abi.</description>
    </item>
    
    <item>
      <title>用户界面</title>
      <link>https://uniswapv3book.com/docs/milestone_2/user-interface/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_2/user-interface/</guid>
      <description>用户界面 # 现在，我们可以让我们的web应用看起来更像一个真正的DEX了。我们可以移除那些硬编码的数额，并且允许用户输入任意的数量。同样，我们还可以让用户在任意一个方向交易，所以我们需要一个按钮来改变交易方向。在更新之后，swap 的表单长这样：
&amp;lt;form className=&amp;#34;SwapForm&amp;#34;&amp;gt; &amp;lt;SwapInput amount={zeroForOne ? amount0 : amount1} disabled={!enabled || loading} readOnly={false} setAmount={setAmount_(zeroForOne ? setAmount0 : setAmount1, zeroForOne)} token={zeroForOne ? pair[0] : pair[1]} /&amp;gt; &amp;lt;ChangeDirectionButton zeroForOne={zeroForOne} setZeroForOne={setZeroForOne} disabled={!enabled || loading} /&amp;gt; &amp;lt;SwapInput amount={zeroForOne ? amount1 : amount0} disabled={!enabled || loading} readOnly={true} token={zeroForOne ? pair[1] : pair[0]} /&amp;gt; &amp;lt;button className=&amp;#39;swap&amp;#39; disabled={!enabled || loading} onClick={swap_}&amp;gt;Swap&amp;lt;/button&amp;gt; &amp;lt;/form&amp;gt; 每个输入都根据交易方向赋值给一个变量，交易方向由 zeroForOne 这个状态来控制。下面的输入空间总是只读的，因为这部分的数字是由报价合约计算出来。
setAmount_ 函数做了两件事：更新上面输入框中的值，调用报价合约来计算下面输入框中的值
const updateAmountOut = debounce((amount) =&amp;gt; { if (amount === 0 || amount === &amp;#34;0&amp;#34;) { return; } setLoading(true); quoter.</description>
    </item>
    
  </channel>
</rss>
