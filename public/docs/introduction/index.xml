<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Milestone 0. 简介 on Uniswap V3 Book 中文版</title>
    <link>https://uniswapv3book.com/docs/introduction/</link>
    <description>Recent content in Milestone 0. 简介 on Uniswap V3 Book 中文版</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language><atom:link href="https://uniswapv3book.com/docs/introduction/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>交易市场简介</title>
      <link>https://uniswapv3book.com/docs/introduction/introduction-to-markets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/introduction/introduction-to-markets/</guid>
      <description>交易市场简介 # 中心化交易所(CEX)如何工作 # 在本书中，我们将会搭建一个运行在以太坊(Ethereum)上的去中心化交易所(DEX)。DEX的设计模式非常复杂多样，因此我们先来考虑中心化交易所的设计。中心化交易所(CEX)的核心为订单簿(order book)，存储了用户的所有买单和卖单。订单簿中的每一笔订单都包含了订单成交的价格以及成交数量。
交易能够正常进行的保障是流动性(liquidity)，也即整个市场中所有可获得的资产数目。假设你希望购买一个衣柜但是没有人售卖，即为没有流动性；如果你希望卖出一个衣柜但是没有人愿意购买，即为市场有流动性但是没有买方。没有流动性，就无法在市场中进行买卖。
在CEX中，流动性存放在订单簿中。如果某个用户提交了一个卖单，他就为市场提供了流动性；如果某人提交了一个买单，他们希望市场有流动性，否则交易就无法进行。
如果市场没有流动性，但是仍然希望进行交易，就需要做市商(market maker)。做市商是向市场提供流动性的，拥有大量各种资产的公司或个人。通过提供流动性，做市商能够从交易中获取利润。
去中心化交易所(DEX)如何工作 # 毫无疑问，去中心化的交易也需要流动性，并且也需要做市商向市场提供多种资产的流动性。然而，在DEX中这个过程无法被中心化地处理，我们需要一种去中心化的做市商方案。相关解决方案非常多样化，而本书将主要关注Uniswap提供的方案。
自动做市商(AMM) # 链上交易市场的历史 一文提到了一种称作自动做市商(Automated Market Maker)的思路。正如其名，这种算法能够自动化完成像做市商一样的工作。更进一步，这种算法是去中心化且无需许可的，也即：
没有被任何单个中心化机构控制 所有资产并不存储在同一地方 任何人在任何地点都能使用 什么是自动做市商AMM？ # 一个AMM是一套定义如何管理流动性的智能合约。每个单独的交易对（例如ETH/USDC）都是一个单独的智能合约，存储了ETH和USDC的资产并且撮合交易，在这个合约中我们可以将ETH兑换成USDC或者将USDC兑换成ETH。
在AMM中，一个核心思想为池子(pooling)：每个合约都是一个存储流动性的池子，允许不同的用户（包括其他合约）在其中进行某种方式的交易。在AMM中有两种角色，*流动性提供者(LP)*以及交易者；这两者通过流动性池进行交互，交互的方式由合约进行规定且不可更改。
这种方法与CEX的关键区别在于： 智能合约是完全自动化的并且不受任何人控制。没有经理，没有系统管理员，没有特权用户，一切都没有。这里只有LP和交易者，任何人都可以担任这两种角色（也可以同时），并且所有的算法都是公开的、程序规定的、不可更改的。
在后面的篇章，我们将更进一步了解Uniswap是如何实现AMM的。
注意在后文中，pool和pair两个词可能会被交替使用，因为一个Uniswap的流动性池即一对token</description>
    </item>
    
    <item>
      <title>恒定函数做市商(CFMM)</title>
      <link>https://uniswapv3book.com/docs/introduction/constant-function-market-maker/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/introduction/constant-function-market-maker/</guid>
      <description>\[ \] 恒定函数做市商 (Constant Function Market Makers) # 本章节主要讲述了Uniswap V2白皮书中的内容. 理解其中的数学原理能帮助你更好地构建像Uniswap这样的应用, 不过假设你没有理解本章全部内容也没有关系
正如我们在上一节中提到的那样，AMM的构建有许多不同的方法。我们将主要关注与构建一种特定的AMM：恒定函数做市商（有时也被称为恒定乘积做市商）。尽管名字听起来很复杂，但是它的核心数学原理只是一个非常简单的公式：
$$x * y = k$$
仅此而已，这就是AMM.
$x$ 和 $y$ 是池子合约所拥有的两种资产的数目。$k$ 是它们的乘积，我们暂时不考虑它的实际值等于多少。
为什么只有两种资产x和y？ 每个Uniswap的池子仅包含两种token。我们使用x和y来表示一个池子中的两种资产，其中x代表第一个token，y代表第二个token。两种token的顺序并不重要。
恒定函数做市商的原理是：在每次交易后，k必须保持不变。当用户进行交易，他们通常将一种类型的token放入池子（也即他们打算卖出的token），并且将另一种类型的token移出池子（也即打算购买的token）。这笔交易会改变池子中两种资产的数量，而上述原理表示，两种资产数目的乘积必须保持不变。我们之后还会在本书中看到许多次这个原理，这就是Uniswap的核心机制。
交易函数 # 现在我们知道了什么是池子以及交易的原理，接下来我们写一下交易发生时的公式：
$$(x + r\Delta x)(y - \Delta y) = k$$
一个池子包含一定数量的token 0 ($x$)和一定数量的token 1 ($y$) 当我们用token 0购买token 1的时候，一些token 0被放入池子 ($\Delta x$) 这个池子将给我们一定数量的token 1作为交换 ($\Delta y$) 池子也会从我们付出的token 0中收取一定数量的手续费 ($r$) 池子中token 0的数量发生了变化 ($x + r \Delta x$)， token 1的数量也发生了变化 ($y - \Delta y$) 二者的乘积保持不变，仍然为 $k$ 我们使用token 0和token 1这样的表述是因为代码中就是如此命名的。在现在，两个token的顺序并不关键</description>
    </item>
    
    <item>
      <title>Uniswap V3</title>
      <link>https://uniswapv3book.com/docs/introduction/uniswap-v3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/introduction/uniswap-v3/</guid>
      <description>\[ \] Uniswap V3简介 # 本章节主要讲述了Uniswap V3白皮书中的内容。同样，假设你没有理解本章的所有概念也没有关系，我们在后面章节直接看代码可能会更清晰。
为了更好地理解Uniswap V3的创新之处在哪里，我们首先来看Uniswap V2的缺点有哪些。
Uniswap V2使用AMM机制实现了一个通用的交易市场。然而，并不是所有的交易对都是平等的，交易对可以根据价格的波动性分为以下两类
价格波动性为中等或高的代币对。这一类包含绝大多数的代币，因为绝大多数代币并没有锚定(pegged to)到某些东西，因此其价格随着市场波动而波动。 价格波动性低的代币对。这一类包含了有锚定的代币，主要为稳定币：USDT/USDC，USDC/DAI，USDT/DAI等等。也包括ETH/stETH，ETH/rETH（一些wrapped ETH）等类型。 这些类对于我们称作“流动性池配置”的概念有不同的要求。最主要的区别在于，锚定代币对需要非常高的流动性来降低大额交易对其的影响。USDC与USDT的价格必须保持在1附近，无论我要买卖多大数目的代币。由于Uniswap V2的通用AMM算法对于稳定币交易并没有很好的适配，其他的AMM（主要是Curve）则在稳定币交易中更加流行。
导致这个问题出现的原因在于，Uniswap V2池子的流动性是分布在无穷区域上的-即池子允许在任何价格的交易发生，从0到正无穷：
这听起来不是一个坏事，但事实上它导致了资本利用效率的不足。一个资产的历史价格通常是在某个区间内的，不管这个区间是大还是小。比如，ETH的历史价格大致在$0.75 到 $4,800 这个区间（数据来源CoinMarketCap）。在今天（2022年6月，1个ETH的现货价格是$1800，没有人会愿意用$5000购买一个ETH，所以在这个点提供流动性是毫无用处的。因此，在远离当前价格区间的、永远不会达到的某个点上提供流动性是毫无意义的
当然，我们都相信ETH的价格某天会达到$10000 （译者注：仅代表原作者观点）
集中流动性 # Uniswap V3引入了 集中流动性(concentrated liquidity) 的概念：LP可以选择他们希望在哪个价格区间提供流动性。这个机制通过将更多的流动性提供在一个相对狭窄的价格区间，从而大大提高了资本利用效率；这也使Uniswap的使用场景更加多样化：它现在可以对于不同价格波动性的池子进行不同的配置。这就是V3相对于V2的提升点。
简单地来说，一个Uniswap V3的交易对是许多个Uniswap V2的交易对。V2与V3的区别是，在V3中，一个交易对有许多的价格区间，而每个价格区间内都有有限数量的资产。从零到正无穷的整个价格区间被划分成了许多个小的价格区间，每一个区间中都有一定数量的流动性。而更关键的点在于，在每个小的价格区间中，工作机制与Uniswap V2一样。这也是为什么说一个Uniswap V3的池子就是许多个V2的池子。
下面，我们来对这种机制进行可视化。我们并不是重新选择一个有限的曲线，而是我们把它在价格$a$ 与价格$b$ 之间的部分截取出来，认为它们是曲线的边界。更进一步，我们把曲线进行平移使得边界点落在坐标轴上，于是得到了下图：
它看起来或许有点孤单， 因此Uniswap V3有许多的价格区间——这样它们就不会感到孤单了 🙂
正如我们在前一章中讲到的那样，交易token使得价格在曲线上移动，而价格区间限制了价格点的移动。当价格移动到曲线的一端时，我们说这个池子被耗尽了：其中一种代币的资产变成了0，无法再购买这种代币（当然，仅仅指在这个价格区间内）
假设起始价格在上面途中曲线的中间点。为了到达点$a$，我们需要购买池子里所有的$y$来使得池子里的$x$最大化；为了到达点$b$，我们需要买光池子里的$x$从而使$y$最大化。在这两个点，池子里都只剩一种token。
一个有趣的点：根据这个原理，可以利用V3的价格区间来挂限价单
如果当前价格区间池子被耗尽将会发生什么？价格点会滑动到下一个价格区间。如果下一个价格区间不存在，这笔交易就会以部分成交而结束——我们将在本书后面的部分看到其如何实现。
下面一图展示了USDC/ETH池子的流动性分布:
可以看到，大量流动性集中在现在价格的附近，而较远的价格区间中的流动性较少——这是因为LP更希望提高它们的资产利用效率。当然，整个区间也不是无穷的，在图片右侧也显示了其上界。
Uniswap V3的数学原理 # 在数学原理上，V3是基于V2的：它们使用了相同的底层公式，但实际上V3使用的是可以被称作增强版。
为了处理价格区间之间的转换，简化流动性管理，以及避免取整出现问题，V3使用了下面这些新的标识：
$$L = \sqrt{xy}$$
$$\sqrt{P} = \sqrt{\frac{y}{x}}$$
$L$ 被称作 流动性数量。池子中的流动性是两种token资产数量的组合。我们知道按照公式，两种代币数量乘积为$k$，因此我们可以用 $\sqrt{xy}$ 来衡量池子流动性。$L$ 实际上是 $x$ 和 $y$ 的几何平均数。</description>
    </item>
    
    <item>
      <title>开发环境</title>
      <link>https://uniswapv3book.com/docs/introduction/dev-environment/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/introduction/dev-environment/</guid>
      <description>开发环境 # 本书中，我们会搭建两个应用：
链上：一套部署在以太坊上的智能合约 链下：一个与智能合约交互的前端应用 尽管本书把前端应用作为其中一部分，但不是我们的主要关注点。我们搭建前端仅仅为了展示智能合约是如何集成到前端应用中的。因为，前端部分是可选读内容，但在本书代码仓库中也提供者这部分的代码
以太坊简介 # 以太坊是一个允许任何人在上面运行应用的区块链。它与一个传统云服务的主要区别在于：
维持这个应用不需要付费，部署应用需要付费 应用代码是不可变的，在其部署后你没有办法再进行修改 用户调用你的应用需要花费gas（手续费） 为了更好地理解这些区别，我们来看一下以太坊的构建。
以太坊的核心（其他区块链也是同理）是一个数据库。这个数据库中最有价值的数据是账户状态。以太坊中的每个账户包含一个地址，以及以下数据：
余额：账户的以太坊(ether)余额 代码：部署在这个地址上的智能合约的字节码 存储：智能合约存储数据的空间 nonce：一个用来防止重放攻击的整数序号 （译者注：Ethereum和ether的中文译名均为以太坊，读者注意区分。Ethereum指的是这条区块链，ether指的是该链上的原生代币）
以太坊的主要任务是安全地维护这些数据，防止未经授权的更改。
同时，以太坊也是一个网络，网络中的每个计算机都独立地构建和维持这些状态。网络的主要目标是能够去中心化地访问数据库：没有任何单个权威机构可以单方面修改任何数据。这是通过叫做*共识(consensus)*的机制来实现的，即网络中节点遵守的一系列规则。如果有节点违反了规则，它将会被从这个网络中排除。
有趣的是，区块链也可以使用MSQL！只是可能会存在一定的性能问题。以太坊中使用的是LevelDB，一个高效的KV数据库。
每个以太坊节点运行EVM，以太坊虚拟机。虚拟机是一个能够执行其他程序的程序，EVM则是执行智能合约程序的程序。用户通过交易(transactions)与合约交互，除了能够简单的发送ether，交易也能够调用智能合约，需要传输的数据包括：
一个合约函数的签名 函数参数 交易被打包进区块，区块被矿工挖出。网络中的每个节点都可以验证每一个区块中的每一笔交易。
某种意义上来说，智能合约与JSON APIs有一定类似，区别就是你调用的是智能合约函数。与API的后端类似，智能合约也执行程序逻辑，并且也可能更改智能合约中存储的数据。与API不同的是，你需要发送一笔交易来改变区块链的状态，并且你需要为每一笔交易付费。
最后，以太坊节点也实现了一套JSON-RPC API。我们可以通过这个API与节点进行交互：获取账户余额、估算gas费、获取区块和交易、发送交易、执行不上链的智能合约调用（仅能读数据）。在这里你可以获得一个可用端点的列表。
交易也是通过这个API发送的, 参见 eth_sendTransaction.
本地开发环境 # 我们将要搭建智能合约并且在以太坊上运行它们，这意味着我们需要一个节点。在本地测试和运行合约也需要一个节点。曾经这使得智能合约开发十分麻烦，因为在一个真实节点上运行大量的测试会十分缓慢。不过现在已经有了很多快速简洁的解决方案。例如Truffle 和 Hardhat。不过这些工具的问题在于我们需要用JavaScript来写测试以及与区块链的交互，这事因为Truffle和Hardhat都运行了一个本地节点，并且使用JavaScript的Web3库来与节点交互。
我们将会选择一个新的框架，Foundry。
Foundry # Foundry是一套用于以太坊应用开发的工具包。我们将会使用以下这些工具：
Forge，一个Solidity的测试框架. Anvil，一个本地以太坊节点。我们将会用它来部署我们的合约，并且与前端app交互。 Cast, 一个非常好用的CLI工具。 Forge使智能合约开发更加容易。当使用Forge开发时，我们不需要运行一个本地节点来进行测试；Forge会在其内置的EVM上运行测试，大大加快了速度，不再需要给节点发送交易和挖出区块。除此以外，Forge还能够使用Solidity编写测试！Forge也内置了机制方便我们模拟区块链的各种状态：修改某个账户余额，从其他地址执行合约，把合约部署在任意地址等等。
然而，我们仍然需要一个本地节点来部署合约。在这里我们将会使用Anvil。前端应用可以使用JavaScript的Web3库来与以太坊节点进行交互。
Ethers.js # Ethers.js 是一个与Ethereum交互的JavaScript库. 这是Dapp开发中使用的两个最流行的JS库之一(另一个是web3.js)。这些库让我们可以使用JSON-API与以太坊节点交互，并且也有各种功能丰富的函数来帮助开发者更容易地开发应用。
MetaMask # MetaMask是一个浏览器中的以太坊钱包。它是一个浏览器插件，可以安全地创建和存储私钥。Metamask也是最常用的以太坊钱包应用，我们将使用它来与我们的本地运行的节点进行交互。
React # React 是前端开发中使用的一个著名的JS库. 本书并不要求会React，我们将会提供一个模板。、
准备开发环境 # 创建一个新的文件夹，并在其中运行 forge init ：
$ mkdir uniswapv3clone $ cd uniswapv3clone $ forge init 如果你使用Visual Studio Code进行开发，可以在forge init 中加入 --vscode 这个flas：forge init --vscode。Forge会在初始化时对于VSCode进行特别设置。</description>
    </item>
    
  </channel>
</rss>
