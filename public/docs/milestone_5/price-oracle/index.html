<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="\[ \] Price Oracle # The final mechanism we&rsquo;re going to add to our DEX is a price oracle. Even though it&rsquo;s not essential to a DEX (there are DEXes that don&rsquo;t implement a price oracle), it&rsquo;s still an important feature of Uniswap and something that&rsquo;s interesting to learn about.
What is Price Oracle? # Price oracle is a mechanism that provides asset prices to blockchain. Since blockchains are isolated ecosystems, there&rsquo;s no direct way of querying external data, e.">
<meta name="theme-color" content="#FFFFFF">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="Price Oracle" />
<meta property="og:description" content="\[ \] Price Oracle # The final mechanism we&rsquo;re going to add to our DEX is a price oracle. Even though it&rsquo;s not essential to a DEX (there are DEXes that don&rsquo;t implement a price oracle), it&rsquo;s still an important feature of Uniswap and something that&rsquo;s interesting to learn about.
What is Price Oracle? # Price oracle is a mechanism that provides asset prices to blockchain. Since blockchains are isolated ecosystems, there&rsquo;s no direct way of querying external data, e." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://uniswapv3book.com/docs/milestone_5/price-oracle/" /><meta property="article:section" content="docs" />



<title>Price Oracle | Uniswap V3 Book 中文版</title>
<link rel="manifest" href="https://uniswapv3book.com/manifest.json">
<link rel="icon" href="https://uniswapv3book.com/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="https://uniswapv3book.com/book.min.82c5dbd23447cee0b4c2aa3ed08ce0961faa40e1fa370eee4f8c9f02e0d46b5f.css" integrity="sha256-gsXb0jRHzuC0wqo&#43;0Izglh&#43;qQOH6Nw7uT4yfAuDUa18=" crossorigin="anonymous">
  <script defer src="https://uniswapv3book.com/flexsearch.min.js"></script>
  <script defer src="https://uniswapv3book.com/en.search.min.7bcb9cc1edbdbe78ffa7aeda28e09d51033768c24a465538e9da7066e43237d4.js" integrity="sha256-e8ucwe29vnj/p67aKOCdUQM3aMJKRlU46dpwZuQyN9Q=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="https://uniswapv3book.com/"><span>Uniswap V3 Book 中文版</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  



  
  <ul>
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Milestone 0. 简介</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/introduction/introduction-to-markets/" class="">交易市场简介</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/introduction/constant-function-market-maker/" class="">恒定函数做市商(CFMM)</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/introduction/uniswap-v3/" class="">Uniswap V3</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/introduction/dev-environment/" class="">开发环境</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Milestone 1. 第一笔交易</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_1/introduction/" class="">简介</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_1/calculating-liquidity/" class="">计算流动性</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_1/providing-liquidity/" class="">提供流动性</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_1/first-swap/" class="">第一笔交易</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_1/manager-contract/" class="">管理合约</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_1/deployment/" class="">部署合约</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_1/user-interface/" class="">用户界面</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Milestone 2. 第二笔交易</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_2/introduction/" class="">简介</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_2/output-amount-calculation/" class="">输出金额计算</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_2/math-in-solidity/" class="">Solidity中的数学运算</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_2/tick-bitmap-index/" class="">Tick Bitmap Index</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_2/generalize-minting/" class="">通用mint</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_2/generalize-swapping/" class="">通用swap</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_2/quoter-contract/" class="">报价合约</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_2/user-interface/" class="">用户界面</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Milestone 3. 跨tick交易</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_3/introduction/" class="">简介</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_3/different-ranges/" class="">不同价格区间</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_3/cross-tick-swaps/" class="">Cross-Tick Swaps</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_3/slippage-protection/" class="">Slippage Protection</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_3/liquidity-calculation/" class="">Liquidity Calculation</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_3/more-on-fixed-point-numbers/" class="">A Little Bit More on Fixed-point Numbers</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_3/flash-loans/" class="">Flash Loans</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_3/user-interface/" class="">User Interface</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Milestone 4. Multi-pool Swaps</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_4/introduction/" class="">Introduction</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_4/factory-contract/" class="">Factory Contract</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_4/path/" class="">Swap Path</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_4/multi-pool-swaps/" class="">Multi-pool Swaps</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_4/user-interface/" class="">User Interface</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_4/tick-rounding/" class="">Tick Rounding</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Milestone 5. Fees and Price Oracle</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_5/introduction/" class="">Introduction</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_5/swap-fees/" class="">Swap Fees</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_5/flash-loan-fees/" class="">Flash Loan Fees</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_5/protocol-fees/" class="">Protocol Fees</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_5/price-oracle/" class="active">Price Oracle</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_5/user-interface/" class="">User Interface</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Milestone 6: NFT positions</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_6/introduction/" class="">Introduction</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_6/erc721-overview/" class="">ERC721 Overview</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_6/nft-manager/" class="">NFT Manager</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_6/nft-renderer/" class="">NFT Renderer</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>补充资料</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/reference/dictionary/" class="">中英名词对照</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>















</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="https://uniswapv3book.com/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>Price Oracle</strong>

  <label for="toc-control">
    
    <img src="https://uniswapv3book.com/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#price-oracle">Price Oracle</a>
      <ul>
        <li><a href="#what-is-price-oracle">What is Price Oracle?</a></li>
        <li><a href="#how-uniswap-price-oracle-works">How Uniswap Price Oracle Works</a></li>
        <li><a href="#price-manipulation-mitigation">Price Manipulation Mitigation</a></li>
        <li><a href="#price-oracle-implementation">Price Oracle Implementation</a>
          <ul>
            <li><a href="#observations-and-cardinality">Observations and Cardinality</a></li>
            <li><a href="#writing-observations">Writing Observations</a></li>
            <li><a href="#increase-of-cardinality">Increase of Cardinality</a></li>
            <li><a href="#reading-observations">Reading Observations</a></li>
            <li><a href="#interpreting-observations">Interpreting Observations</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown">
<link rel="stylesheet" href="https://uniswapv3book.com/katex/katex.min.css" />
<script>
  function renderKatex(element) {
    renderMathInElement(document.body, {
      delimiters: [
        { left: '$$', right: '$$', display: true },
        { left: '$', right: '$', display: false },
        { left: '\\(', right: '\\)', display: false },
        { left: '\\[', right: '\\]', display: true }
      ],
      
      throwOnError: false
    });
  }
</script>
<script defer src="https://uniswapv3book.com/katex/katex.min.js"></script>
<script defer src="https://uniswapv3book.com/katex/auto-render.min.js" onload="renderKatex(document.body)"></script><span>
  \[ \]
</span>
<h1 id="price-oracle">
  Price Oracle
  <a class="anchor" href="#price-oracle">#</a>
</h1>
<p>The final mechanism we&rsquo;re going to add to our DEX is a <em>price oracle</em>. Even though it&rsquo;s not essential to a DEX (there
are DEXes that don&rsquo;t implement a price oracle), it&rsquo;s still an important feature of Uniswap and something that&rsquo;s
interesting to learn about.</p>
<h2 id="what-is-price-oracle">
  What is Price Oracle?
  <a class="anchor" href="#what-is-price-oracle">#</a>
</h2>
<p>Price oracle is a mechanism that provides asset prices to blockchain. Since blockchains are isolated ecosystems, there&rsquo;s
no direct way of querying external data, e.g. fetching asset prices from centralized exchanges via API. Another, a very
hard one, problem is data validity and authenticity: when fetching prices from an exchange, how do you know they&rsquo;re real?
You have to trust the source. But the internet is not often secure and, sometimes, prices can be manipulated, DNS records
can be hijacked, API servers can go down, etc. All these difficulties need to be addressed so we could have reliable and
correct on-chain prices.</p>
<p>One of the first working solution of the above mentioned problems was <a href="https://chain.link/">Chainlink</a>. Chainlink runs
a decentralized network of oracles that fetch asset prices from centralized exchanges via APIs, average them, and provide
them on-chain in a tamper-proof way. Basically, Chainlink is a set of contracts with one state variable, asset price,
that can be read by anyone (any other contract or user) but can be written to only by oracles.</p>
<p>This is one way of looking at price oracles. There&rsquo;s another.</p>
<p>If we have native on-chain exchanges, why would we need to fetch prices from outside? This is how the Uniswap price oracle
works. Thanks to arbitraging and high liquidity, asset prices on Uniswap are close to those on centralized exchanges. So,
instead of using centralized exchanges as the source of truth for asset prices, we can use Uniswap, and we don&rsquo;t need to
solve the problems related to delivering data on-chain (we also don&rsquo;t need to trust to data providers).</p>
<h2 id="how-uniswap-price-oracle-works">
  How Uniswap Price Oracle Works
  <a class="anchor" href="#how-uniswap-price-oracle-works">#</a>
</h2>
<p>Uniswap simply keeps the record of all previous swap prices. That&rsquo;s it. But instead of tracking actual prices, Uniswap
tracks the <em>accumulated price</em>, which is the sum of prices at each second in the history of a pool contract.</p>
<p>$$a_{i} = \sum_{i=1}^t p_{i}$$</p>
<p>This approach allows to find <em>time-weighted average price</em> between two points in time ($t_1$ and $t_2$) by simply
getting the accumulated prices at these points ($a_{t_1}$ and $a_{t_2}$), subtracting one from the other, and dividing
by the number of seconds between the two points:</p>
<p>$$p_{t_1,t_2} = \frac{a_{t_2} - a_{t_1}}{t_2 - t_1}$$</p>
<p>This is how it worked in Uniswap V2. In V3, it&rsquo;s slightly different. The price that&rsquo;s accumulated is the current tick
(which is $log_{1.0001}$ of the price):</p>
<p>$$a_{i} = \sum_{i=1}^t log_{1.0001}P(i)$$</p>
<p>And instead of averaging prices, <em>geometric mean</em> is taken:</p>
<p>$$ P_{t_1,t_2} = \left( \prod_{i=t_1}^{t_2} P_i \right) ^ \frac{1}{t_2-t_1} $$</p>
<p>To find the time-weighted geometric mean price between two points in time, we take the accumulated values at these time
points, subtract one from the other, divide by the number of seconds between the two points, and calculate $1.0001^{x}$:</p>
<p>$$ log_{1.0001}{(P_{t_1,t_2})} = \frac{\sum_{i=t_1}^{t_2} log_{1.0001}(P_i)}{t_2-t_1}$$
$$ = \frac{a_{t_2} - a_{t_1}}{t_2-t_1}$$</p>
<p>$$P_{t_1,t_2} = 1.0001^{\frac{a_{t_2} - a_{t_1}}{t_2-t_1}}$$</p>
<p>Uniswap V2 didn&rsquo;t store historical accumulated prices, which required referring to a third-party blockchain data indexing
service to find a historical price when calculating an average one. Uniswap V3, on the other hand, allows to store up
to 65,535 historical accumulated prices, which makes it much easier to calculate any historical time-weighter geometric
price.</p>
<h2 id="price-manipulation-mitigation">
  Price Manipulation Mitigation
  <a class="anchor" href="#price-manipulation-mitigation">#</a>
</h2>
<p>Another important topic is price manipulation and how it&rsquo;s mitigated in Uniswap.</p>
<p>It&rsquo;s theoretically possible to manipulate a pool&rsquo;s price to your advantage: for example, buy a big amount of tokens to
raise its price and get a profit on a third-party DeFi service that uses Uniswap price oracles, then trade the tokens
back to the real price. To mitigate such attacks, Uniswap tracks prices <strong>at the end of a block</strong>, <em>after</em> the last trade
of a block. This removes the possibility of in-block price manipulations.</p>
<p>Technically, prices in the Uniswap oracle are updated at the beginning of each block, and each price is calculated before
the first swap in a block.</p>
<h2 id="price-oracle-implementation">
  Price Oracle Implementation
  <a class="anchor" href="#price-oracle-implementation">#</a>
</h2>
<p>Alright, let&rsquo;s get to code.</p>
<h3 id="observations-and-cardinality">
  Observations and Cardinality
  <a class="anchor" href="#observations-and-cardinality">#</a>
</h3>
<p>We&rsquo;ll begin by creating the <code>Oracle</code> library contract and the <code>Observation</code> structure:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#75715e">// src/lib/Oracle.sol
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">library</span> Oracle {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Observation</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">uint32</span> timestamp;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int56</span> tickCumulative;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">bool</span> initialized;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><em>An observation</em> is a slot that stores a recorded price. It stores a price, the timestamp when this price was recorded,
and the <code>initialized</code> flag that is set to <code>true</code> when the observation is activated (not all observations are activated by
default). A pool contract can store up to 65,535 observations:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#75715e">// src/UniswapV3Pool.sol
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">contract</span> <span style="color:#a6e22e">UniswapV3Pool</span> <span style="color:#66d9ef">is</span> IUniswapV3Pool {
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">using</span> Oracle <span style="color:#66d9ef">for</span> Oracle.Observation[<span style="color:#ae81ff">65535</span>];
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    Oracle.Observation[<span style="color:#ae81ff">65535</span>] <span style="color:#66d9ef">public</span> observations;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>However, since storing that many instances of <code>Observation</code> requires a lot of gas (someone would have to pay for writing
each of them to contract&rsquo;s storage), a pool by default can store only 1 observation, which gets overwritten each time
a new price is recorded. The number of activated observations, the <em>cardinality</em> of observations, can be increased at
any time by anyone who&rsquo;s willing to pay for that. To manage cardinality, we need a few extra state variables:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Slot0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Current sqrt(P)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">uint160</span> sqrtPriceX96;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Current tick
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int24</span> tick;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Most recent observation index
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">uint16</span> observationIndex;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Maximum number of observations
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">uint16</span> observationCardinality;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Next maximum number of observations
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">uint16</span> observationCardinalityNext;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    ...
</span></span></code></pre></div><ul>
<li><code>observationIndex</code> tracks the index of the most recent observation;</li>
<li><code>observationCardinality</code> tracks the number of activated observations;</li>
<li><code>observationCardinalityNext</code> track the next cardinality the array of observations can expand to.</li>
</ul>
<p>Observations are stored in a fixed-length array that expands when a new observation is saved and <code>observationCardinalityNext</code>
is greater than <code>observationCardinality</code> (which signals that cardinality can be expanded). If the array cannot be expanded
(next cardinality value equals to the current one), oldest observations get overwritten, i.e. observation is stored at
index 0, next one is stored at index 1, and so on.</p>
<p>When pool is created, <code>observationCardinality</code> and <code>observationCardinalityNext</code> are set to 1:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#75715e">// src/UniswapV3Pool.sol
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">contract</span> <span style="color:#a6e22e">UniswapV3Pool</span> <span style="color:#66d9ef">is</span> IUniswapV3Pool {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">initialize</span>(<span style="color:#66d9ef">uint160</span> sqrtPriceX96) <span style="color:#66d9ef">public</span> {
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        (<span style="color:#66d9ef">uint16</span> cardinality, <span style="color:#66d9ef">uint16</span> cardinalityNext) <span style="color:#f92672">=</span> observations.initialize(
</span></span><span style="display:flex;"><span>            _blockTimestamp()
</span></span><span style="display:flex;"><span>        );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        slot0 <span style="color:#f92672">=</span> Slot0({
</span></span><span style="display:flex;"><span>            sqrtPriceX96<span style="color:#f92672">:</span> sqrtPriceX96,
</span></span><span style="display:flex;"><span>            tick<span style="color:#f92672">:</span> tick,
</span></span><span style="display:flex;"><span>            observationIndex<span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>            observationCardinality<span style="color:#f92672">:</span> cardinality,
</span></span><span style="display:flex;"><span>            observationCardinalityNext<span style="color:#f92672">:</span> cardinalityNext
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#75715e">// src/lib/Oracle.sol
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">library</span> Oracle {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">initialize</span>(Observation[<span style="color:#ae81ff">65535</span>] <span style="color:#66d9ef">storage</span> self, <span style="color:#66d9ef">uint32</span> time)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">internal</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">returns</span> (<span style="color:#66d9ef">uint16</span> cardinality, <span style="color:#66d9ef">uint16</span> cardinalityNext)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        self[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> Observation({
</span></span><span style="display:flex;"><span>            timestamp<span style="color:#f92672">:</span> time,
</span></span><span style="display:flex;"><span>            tickCumulative<span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>            initialized<span style="color:#f92672">:</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        cardinality <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        cardinalityNext <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="writing-observations">
  Writing Observations
  <a class="anchor" href="#writing-observations">#</a>
</h3>
<p>In <code>swap</code> function, when current price is changed, an observation is written to the observations array:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#75715e">// src/UniswapV3Pool.sol
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">contract</span> <span style="color:#a6e22e">UniswapV3Pool</span> <span style="color:#66d9ef">is</span> IUniswapV3Pool {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">swap</span>(...) <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">returns</span> (...) {
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (state.tick <span style="color:#f92672">!=</span> slot0_.tick) {
</span></span><span style="display:flex;"><span>            (
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">uint16</span> observationIndex,
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">uint16</span> observationCardinality
</span></span><span style="display:flex;"><span>            ) <span style="color:#f92672">=</span> observations.write(
</span></span><span style="display:flex;"><span>                    slot0_.observationIndex,
</span></span><span style="display:flex;"><span>                    _blockTimestamp(),
</span></span><span style="display:flex;"><span>                    slot0_.tick,
</span></span><span style="display:flex;"><span>                    slot0_.observationCardinality,
</span></span><span style="display:flex;"><span>                    slot0_.observationCardinalityNext
</span></span><span style="display:flex;"><span>                );
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            (
</span></span><span style="display:flex;"><span>                slot0.sqrtPriceX96,
</span></span><span style="display:flex;"><span>                slot0.tick,
</span></span><span style="display:flex;"><span>                slot0.observationIndex,
</span></span><span style="display:flex;"><span>                slot0.observationCardinality
</span></span><span style="display:flex;"><span>            ) <span style="color:#f92672">=</span> (
</span></span><span style="display:flex;"><span>                state.sqrtPriceX96,
</span></span><span style="display:flex;"><span>                state.tick,
</span></span><span style="display:flex;"><span>                observationIndex,
</span></span><span style="display:flex;"><span>                observationCardinality
</span></span><span style="display:flex;"><span>            );
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Notice that the tick that&rsquo;s observed here is <code>slot0_.tick</code> (not <code>state.stick</code>), i.e. the price before the swap! It&rsquo;s
updated with a new price in the next statement. This is the price manipulation mitigation we discussed earlier: Uniswap
tracks prices <strong>before</strong> the first trade in the block and <strong>after</strong> the last trade in the previous block.</p>
<p>Also notice that each observation is identified by <code>_blockTimestamp()</code>, i.e. the current block timestamp. This means that
if there&rsquo;s already an observation for the current block, a price is not recorded. If there are no observations for the
current block (i.e. this is the first swap in the block), a price is recorded. This is part of the price manipulation
mitigation mechanism.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#75715e">// src/lib/Oracle.sol
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">write</span>(
</span></span><span style="display:flex;"><span>    Observation[<span style="color:#ae81ff">65535</span>] <span style="color:#66d9ef">storage</span> self,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint16</span> index,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32</span> timestamp,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int24</span> tick,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint16</span> cardinality,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint16</span> cardinalityNext
</span></span><span style="display:flex;"><span>) <span style="color:#66d9ef">internal</span> <span style="color:#66d9ef">returns</span> (<span style="color:#66d9ef">uint16</span> indexUpdated, <span style="color:#66d9ef">uint16</span> cardinalityUpdated) {
</span></span><span style="display:flex;"><span>    Observation <span style="color:#66d9ef">memory</span> last <span style="color:#f92672">=</span> self[index];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (last.timestamp <span style="color:#f92672">==</span> timestamp) <span style="color:#66d9ef">return</span> (index, cardinality);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (cardinalityNext <span style="color:#f92672">&gt;</span> cardinality <span style="color:#f92672">&amp;&amp;</span> index <span style="color:#f92672">==</span> (cardinality <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)) {
</span></span><span style="display:flex;"><span>        cardinalityUpdated <span style="color:#f92672">=</span> cardinalityNext;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        cardinalityUpdated <span style="color:#f92672">=</span> cardinality;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    indexUpdated <span style="color:#f92672">=</span> (index <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> cardinalityUpdated;
</span></span><span style="display:flex;"><span>    self[indexUpdated] <span style="color:#f92672">=</span> transform(last, timestamp, tick);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Here we see that an observation is skipped when there&rsquo;s already an observation made at the current block. If there&rsquo;s no
such observation though, we&rsquo;re saving a new one and trying to expand the cardinality when possible. The modulo operator
(<code>%</code>) ensures that observation index stays within the range $[0, cardinality)$ and resets to 0 when the upper bound is
reached.</p>
<p>Now, let&rsquo;s look at the <code>transform</code> function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">transform</span>(
</span></span><span style="display:flex;"><span>    Observation <span style="color:#66d9ef">memory</span> last,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32</span> timestamp,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int24</span> tick
</span></span><span style="display:flex;"><span>) <span style="color:#66d9ef">internal</span> <span style="color:#66d9ef">pure</span> <span style="color:#66d9ef">returns</span> (Observation <span style="color:#66d9ef">memory</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint56</span> delta <span style="color:#f92672">=</span> timestamp <span style="color:#f92672">-</span> last.timestamp;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        Observation({
</span></span><span style="display:flex;"><span>            timestamp<span style="color:#f92672">:</span> timestamp,
</span></span><span style="display:flex;"><span>            tickCumulative<span style="color:#f92672">:</span> last.tickCumulative <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int56</span>(tick) <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int56</span>(delta),
</span></span><span style="display:flex;"><span>            initialized<span style="color:#f92672">:</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>What we&rsquo;re calculating here is the accumulated price: current tick gets multiplied by the number of the seconds since
the last observation and gets added to the last accumulated price.</p>
<h3 id="increase-of-cardinality">
  Increase of Cardinality
  <a class="anchor" href="#increase-of-cardinality">#</a>
</h3>
<p>Let&rsquo;s now see how cardinality is expanded.</p>
<p>Anyone at any time can increase the cardinality of observations of a pool and pay for the gas required to do so. For this,
we&rsquo;ll add a new public function to Pool contract:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#75715e">// src/UniswapV3Pool.sol
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">increaseObservationCardinalityNext</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint16</span> observationCardinalityNext
</span></span><span style="display:flex;"><span>) <span style="color:#66d9ef">public</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint16</span> observationCardinalityNextOld <span style="color:#f92672">=</span> slot0.observationCardinalityNext;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint16</span> observationCardinalityNextNew <span style="color:#f92672">=</span> observations.grow(
</span></span><span style="display:flex;"><span>        observationCardinalityNextOld,
</span></span><span style="display:flex;"><span>        observationCardinalityNext
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (observationCardinalityNextNew <span style="color:#f92672">!=</span> observationCardinalityNextOld) {
</span></span><span style="display:flex;"><span>        slot0.observationCardinalityNext <span style="color:#f92672">=</span> observationCardinalityNextNew;
</span></span><span style="display:flex;"><span>        emit IncreaseObservationCardinalityNext(
</span></span><span style="display:flex;"><span>            observationCardinalityNextOld,
</span></span><span style="display:flex;"><span>            observationCardinalityNextNew
</span></span><span style="display:flex;"><span>        );
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>And a new function to Oracle:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#75715e">// src/lib/Oracle.sol
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">grow</span>(
</span></span><span style="display:flex;"><span>    Observation[<span style="color:#ae81ff">65535</span>] <span style="color:#66d9ef">storage</span> self,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint16</span> current,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint16</span> next
</span></span><span style="display:flex;"><span>) <span style="color:#66d9ef">internal</span> <span style="color:#66d9ef">returns</span> (<span style="color:#66d9ef">uint16</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (next <span style="color:#f92672">&lt;=</span> current) <span style="color:#66d9ef">return</span> current;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">uint16</span> i <span style="color:#f92672">=</span> current; i <span style="color:#f92672">&lt;</span> next; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        self[i].timestamp <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> next;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In the <code>grow</code> function, we&rsquo;re allocating new observations by setting the <code>timestamp</code> field of each of them to some non-
zero value. Notice that <code>self</code> is a storage variable, assigning values to its elements will update the array counter and
write the values to contract&rsquo;s storage.</p>
<h3 id="reading-observations">
  Reading Observations
  <a class="anchor" href="#reading-observations">#</a>
</h3>
<p>We&rsquo;ve finally come to the trickiest part of this chapter: reading of observations. Before moving on, let&rsquo;s review how
observations are stored to get a better picture.</p>
<p>Observations are stored in a fixed-length array that can be expanded:</p>
<p><img src="https://uniswapv3book.com/images/milestone_5/observations.png" alt="Observations array" /></p>
<p>As we noted above, observations are expected to overflow: if a new observation doesn&rsquo;t fit into the array, writing
continues starting at index 0, i.e. oldest observations get overwritten:</p>
<p><img src="https://uniswapv3book.com/images/milestone_5/observations_wrapping.png" alt="Observations wrapping" /></p>
<p>There&rsquo;s no guarantee that an observation will be stored for every block because swaps don&rsquo;t happen in every block. Thus,
there will be blocks we don&rsquo;t know prices at, and such periods of missing observations can be long. Of course, we don&rsquo;t
want to have gaps in the prices reported by the oracle, and this is why we&rsquo;re using time-weighted average prices (TWAP)–so we
could have averaged prices in the periods where there were no observations. TWAP allows us to <em>interpolate</em> prices, i.e.
to draw a line between two observations–each point on the line will be a price at a specific timestamp between the two
observations.</p>
<p><img src="https://uniswapv3book.com/images/milestone_5/interpolated_prices.png" alt="Interpolated prices" /></p>
<p>So, reading observations means finding observations by timestamps and interpolating missing observations, taking into
consideration that the observations array is allowed to overflow (e.g. the oldest observation can come after the most
recent one in the array). Since we&rsquo;re not indexing the observations by timestamps (to save gas), we&rsquo;ll need to use the
<a href="https://en.wikipedia.org/wiki/Binary_search_algorithm">binary search algorithm</a> to efficient search. But not always.</p>
<p>Let&rsquo;s break it down into smaller steps and begin by implementing <code>observe</code> function in <code>Oracle</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">observe</span>(
</span></span><span style="display:flex;"><span>    Observation[<span style="color:#ae81ff">65535</span>] <span style="color:#66d9ef">storage</span> self,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32</span> time,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32</span>[] <span style="color:#66d9ef">memory</span> secondsAgos,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int24</span> tick,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint16</span> index,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint16</span> cardinality
</span></span><span style="display:flex;"><span>) <span style="color:#66d9ef">internal</span> <span style="color:#66d9ef">view</span> <span style="color:#66d9ef">returns</span> (<span style="color:#66d9ef">int56</span>[] <span style="color:#66d9ef">memory</span> tickCumulatives) {
</span></span><span style="display:flex;"><span>    tickCumulatives <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int56</span>[](secondsAgos.length);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">uint256</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> secondsAgos.length; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        tickCumulatives[i] <span style="color:#f92672">=</span> observeSingle(
</span></span><span style="display:flex;"><span>            self,
</span></span><span style="display:flex;"><span>            time,
</span></span><span style="display:flex;"><span>            secondsAgos[i],
</span></span><span style="display:flex;"><span>            tick,
</span></span><span style="display:flex;"><span>            index,
</span></span><span style="display:flex;"><span>            cardinality
</span></span><span style="display:flex;"><span>        );
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The function takes current block timestamp, the list of time points we want to get prices at (<code>secondsAgo</code>), current
tick, observations index, and cardinality.</p>
<p>Moving to the <code>observeSingle</code> function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">observeSingle</span>(
</span></span><span style="display:flex;"><span>    Observation[<span style="color:#ae81ff">65535</span>] <span style="color:#66d9ef">storage</span> self,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32</span> time,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32</span> secondsAgo,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int24</span> tick,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint16</span> index,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint16</span> cardinality
</span></span><span style="display:flex;"><span>) <span style="color:#66d9ef">internal</span> <span style="color:#66d9ef">view</span> <span style="color:#66d9ef">returns</span> (<span style="color:#66d9ef">int56</span> tickCumulative) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (secondsAgo <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        Observation <span style="color:#66d9ef">memory</span> last <span style="color:#f92672">=</span> self[index];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (last.timestamp <span style="color:#f92672">!=</span> time) last <span style="color:#f92672">=</span> transform(last, time, tick);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> last.tickCumulative;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>When most recent observation is requested (0 seconds passed), we can return it right away. If it wasn&rsquo;t record in the
current block, transform it to consider the current block and the current tick.</p>
<p>If an older time point is requested, we need to make several checks before switching to the binary search algorithm:</p>
<ol>
<li>if the requested time point is the last observation, we can return the accumulated price at the latest observation;</li>
<li>if the requested time point is after the last observation, we can call <code>transform</code>  to find the accumulated price at
this point, knowing the last observed price and the current price;</li>
<li>if the requested time point is before the last observation, we have to use the binary search.</li>
</ol>
<p>Let&rsquo;s go straight to the third point:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">binarySearch</span>(
</span></span><span style="display:flex;"><span>    Observation[<span style="color:#ae81ff">65535</span>] <span style="color:#66d9ef">storage</span> self,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32</span> time,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32</span> target,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint16</span> index,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint16</span> cardinality
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">view</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">returns</span> (Observation <span style="color:#66d9ef">memory</span> beforeOrAt, Observation <span style="color:#66d9ef">memory</span> atOrAfter)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    ...
</span></span></code></pre></div><p>The function takes the current block timestamp (<code>time</code>), the timestamp of the price point requested (<code>target</code>), as well
as the current observations index and cardinality. It returns the range between two observations in which the requested time
point is located.</p>
<p>To initialize the binary search algorithm, we set the boundaries:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#66d9ef">uint256</span> l <span style="color:#f92672">=</span> (index <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> cardinality; <span style="color:#75715e">// oldest observation
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">uint256</span> r <span style="color:#f92672">=</span> l <span style="color:#f92672">+</span> cardinality <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// newest observation
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">uint256</span> i;
</span></span></code></pre></div><p>Recall that the observations array is expected to overflow, that&rsquo;s why we&rsquo;re using the modulo operator here.</p>
<p>Then we spin up an infinite loop, in which we check the middle point of the range: if it&rsquo;s not initialized (there&rsquo;s no
observation), we&rsquo;re continuing with the next point:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">true</span>) {
</span></span><span style="display:flex;"><span>    i <span style="color:#f92672">=</span> (l <span style="color:#f92672">+</span> r) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    beforeOrAt <span style="color:#f92672">=</span> self[i <span style="color:#f92672">%</span> cardinality];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>beforeOrAt.initialized) {
</span></span><span style="display:flex;"><span>        l <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ...
</span></span></code></pre></div><p>If the point is initialized, we call it the left boundary of the range we want the requested time point to be included
in. And we&rsquo;re trying to find the right boundary (<code>atOrAfter</code>):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    atOrAfter <span style="color:#f92672">=</span> self[(i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> cardinality];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> targetAtOrAfter <span style="color:#f92672">=</span> lte(time, beforeOrAt.timestamp, target);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (targetAtOrAfter <span style="color:#f92672">&amp;&amp;</span> lte(time, target, atOrAfter.timestamp))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    ...
</span></span></code></pre></div><p>If we&rsquo;ve found the boundaries, we return them. If not, we continue our search:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>targetAtOrAfter) r <span style="color:#f92672">=</span> i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> l <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>After finding a range of observations the requested time point belongs to, we need to calculate the price at the
requested time point:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#75715e">// function observeSingle() {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint56</span> observationTimeDelta <span style="color:#f92672">=</span> atOrAfter.timestamp <span style="color:#f92672">-</span>
</span></span><span style="display:flex;"><span>        beforeOrAt.timestamp;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint56</span> targetDelta <span style="color:#f92672">=</span> target <span style="color:#f92672">-</span> beforeOrAt.timestamp;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        beforeOrAt.tickCumulative <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>        ((atOrAfter.tickCumulative <span style="color:#f92672">-</span> beforeOrAt.tickCumulative) <span style="color:#f92672">/</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int56</span>(observationTimeDelta)) <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int56</span>(targetDelta);
</span></span><span style="display:flex;"><span>    ...
</span></span></code></pre></div><p>This is as simple as finding the average rate of change within the range and multiplying it by the number of seconds
that has passed between the lower bound of the range and the time point we need. This is the interpolation we discussed
earlier.</p>
<p>The last thing we need to implement here is a public function in Pool contract that reads and returns observations:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#75715e">// src/UniswapV3Pool.sol
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">observe</span>(<span style="color:#66d9ef">uint32</span>[] calldata secondsAgos)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">view</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">returns</span> (<span style="color:#66d9ef">int56</span>[] <span style="color:#66d9ef">memory</span> tickCumulatives)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        observations.observe(
</span></span><span style="display:flex;"><span>            _blockTimestamp(),
</span></span><span style="display:flex;"><span>            secondsAgos,
</span></span><span style="display:flex;"><span>            slot0.tick,
</span></span><span style="display:flex;"><span>            slot0.observationIndex,
</span></span><span style="display:flex;"><span>            slot0.observationCardinality
</span></span><span style="display:flex;"><span>        );
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="interpreting-observations">
  Interpreting Observations
  <a class="anchor" href="#interpreting-observations">#</a>
</h3>
<p>Let&rsquo;s now see how to interpret observations.</p>
<p>The <code>observe</code> function we just added returns an array of accumulated prices, and we want to know how to convert them
to actual prices. I&rsquo;ll demonstrate this in a test of the <code>observe</code> function.</p>
<p>In the test, I run multiple swaps in different directions and at different blocks:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">testObserve</span>() <span style="color:#66d9ef">public</span> {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    pool.increaseObservationCardinalityNext(<span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    vm.warp(<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    pool.swap(<span style="color:#66d9ef">address</span>(this), <span style="color:#66d9ef">false</span>, swapAmount, sqrtP(<span style="color:#ae81ff">6000</span>), extra);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    vm.warp(<span style="color:#ae81ff">7</span>);
</span></span><span style="display:flex;"><span>    pool.swap(<span style="color:#66d9ef">address</span>(this), <span style="color:#66d9ef">true</span>, swapAmount2, sqrtP(<span style="color:#ae81ff">4000</span>), extra);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    vm.warp(<span style="color:#ae81ff">20</span>);
</span></span><span style="display:flex;"><span>    pool.swap(<span style="color:#66d9ef">address</span>(this), <span style="color:#66d9ef">false</span>, swapAmount, sqrtP(<span style="color:#ae81ff">6000</span>), extra);
</span></span><span style="display:flex;"><span>    ...
</span></span></code></pre></div><blockquote>
<p><code>vm.warp</code> is a cheat-code provided by Foundry: it forwards to a block with the specified timestamp. 2, 7, 20 – these
are block timestamps.</p>
</blockquote>
<p>The first swap is made at the block with timestamp 2, the second one is made at timestamp 7, and the third one is made at
timestamp 20. We can then read the observations:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    secondsAgos <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">uint32</span>[](<span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>    secondsAgos[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    secondsAgos[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">13</span>;
</span></span><span style="display:flex;"><span>    secondsAgos[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">17</span>;
</span></span><span style="display:flex;"><span>    secondsAgos[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">18</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int56</span>[] <span style="color:#66d9ef">memory</span> tickCumulatives <span style="color:#f92672">=</span> pool.observe(secondsAgos);
</span></span><span style="display:flex;"><span>    assertEq(tickCumulatives[<span style="color:#ae81ff">0</span>], <span style="color:#ae81ff">1607059</span>);
</span></span><span style="display:flex;"><span>    assertEq(tickCumulatives[<span style="color:#ae81ff">1</span>], <span style="color:#ae81ff">511146</span>);
</span></span><span style="display:flex;"><span>    assertEq(tickCumulatives[<span style="color:#ae81ff">2</span>], <span style="color:#ae81ff">170370</span>);
</span></span><span style="display:flex;"><span>    assertEq(tickCumulatives[<span style="color:#ae81ff">3</span>], <span style="color:#ae81ff">85176</span>);
</span></span><span style="display:flex;"><span>    ...
</span></span></code></pre></div><ol>
<li>The earliest observed price is 0, which is the initial observation that&rsquo;s set when the pool is deployed. However,
since the cardinality was set to 3 and we made 3 swaps, it was overwritten by the last observation.</li>
<li>During the first swap, tick 85176 was observed, which is the initial price of the pool–recall that the price before
a swap is observed. Because the very first observation was overwritten, this is the oldest observation now.</li>
<li>Next returned accumulated price is 170370, which is <code>85176 + 85194</code>. The former is the previous accumulator value,
the latter is the price after the first swap that was observed during the second swap.</li>
<li>Next returned accumulated price is 511146, which is <code>(511146 - 170370) / (17 - 13) = 85194</code>, the accumulated price
between the second and the third swap.</li>
<li>Finally, the most recent observation is 1607059, which is <code>(1607059 - 511146) / (20 - 7) = 84301</code>, which is ~4581
USDC/ETH, the price after the second swap that was observed during the third swap.</li>
</ol>
<p>And here&rsquo;s an example that involves interpolation: the time points requested are not the time points of the swaps:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span>secondsAgos <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">uint32</span>[](<span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>secondsAgos[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>secondsAgos[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>secondsAgos[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>secondsAgos[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">15</span>;
</span></span><span style="display:flex;"><span>secondsAgos[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">18</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>tickCumulatives <span style="color:#f92672">=</span> pool.observe(secondsAgos);
</span></span><span style="display:flex;"><span>assertEq(tickCumulatives[<span style="color:#ae81ff">0</span>], <span style="color:#ae81ff">1607059</span>);
</span></span><span style="display:flex;"><span>assertEq(tickCumulatives[<span style="color:#ae81ff">1</span>], <span style="color:#ae81ff">1185554</span>);
</span></span><span style="display:flex;"><span>assertEq(tickCumulatives[<span style="color:#ae81ff">2</span>], <span style="color:#ae81ff">764049</span>);
</span></span><span style="display:flex;"><span>assertEq(tickCumulatives[<span style="color:#ae81ff">3</span>], <span style="color:#ae81ff">340758</span>);
</span></span><span style="display:flex;"><span>assertEq(tickCumulatives[<span style="color:#ae81ff">4</span>], <span style="color:#ae81ff">85176</span>);
</span></span></code></pre></div><p>This results in prices: 4581.03, 4581.03, 4747.6, 5008.91, which are the average prices within the requested intervals.</p>
<blockquote>
<p>Here&rsquo;s how to compute those values in Python:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>vals <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1607059</span>, <span style="color:#ae81ff">1185554</span>, <span style="color:#ae81ff">764049</span>, <span style="color:#ae81ff">340758</span>, <span style="color:#ae81ff">85176</span>]
</span></span><span style="display:flex;"><span>secs <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">18</span>]
</span></span><span style="display:flex;"><span>[<span style="color:#ae81ff">1.0001</span><span style="color:#f92672">**</span>((vals[i] <span style="color:#f92672">-</span> vals[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]) <span style="color:#f92672">/</span> (secs[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> secs[i])) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(vals)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)]
</span></span></code></pre></div></blockquote>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#price-oracle">Price Oracle</a>
      <ul>
        <li><a href="#what-is-price-oracle">What is Price Oracle?</a></li>
        <li><a href="#how-uniswap-price-oracle-works">How Uniswap Price Oracle Works</a></li>
        <li><a href="#price-manipulation-mitigation">Price Manipulation Mitigation</a></li>
        <li><a href="#price-oracle-implementation">Price Oracle Implementation</a>
          <ul>
            <li><a href="#observations-and-cardinality">Observations and Cardinality</a></li>
            <li><a href="#writing-observations">Writing Observations</a></li>
            <li><a href="#increase-of-cardinality">Increase of Cardinality</a></li>
            <li><a href="#reading-observations">Reading Observations</a></li>
            <li><a href="#interpreting-observations">Interpreting Observations</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












