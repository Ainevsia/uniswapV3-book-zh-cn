<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="\[ \] 提供流动性 # 有了这些理论，我们现在可以开始写代码了！
新建一个文件夹，cd进去运行forge init --vscode-来初始化一个Forge项目。加上--vscode会让Forge配置vscode的Solidity插件。 删除其中的合约和测试文件：
script/Contract.s.sol src/Contract.sol test/Contract.t.sol 现在，我们可以开始写我们的第一个合约了~
池子合约 # 正如我们在简介中提到的那样，Uniswap部署了多个池子合约，每一个都是负责一对token的交易。Uniswap的所有合约被分为以下两类：
核心合约(core contracts) 外部合约(periphery contracts) 正如其名，核心合约实现了核心的逻辑。这些合约是最小的，对用户不友好的，底层的合约。这些合约都只做一件事并且保证这件事尽可能地安全。在Uniswap V3中，核心合约包含以下两个：
池子(Pool)合约，实现了去中心化交易的核心逻辑 工厂(Factory)合约，作为池子合约的注册入口，使得部署池子合约更加简单。 我们将会从池子合约开始，这部分实现了Uniswap 99%的核心功能。
创建 src/UniswapV3Pool.sol:
pragma solidity ^0.8.14; contract UniswapV3Pool {} 让我们想一下这个合约需要存储哪些数据：
由于每个合约都是一对token的交易市场，我们需要存储两个token的地址。这些地址是静态的，仅设置一次并且保持不变的。(因此，这些变量需要被设置为immutable) 每个池子合约包含了一系列的流动性位置，我们需要用一个mapping来存储这些信息，key代表不同位置，value是包含这些位置相关的信息。 每个池子合约都包含一些tick的信息，需要一个mapping来存储tick的编号与对应的信息 tick的范围是固定的，这些范围在合约中存为常数 需要存储池子流动性的数量$L$ 最后，我们还需要跟踪现在的价格和对应的tock。我们将会把他们存储在一个slot中来节省gas费：因为这些变量会被频繁读写，所以我们需要充分考虑Solidity变量在存储中的分布特点 总之，合约大概存储了以下这些信息：
// src/lib/Tick.sol library Tick { struct Info { bool initialized; uint128 liquidity; } ... } // src/lib/Position.sol library Position { struct Info { uint128 liquidity; } ... } // src/UniswapV3Pool.">
<meta name="theme-color" content="#FFFFFF">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="提供流动性" />
<meta property="og:description" content="\[ \] 提供流动性 # 有了这些理论，我们现在可以开始写代码了！
新建一个文件夹，cd进去运行forge init --vscode-来初始化一个Forge项目。加上--vscode会让Forge配置vscode的Solidity插件。 删除其中的合约和测试文件：
script/Contract.s.sol src/Contract.sol test/Contract.t.sol 现在，我们可以开始写我们的第一个合约了~
池子合约 # 正如我们在简介中提到的那样，Uniswap部署了多个池子合约，每一个都是负责一对token的交易。Uniswap的所有合约被分为以下两类：
核心合约(core contracts) 外部合约(periphery contracts) 正如其名，核心合约实现了核心的逻辑。这些合约是最小的，对用户不友好的，底层的合约。这些合约都只做一件事并且保证这件事尽可能地安全。在Uniswap V3中，核心合约包含以下两个：
池子(Pool)合约，实现了去中心化交易的核心逻辑 工厂(Factory)合约，作为池子合约的注册入口，使得部署池子合约更加简单。 我们将会从池子合约开始，这部分实现了Uniswap 99%的核心功能。
创建 src/UniswapV3Pool.sol:
pragma solidity ^0.8.14; contract UniswapV3Pool {} 让我们想一下这个合约需要存储哪些数据：
由于每个合约都是一对token的交易市场，我们需要存储两个token的地址。这些地址是静态的，仅设置一次并且保持不变的。(因此，这些变量需要被设置为immutable) 每个池子合约包含了一系列的流动性位置，我们需要用一个mapping来存储这些信息，key代表不同位置，value是包含这些位置相关的信息。 每个池子合约都包含一些tick的信息，需要一个mapping来存储tick的编号与对应的信息 tick的范围是固定的，这些范围在合约中存为常数 需要存储池子流动性的数量$L$ 最后，我们还需要跟踪现在的价格和对应的tock。我们将会把他们存储在一个slot中来节省gas费：因为这些变量会被频繁读写，所以我们需要充分考虑Solidity变量在存储中的分布特点 总之，合约大概存储了以下这些信息：
// src/lib/Tick.sol library Tick { struct Info { bool initialized; uint128 liquidity; } ... } // src/lib/Position.sol library Position { struct Info { uint128 liquidity; } ... } // src/UniswapV3Pool." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://uniswapv3book.com/docs/milestone_1/providing-liquidity/" /><meta property="article:section" content="docs" />



<title>提供流动性 | Uniswap V3 Book 中文版</title>
<link rel="manifest" href="https://uniswapv3book.com/manifest.json">
<link rel="icon" href="https://uniswapv3book.com/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="https://uniswapv3book.com/book.min.82c5dbd23447cee0b4c2aa3ed08ce0961faa40e1fa370eee4f8c9f02e0d46b5f.css" integrity="sha256-gsXb0jRHzuC0wqo&#43;0Izglh&#43;qQOH6Nw7uT4yfAuDUa18=" crossorigin="anonymous">
  <script defer src="https://uniswapv3book.com/flexsearch.min.js"></script>
  <script defer src="https://uniswapv3book.com/en.search.min.7bcb9cc1edbdbe78ffa7aeda28e09d51033768c24a465538e9da7066e43237d4.js" integrity="sha256-e8ucwe29vnj/p67aKOCdUQM3aMJKRlU46dpwZuQyN9Q=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="https://uniswapv3book.com/"><span>Uniswap V3 Book 中文版</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  



  
  <ul>
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Milestone 0. 简介</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/introduction/introduction-to-markets/" class="">交易市场简介</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/introduction/constant-function-market-maker/" class="">恒定函数做市商(CFMM)</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/introduction/uniswap-v3/" class="">Uniswap V3</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/introduction/dev-environment/" class="">开发环境</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Milestone 1. 第一笔交易</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_1/introduction/" class="">简介</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_1/calculating-liquidity/" class="">计算流动性</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_1/providing-liquidity/" class="active">提供流动性</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_1/first-swap/" class="">第一笔交易</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_1/manager-contract/" class="">管理合约</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_1/deployment/" class="">部署合约</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_1/user-interface/" class="">用户界面</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Milestone 2. 第二笔交易</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_2/introduction/" class="">简介</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_2/output-amount-calculation/" class="">输出金额计算</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_2/math-in-solidity/" class="">Solidity中的数学运算</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_2/tick-bitmap-index/" class="">Tick Bitmap Index</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_2/generalize-minting/" class="">通用mint</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_2/generalize-swapping/" class="">通用swap</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_2/quoter-contract/" class="">报价合约</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_2/user-interface/" class="">用户界面</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Milestone 3. 跨tick交易</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_3/introduction/" class="">简介</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_3/different-ranges/" class="">不同价格区间</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_3/cross-tick-swaps/" class="">Cross-Tick Swaps</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_3/slippage-protection/" class="">Slippage Protection</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_3/liquidity-calculation/" class="">Liquidity Calculation</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_3/more-on-fixed-point-numbers/" class="">A Little Bit More on Fixed-point Numbers</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_3/flash-loans/" class="">Flash Loans</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_3/user-interface/" class="">User Interface</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Milestone 4. Multi-pool Swaps</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_4/introduction/" class="">Introduction</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_4/factory-contract/" class="">Factory Contract</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_4/path/" class="">Swap Path</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_4/multi-pool-swaps/" class="">Multi-pool Swaps</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_4/user-interface/" class="">User Interface</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_4/tick-rounding/" class="">Tick Rounding</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Milestone 5. Fees and Price Oracle</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_5/introduction/" class="">Introduction</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_5/swap-fees/" class="">Swap Fees</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_5/flash-loan-fees/" class="">Flash Loan Fees</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_5/protocol-fees/" class="">Protocol Fees</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_5/price-oracle/" class="">Price Oracle</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_5/user-interface/" class="">User Interface</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Milestone 6: NFT positions</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_6/introduction/" class="">Introduction</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_6/erc721-overview/" class="">ERC721 Overview</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_6/nft-manager/" class="">NFT Manager</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/milestone_6/nft-renderer/" class="">NFT Renderer</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>补充资料</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://uniswapv3book.com/docs/reference/dictionary/" class="">中英名词对照</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>















</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="https://uniswapv3book.com/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>提供流动性</strong>

  <label for="toc-control">
    
    <img src="https://uniswapv3book.com/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#提供流动性">提供流动性</a>
      <ul>
        <li><a href="#池子合约">池子合约</a></li>
        <li><a href="#铸造minting">铸造(Minting)</a></li>
        <li><a href="#测试">测试</a>
          <ul>
            <li><a href="#测试token">测试token</a></li>
            <li><a href="#测试-minting">测试 Minting</a></li>
            <li><a href="#失败">失败</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown">
<link rel="stylesheet" href="https://uniswapv3book.com/katex/katex.min.css" />
<script>
  function renderKatex(element) {
    renderMathInElement(document.body, {
      delimiters: [
        { left: '$$', right: '$$', display: true },
        { left: '$', right: '$', display: false },
        { left: '\\(', right: '\\)', display: false },
        { left: '\\[', right: '\\]', display: true }
      ],
      
      throwOnError: false
    });
  }
</script>
<script defer src="https://uniswapv3book.com/katex/katex.min.js"></script>
<script defer src="https://uniswapv3book.com/katex/auto-render.min.js" onload="renderKatex(document.body)"></script><span>
  \[ \]
</span>
<h1 id="提供流动性">
  提供流动性
  <a class="anchor" href="#%e6%8f%90%e4%be%9b%e6%b5%81%e5%8a%a8%e6%80%a7">#</a>
</h1>
<p>有了这些理论，我们现在可以开始写代码了！</p>
<p>新建一个文件夹，cd进去运行<code>forge init --vscode</code>-来初始化一个Forge项目。加上<code>--vscode</code>会让Forge配置vscode的Solidity插件。
删除其中的合约和测试文件：</p>
<ul>
<li><code>script/Contract.s.sol</code></li>
<li><code>src/Contract.sol</code></li>
<li><code>test/Contract.t.sol</code></li>
</ul>
<p>现在，我们可以开始写我们的第一个合约了~</p>
<h2 id="池子合约">
  池子合约
  <a class="anchor" href="#%e6%b1%a0%e5%ad%90%e5%90%88%e7%ba%a6">#</a>
</h2>
<p>正如我们在简介中提到的那样，Uniswap部署了多个池子合约，每一个都是负责一对token的交易。Uniswap的所有合约被分为以下两类：</p>
<ul>
<li>核心合约(core contracts)</li>
<li>外部合约(periphery contracts)</li>
</ul>
<p>正如其名，核心合约实现了核心的逻辑。这些合约是最小的，对用户<strong>不</strong>友好的，底层的合约。这些合约都只做一件事并且保证这件事尽可能地安全。在Uniswap V3中，核心合约包含以下两个：</p>
<ol>
<li>池子(Pool)合约，实现了去中心化交易的核心逻辑</li>
<li>工厂(Factory)合约，作为池子合约的注册入口，使得部署池子合约更加简单。</li>
</ol>
<p>我们将会从池子合约开始，这部分实现了Uniswap 99%的核心功能。</p>
<p>创建 <code>src/UniswapV3Pool.sol</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#66d9ef">pragma solidity</span> <span style="color:#f92672">^</span><span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">8</span>.<span style="color:#ae81ff">14</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">contract</span> <span style="color:#a6e22e">UniswapV3Pool</span> {}
</span></span></code></pre></div><p>让我们想一下这个合约需要存储哪些数据：</p>
<ol>
<li>由于每个合约都是一对token的交易市场，我们需要存储两个token的地址。这些地址是静态的，仅设置一次并且保持不变的。(因此，这些变量需要被设置为immutable)</li>
<li>每个池子合约包含了一系列的流动性位置，我们需要用一个mapping来存储这些信息，key代表不同位置，value是包含这些位置相关的信息。</li>
<li>每个池子合约都包含一些tick的信息，需要一个mapping来存储tick的编号与对应的信息</li>
<li>tick的范围是固定的，这些范围在合约中存为常数</li>
<li>需要存储池子流动性的数量$L$</li>
<li>最后，我们还需要跟踪现在的价格和对应的tock。我们将会把他们存储在一个slot中来节省gas费：因为这些变量会被频繁读写，所以我们需要充分考虑<a href="https://docs.soliditylang.org/en/v0.8.17/internals/layout_in_storage.html">Solidity变量在存储中的分布特点</a></li>
</ol>
<p>总之，合约大概存储了以下这些信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#75715e">// src/lib/Tick.sol
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">library</span> Tick {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Info</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">bool</span> initialized;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">uint128</span> liquidity;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// src/lib/Position.sol
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">library</span> Position {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Info</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">uint128</span> liquidity;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// src/UniswapV3Pool.sol
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">contract</span> <span style="color:#a6e22e">UniswapV3Pool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">using</span> Tick <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">mapping</span>(<span style="color:#66d9ef">int24</span> <span style="color:#f92672">=&gt;</span> Tick.Info);
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">using</span> Position <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">mapping</span>(<span style="color:#66d9ef">bytes32</span> <span style="color:#f92672">=&gt;</span> Position.Info);
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">using</span> Position <span style="color:#66d9ef">for</span> Position.Info;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int24</span> <span style="color:#66d9ef">internal</span> <span style="color:#66d9ef">constant</span> MIN_TICK <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">887272</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int24</span> <span style="color:#66d9ef">internal</span> <span style="color:#66d9ef">constant</span> MAX_TICK <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>MIN_TICK;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Pool tokens, immutable
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">address</span> <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">immutable</span> token0;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">address</span> <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">immutable</span> token1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Packing variables that are read together
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Slot0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Current sqrt(P)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">uint160</span> sqrtPriceX96;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Current tick
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int24</span> tick;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    Slot0 <span style="color:#66d9ef">public</span> slot0;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Amount of liquidity, L.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint128</span> <span style="color:#66d9ef">public</span> liquidity;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Ticks info
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">mapping</span>(<span style="color:#66d9ef">int24</span> <span style="color:#f92672">=&gt;</span> Tick.Info) <span style="color:#66d9ef">public</span> ticks;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Positions info
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">mapping</span>(<span style="color:#66d9ef">bytes32</span> <span style="color:#f92672">=&gt;</span> Position.Info) <span style="color:#66d9ef">public</span> positions;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ...
</span></span></code></pre></div><p>Uniswap V3有很多辅助的合约，<code>Tick</code>和<code>Position</code>就是其中两个。<code>using A for B</code>是Solidity的一个语言特性，能够让你用库合约<code>A</code>中的函数来扩展类型<code>B</code>，简化了对于复杂数据结构的管理方式。</p>
<blockquote>
<p>简洁起见，我会省略掉关于Solidity的语法和特性的一些细节上的解释。Solidity有非常清楚的<a href="https://docs.soliditylang.org/en/latest/">文档</a>，当遇到相关问题是可以参考这里。</p>
</blockquote>
<p>接下来，我们在constructor中初始化其中一些变量：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">address</span> token0_,
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">address</span> token1_,
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">uint160</span> sqrtPriceX96,
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int24</span> tick
</span></span><span style="display:flex;"><span>    ) {
</span></span><span style="display:flex;"><span>        token0 <span style="color:#f92672">=</span> token0_;
</span></span><span style="display:flex;"><span>        token1 <span style="color:#f92672">=</span> token1_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        slot0 <span style="color:#f92672">=</span> Slot0({sqrtPriceX96<span style="color:#f92672">:</span> sqrtPriceX96, tick<span style="color:#f92672">:</span> tick});
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在构造函数中，我们初始化了不可变的token地址、现在的价格和对应的tick。我们暂时还不需要提供流动性。</p>
<p>从这里开始，到本节的最后我们会使用我们预先计算好的数值，完成我们的第一笔交易</p>
<h2 id="铸造minting">
  铸造(Minting)
  <a class="anchor" href="#%e9%93%b8%e9%80%a0minting">#</a>
</h2>
<p>在Uniswap V2中，提供流动性被称作<em>minting(铸造)</em>，因为Uniswap V2的池子给予LP-token作为提供流动性的交换。V3没有这种行为，但是仍然保留了同样的名字，我们在这里也同样使用这个名字：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">mint</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">address</span> owner,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int24</span> lowerTick,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int24</span> upperTick,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint128</span> amount
</span></span><span style="display:flex;"><span>) <span style="color:#66d9ef">external</span> <span style="color:#66d9ef">returns</span> (<span style="color:#66d9ef">uint256</span> amount0, <span style="color:#66d9ef">uint256</span> amount1) {
</span></span><span style="display:flex;"><span>    ...
</span></span></code></pre></div><p>我们的<code>mint</code>函数会包含以下参数：</p>
<ol>
<li>所有者的地址，来识别是谁提供的流动性</li>
<li>上界和下界的tick，来设置价格区间的边界</li>
<li>希望提供的流动性的数量</li>
</ol>
<blockquote>
<p>注意到在这里，用户指定了$L$，而不是具体的token数量。这显然不是特别方便，但是要记得池子合约是核心合约的一部分——它并不需要用户友好，因为它仅实现了最小的核心逻辑。在后面章节中，我们会实现一些辅助合约，来帮助用户在调用<code>Pool.mint</code>之前将token数目转换成$L$。</p>
</blockquote>
<p>我们简单描述一下铸造函数如何工作：</p>
<ol>
<li>用户指定价格区间和流动性的数量</li>
<li>合约更新<code>ticks</code>和<code>positions</code>的mapping。</li>
<li>合约计算出用户需要提供的token数量（在本节我们用事先计算好的值）</li>
<li>合约从用户处获得token，并且验证数量是否正确</li>
</ol>
<p>首先来检查ticks：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (
</span></span><span style="display:flex;"><span>    lowerTick <span style="color:#f92672">&gt;=</span> upperTick <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>    lowerTick <span style="color:#f92672">&lt;</span> MIN_TICK <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>    upperTick <span style="color:#f92672">&gt;</span> MAX_TICK
</span></span><span style="display:flex;"><span>) revert InvalidTickRange();
</span></span></code></pre></div><p>并且确保流动性的数量不为零：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (amount <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) revert ZeroLiquidity();
</span></span></code></pre></div><p>接下来，增加tick和position的信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span>ticks.update(lowerTick, amount);
</span></span><span style="display:flex;"><span>ticks.update(upperTick, amount);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Position.Info <span style="color:#66d9ef">storage</span> position <span style="color:#f92672">=</span> positions.get(
</span></span><span style="display:flex;"><span>    owner,
</span></span><span style="display:flex;"><span>    lowerTick,
</span></span><span style="display:flex;"><span>    upperTick
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>position.update(amount);
</span></span></code></pre></div><p><code>ticks.update</code>函数如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#75715e">// src/lib/Tick.sol
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">update</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">mapping</span>(<span style="color:#66d9ef">int24</span> <span style="color:#f92672">=&gt;</span> Tick.Info) <span style="color:#66d9ef">storage</span> self,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int24</span> tick,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint128</span> liquidityDelta
</span></span><span style="display:flex;"><span>) <span style="color:#66d9ef">internal</span> {
</span></span><span style="display:flex;"><span>    Tick.Info <span style="color:#66d9ef">storage</span> tickInfo <span style="color:#f92672">=</span> self[tick];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint128</span> liquidityBefore <span style="color:#f92672">=</span> tickInfo.liquidity;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint128</span> liquidityAfter <span style="color:#f92672">=</span> liquidityBefore <span style="color:#f92672">+</span> liquidityDelta;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (liquidityBefore <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        tickInfo.initialized <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    tickInfo.liquidity <span style="color:#f92672">=</span> liquidityAfter;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>它初始化一个流动性为0的tick，并且在上面添加新的流动性。正如上面所示，我们会在下界tick和上界tick均调用此函数，流动性在两边都有添加。</p>
<p><code>position.update</code>函数如下所示:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#75715e">// src/libs/Position.sol
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">update</span>(Info <span style="color:#66d9ef">storage</span> self, <span style="color:#66d9ef">uint128</span> liquidityDelta) <span style="color:#66d9ef">internal</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint128</span> liquidityBefore <span style="color:#f92672">=</span> self.liquidity;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint128</span> liquidityAfter <span style="color:#f92672">=</span> liquidityBefore <span style="color:#f92672">+</span> liquidityDelta;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    self.liquidity <span style="color:#f92672">=</span> liquidityAfter;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>与tick的函数类似，它也在特定的位置上添加流动性。其中的get函数如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#75715e">// src/libs/Position.sol
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>...
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">get</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">mapping</span>(<span style="color:#66d9ef">bytes32</span> <span style="color:#f92672">=&gt;</span> Info) <span style="color:#66d9ef">storage</span> self,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">address</span> owner,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int24</span> lowerTick,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int24</span> upperTick
</span></span><span style="display:flex;"><span>) <span style="color:#66d9ef">internal</span> <span style="color:#66d9ef">view</span> <span style="color:#66d9ef">returns</span> (Position.Info <span style="color:#66d9ef">storage</span> position) {
</span></span><span style="display:flex;"><span>    position <span style="color:#f92672">=</span> self[
</span></span><span style="display:flex;"><span>        keccak256(abi.encodePacked(owner, lowerTick, upperTick))
</span></span><span style="display:flex;"><span>    ];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>每个位置都由三个变量所确定：LP地址，下界tick编号，上界tick编号。我们将这三个变量哈希来减少数据存储开销：哈希结果只有32字节，而三个变量分别存储需要96字节。</p>
<blockquote>
<p>如果我们使用三个变量来标定，我们就需要三个mapping。每个变量都分别需要32字节的开销，因为solidity会把变量存储在32字节的slot中（此处没有packing）</p>
</blockquote>
<p>让我们继续完成我们的minting函数。接下来我们需要计算用户需要质押token的数量，幸运的是，我们在上一章中已经用公式计算出了对应的数值。在这里我们会在代码中硬编码这些数据：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span>amount0 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">998976618347425280</span> <span style="color:#66d9ef">ether</span>;
</span></span><span style="display:flex;"><span>amount1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">5000</span> <span style="color:#66d9ef">ether</span>;
</span></span></code></pre></div><blockquote>
<p>在后面的章节中，我们会把这里替换成真正的计算</p>
</blockquote>
<p>现在，我们可以从用户处获得token了。这部分是通过callback来实现的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#66d9ef">uint256</span> balance0Before;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">uint256</span> balance1Before;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (amount0 <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) balance0Before <span style="color:#f92672">=</span> balance0();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (amount1 <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) balance1Before <span style="color:#f92672">=</span> balance1();
</span></span><span style="display:flex;"><span>IUniswapV3MintCallback(msg.sender).uniswapV3MintCallback(
</span></span><span style="display:flex;"><span>    amount0,
</span></span><span style="display:flex;"><span>    amount1
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (amount0 <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> balance0Before <span style="color:#f92672">+</span> amount0 <span style="color:#f92672">&gt;</span> balance0())
</span></span><span style="display:flex;"><span>    revert InsufficientInputAmount();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (amount1 <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> balance1Before <span style="color:#f92672">+</span> amount1 <span style="color:#f92672">&gt;</span> balance1())
</span></span><span style="display:flex;"><span>    revert InsufficientInputAmount();
</span></span></code></pre></div><p>首先，我们记录下现在的token余额。接下来我们调用caller的<code>uniswapV3MintCallback</code>方法。预期调用者为合约地址，因为普通用户地址无法实现callback函数。使用callback函数看起来很不用户友好，但是这能够让合约计算token的数量——这非常关键，因为我们无法信任用户。</p>
<p>调用者需要实现<code>uniswapV3MintCallback</code>来将token转给池子合约。调用callback函数后，我们会检查池子合约的对应余额是否发生变化，并且增量应该大于<code>amount0</code>和<code>amount1</code>：这意味着调用者已经把钱转到了池子。</p>
<p>最后，发出一个Mint事件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span>emit Mint(msg.sender, owner, lowerTick, upperTick, amount, amount0, amount1);
</span></span></code></pre></div><p>事件(Event)是合约数据再以太坊中标定的方式，后续可以据此进行搜索。通常来说，比较好的编程习惯是在合约的状态变量发生改变时发出一个事件，这能够让前端知道这件事情发生了。事件也包含了很多有用的信息，比如：调用者的地址，对应的流动性位置，上界和下界的tick，新的流动性数量，两种token的数量。这些信息会作为日志（log）存储，任何人都可以通过收集这样的日志来重放合约中的状态变动，而不需要去遍历分析所有的区块和交易。</p>
<p>现在我们完成了！（出乎意料的简单）。接下来到了测试部分。</p>
<h2 id="测试">
  测试
  <a class="anchor" href="#%e6%b5%8b%e8%af%95">#</a>
</h2>
<p>现在，我们还不知道我们的合约是否正确。在部署我们的合约之前，我们需要写一系列的测试来保证合约功能正常。正如之前所说，Forge是一个绝妙的测试框架，能够让我们的测试十分简单。</p>
<p>创建一个新的测试文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#75715e">// test/UniswapV3Pool.t.sol
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// SPDX-License-Identifier: UNLICENSED
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">pragma solidity</span> <span style="color:#f92672">^</span><span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">8</span>.<span style="color:#ae81ff">14</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;forge-std/Test.sol&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">contract</span> <span style="color:#a6e22e">UniswapV3PoolTest</span> <span style="color:#66d9ef">is</span> Test {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">setUp</span>() <span style="color:#66d9ef">public</span> {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">testExample</span>() <span style="color:#66d9ef">public</span> {
</span></span><span style="display:flex;"><span>        assertTrue(<span style="color:#66d9ef">true</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们来运行一下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ forge test
</span></span><span style="display:flex;"><span>Running <span style="color:#ae81ff">1</span> test <span style="color:#66d9ef">for</span> test/UniswapV3Pool.t.sol:UniswapV3PoolTest
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>PASS<span style="color:#f92672">]</span> testExample<span style="color:#f92672">()</span> <span style="color:#f92672">(</span>gas: 279<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>Test result: ok. <span style="color:#ae81ff">1</span> passed; <span style="color:#ae81ff">0</span> failed; finished in 5.07ms
</span></span></code></pre></div><p>测试通过了！这是显然的，因为目前我们只测试了<code>true</code>等于<code>true</code>。</p>
<p>测试合约都继承自<code>forge-std/Test.sol</code>。这个合约实现了一些列的测试功能，我们后续会对这些功能越来越熟悉。如果你现在就一定想知道，可以打开<code>lib/forge-std/src/Test.sol</code>简单读一下。</p>
<p>测试合约遵循以下规则：</p>
<ol>
<li><code>setUp</code>函数用来准备测试样例。在每个测试样例中，我们都希望有一个配置好的环境，比如合约的部署、token的铸造、池子的初始化——这些都将在<code>setUp</code>中完成</li>
<li>每个测试样例以<code>test</code>开头，例如<code>testMint()</code>。这能够让Forge区分出测试样例和其他的辅助函数（这里我们也可以写任何我们需要的辅助函数）。</li>
</ol>
<p>现在我们来真正测试minting</p>
<h3 id="测试token">
  测试token
  <a class="anchor" href="#%e6%b5%8b%e8%af%95token">#</a>
</h3>
<p>为了测试minting功能，我们需要token。这对我们来说不是个问题，因为我们在测试中能够随意部署任何合约！更进一步，Forge能够用依赖的方式安装其他开源合约。在这里，我们需要包含铸造功能的ERC20合约。我们会使用<a href="https://github.com/Rari-Capital/solmate">Solmate</a>的ERC20合约（Solmate包含了一系列gas优化的合约），并且创建一个继承自Solmate合约的ERC20合约，开放mint接口。</p>
<p>首先安装<code>solmate</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ forge install rari-capital/solmate
</span></span></code></pre></div><p>之后，在<code>test</code>文件夹中创建<code>ERC20Mintable.sol</code>合约（因为此合约仅用于测试）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#75715e">// SPDX-License-Identifier: UNLICENSED
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">pragma solidity</span> <span style="color:#f92672">^</span><span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">8</span>.<span style="color:#ae81ff">14</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;solmate/tokens/ERC20.sol&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">contract</span> <span style="color:#a6e22e">ERC20Mintable</span> <span style="color:#66d9ef">is</span> ERC20 {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constructor</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">string</span> <span style="color:#66d9ef">memory</span> _name,
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">string</span> <span style="color:#66d9ef">memory</span> _symbol,
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">uint8</span> _decimals
</span></span><span style="display:flex;"><span>    ) ERC20(_name, _symbol, _decimals) {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">mint</span>(<span style="color:#66d9ef">address</span> to, <span style="color:#66d9ef">uint256</span> amount) <span style="color:#66d9ef">public</span> {
</span></span><span style="display:flex;"><span>        _mint(to, amount);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们的<code>ERC20Mintable</code>继承了<code>solmate/tokens/ERC20.sol</code>的所有功能，并且额外实现了一个public的<code>mint</code>方法，能够让我们铸造任意数量的token。</p>
<h3 id="测试-minting">
  测试 Minting
  <a class="anchor" href="#%e6%b5%8b%e8%af%95-minting">#</a>
</h3>
<p>现在，我们可以进行minting的测试了。</p>
<p>首先，部署所有需要用到的合约：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#75715e">// test/UniswapV3Pool.t.sol
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>...
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;./ERC20Mintable.sol&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;../src/UniswapV3Pool.sol&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">contract</span> <span style="color:#a6e22e">UniswapV3PoolTest</span> <span style="color:#66d9ef">is</span> Test {
</span></span><span style="display:flex;"><span>    ERC20Mintable token0;
</span></span><span style="display:flex;"><span>    ERC20Mintable token1;
</span></span><span style="display:flex;"><span>    UniswapV3Pool pool;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">setUp</span>() <span style="color:#66d9ef">public</span> {
</span></span><span style="display:flex;"><span>        token0 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ERC20Mintable(<span style="color:#e6db74">&#34;Ether&#34;</span>, <span style="color:#e6db74">&#34;ETH&#34;</span>, <span style="color:#ae81ff">18</span>);
</span></span><span style="display:flex;"><span>        token1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ERC20Mintable(<span style="color:#e6db74">&#34;USDC&#34;</span>, <span style="color:#e6db74">&#34;USDC&#34;</span>, <span style="color:#ae81ff">18</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ...
</span></span></code></pre></div><p>在<code>setUp</code>函数中，我们部署了token合约，但是不需要部署池子合约。这是因为所有的测试样例都会使用同样的token，但是可能会使用不同的池子。</p>
<p>为了让池子的设置更加简单清晰，我们将在另外一个函数中完成这部分工作，<code>setupTestCase</code>。它接受一系列的测试样例参数，进行池子的设置。在我们的第一个测试样例中，我们会测试成功的流动性铸造，其参数如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">testMintSuccess</span>() <span style="color:#66d9ef">public</span> {
</span></span><span style="display:flex;"><span>    TestCaseParams <span style="color:#66d9ef">memory</span> params <span style="color:#f92672">=</span> TestCaseParams({
</span></span><span style="display:flex;"><span>        wethBalance<span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">ether</span>,
</span></span><span style="display:flex;"><span>        usdcBalance<span style="color:#f92672">:</span> <span style="color:#ae81ff">5000</span> <span style="color:#66d9ef">ether</span>,
</span></span><span style="display:flex;"><span>        currentTick<span style="color:#f92672">:</span> <span style="color:#ae81ff">85176</span>,
</span></span><span style="display:flex;"><span>        lowerTick<span style="color:#f92672">:</span> <span style="color:#ae81ff">84222</span>,
</span></span><span style="display:flex;"><span>        upperTick<span style="color:#f92672">:</span> <span style="color:#ae81ff">86129</span>,
</span></span><span style="display:flex;"><span>        liquidity<span style="color:#f92672">:</span> <span style="color:#ae81ff">1517882343751509868544</span>,
</span></span><span style="display:flex;"><span>        currentSqrtP<span style="color:#f92672">:</span> <span style="color:#ae81ff">5602277097478614198912276234240</span>,
</span></span><span style="display:flex;"><span>        shouldTransferInCallback<span style="color:#f92672">:</span> <span style="color:#66d9ef">true</span>,
</span></span><span style="display:flex;"><span>        mintLiqudity<span style="color:#f92672">:</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>    });
</span></span></code></pre></div><ol>
<li>我们计划向池子中质押1ETH和5000USDC</li>
<li>当前的tick为81576，上下界的tick分别为84222和86129（在上一章中计算的结果）</li>
<li>我们将会指定预先计算好的流动性$L$和现价$\sqrt{P}$</li>
<li>在本样例中，我们会铸造流动性（<code>mintLiquidity</code>参数为true），也会在池子合约调用callback时转给它token（<code>shouldTransferInCallback</code>参数为true）。我们并不会在每个测试中都这样做，因此我们有这些参数的设置。</li>
</ol>
<p>接下来，我们用上述参数调用<code>setUpTestCase</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">setupTestCase</span>(TestCaseParams <span style="color:#66d9ef">memory</span> params)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">internal</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">returns</span> (<span style="color:#66d9ef">uint256</span> poolBalance0, <span style="color:#66d9ef">uint256</span> poolBalance1)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    token0.mint(<span style="color:#66d9ef">address</span>(this), params.wethBalance);
</span></span><span style="display:flex;"><span>    token1.mint(<span style="color:#66d9ef">address</span>(this), params.usdcBalance);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    pool <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> UniswapV3Pool(
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">address</span>(token0),
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">address</span>(token1),
</span></span><span style="display:flex;"><span>        params.currentSqrtP,
</span></span><span style="display:flex;"><span>        params.currentTick
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (params.mintLiqudity) {
</span></span><span style="display:flex;"><span>        (poolBalance0, poolBalance1) <span style="color:#f92672">=</span> pool.mint(
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">address</span>(this),
</span></span><span style="display:flex;"><span>            params.lowerTick,
</span></span><span style="display:flex;"><span>            params.upperTick,
</span></span><span style="display:flex;"><span>            params.liquidity
</span></span><span style="display:flex;"><span>        );
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    shouldTransferInCallback <span style="color:#f92672">=</span> params.shouldTransferInCallback;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在这个函数中，我们铸造了token，部署了池子合约。由于<code>mintLiquidity</code>参数设置为true，我们会在池子中铸造初始流动性。最后，我们设置<code>shouldTransferInCallback</code>变量，使得在callback中能读到此参数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">uniswapV3MintCallback</span>(<span style="color:#66d9ef">uint256</span> amount0, <span style="color:#66d9ef">uint256</span> amount1) <span style="color:#66d9ef">public</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (shouldTransferInCallback) {
</span></span><span style="display:flex;"><span>        token0.transfer(msg.sender, amount0);
</span></span><span style="display:flex;"><span>        token1.transfer(msg.sender, amount1);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在这个测试中，是测试合约提供流动性并且调用池子的<code>mint</code>函数，与用户（EOA）无关。测试合约会作为用户，因此它实现了callback函数。测试合约仅仅是个合约而已，你可以用任何你习惯的方式来编写它。</p>
<p>在<code>testMineSuccess</code>中，我们希望池子合约能够：</p>
<ol>
<li>从用户处获取正确数量的token</li>
<li>创建一个关键字和流动性正确的position</li>
<li>初始化我们声明的上下界tick</li>
<li>有正确的$\sqrt{P}$和$L$。</li>
</ol>
<p>我们来实现这些。</p>
<p>铸造在<code>setupTestCase</code>中实现，我们不需要再写一遍了。这个函数也反悔了我们需要的token数量，我们对其进行检查：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span>(<span style="color:#66d9ef">uint256</span> poolBalance0, <span style="color:#66d9ef">uint256</span> poolBalance1) <span style="color:#f92672">=</span> setupTestCase(params);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">uint256</span> expectedAmount0 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">998976618347425280</span> <span style="color:#66d9ef">ether</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">uint256</span> expectedAmount1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">5000</span> <span style="color:#66d9ef">ether</span>;
</span></span><span style="display:flex;"><span>assertEq(
</span></span><span style="display:flex;"><span>    poolBalance0,
</span></span><span style="display:flex;"><span>    expectedAmount0,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;incorrect token0 deposited amount&#34;</span>
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>assertEq(
</span></span><span style="display:flex;"><span>    poolBalance1,
</span></span><span style="display:flex;"><span>    expectedAmount1,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;incorrect token1 deposited amount&#34;</span>
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>我们希望池子里的token数量与我们预先设计好的一致。同样也直接对池子进行检查：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span>assertEq(token0.balanceOf(<span style="color:#66d9ef">address</span>(pool)), expectedAmount0);
</span></span><span style="display:flex;"><span>assertEq(token1.balanceOf(<span style="color:#66d9ef">address</span>(pool)), expectedAmount1);
</span></span></code></pre></div><p>接下来，我们需要检查池子创建的position。回忆一下，在<code>positions</code>这个mapping中，我们的键值是一个哈希。我们手动计算这个键值并且获得合约中对应的position：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#66d9ef">bytes32</span> positionKey <span style="color:#f92672">=</span> keccak256(
</span></span><span style="display:flex;"><span>    abi.encodePacked(<span style="color:#66d9ef">address</span>(this), params.lowerTick, params.upperTick)
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">uint128</span> posLiquidity <span style="color:#f92672">=</span> pool.positions(positionKey);
</span></span><span style="display:flex;"><span>assertEq(posLiquidity, params.liquidity);
</span></span></code></pre></div><blockquote>
<p>由于<code>Position.Info</code>是一个<a href="https://docs.soliditylang.org/en/latest/types.html#structs">struct</a>，它会在返回时被解构，每个field分别赋值给一个单独的变量。</p>
</blockquote>
<p>接下来检查ticks：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span>(<span style="color:#66d9ef">bool</span> tickInitialized, <span style="color:#66d9ef">uint128</span> tickLiquidity) <span style="color:#f92672">=</span> pool.ticks(
</span></span><span style="display:flex;"><span>    params.lowerTick
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>assertTrue(tickInitialized);
</span></span><span style="display:flex;"><span>assertEq(tickLiquidity, params.liquidity);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(tickInitialized, tickLiquidity) <span style="color:#f92672">=</span> pool.ticks(params.upperTick);
</span></span><span style="display:flex;"><span>assertTrue(tickInitialized);
</span></span><span style="display:flex;"><span>assertEq(tickLiquidity, params.liquidity);
</span></span></code></pre></div><p>最后，检查$\sqrt{P}$和$L$:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span>(<span style="color:#66d9ef">uint160</span> sqrtPriceX96, <span style="color:#66d9ef">int24</span> tick) <span style="color:#f92672">=</span> pool.slot0();
</span></span><span style="display:flex;"><span>assertEq(
</span></span><span style="display:flex;"><span>    sqrtPriceX96,
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">5602277097478614198912276234240</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;invalid current sqrtP&#34;</span>
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>assertEq(tick, <span style="color:#ae81ff">85176</span>, <span style="color:#e6db74">&#34;invalid current tick&#34;</span>);
</span></span><span style="display:flex;"><span>assertEq(
</span></span><span style="display:flex;"><span>    pool.liquidity(),
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">1517882343751509868544</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;invalid current liquidity&#34;</span>
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>我们会发现，用Solidity写测试如此简单。</p>
<h3 id="失败">
  失败
  <a class="anchor" href="#%e5%a4%b1%e8%b4%a5">#</a>
</h3>
<p>显然，仅仅测试成功的场景是不够的，我们也需要构造一些失败的测试样例。在提供流动性时可能会有哪些错误点？一些提示如下：</p>
<ol>
<li>上下界tick太大/太小</li>
<li>提供流动性数量为0</li>
<li>LP拥有的token数量不足</li>
</ol>
<p>以上测试用例的编写将留作练习。代码也可以在<a href="https://github.com/Jeiwan/uniswapv3-code/blob/milestone_1/test/UniswapV3Pool.t.sol">这个仓库</a>找到</p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#提供流动性">提供流动性</a>
      <ul>
        <li><a href="#池子合约">池子合约</a></li>
        <li><a href="#铸造minting">铸造(Minting)</a></li>
        <li><a href="#测试">测试</a>
          <ul>
            <li><a href="#测试token">测试token</a></li>
            <li><a href="#测试-minting">测试 Minting</a></li>
            <li><a href="#失败">失败</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












