<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Milestone 1. 第一笔交易 on Uniswap V3 Book 中文版</title>
    <link>https://uniswapv3book.com/docs/milestone_1/</link>
    <description>Recent content in Milestone 1. 第一笔交易 on Uniswap V3 Book 中文版</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language><atom:link href="https://uniswapv3book.com/docs/milestone_1/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>简介</title>
      <link>https://uniswapv3book.com/docs/milestone_1/introduction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_1/introduction/</guid>
      <description>\[ \] 第一笔交易 # 在本章中，我们将会搭建一个流动性池合约，能够接受用户的流动性并且在某个价格区间内做交易。为了尽可能简化，我们仅在一个价格区间内提供流动性，并且仅允许单向的交易。另外，为了更好地理解其中的数学原理，我们将手动计算其中用到的数学参数，暂不使用Solidity的数学库进行计算。
我们本章中要搭建的模型如下：
这是一个ETH/USDC的池子合约。ETH是资产$x$，USDC是资产$y$。 现货价格将被设置为一个ETH对5000USDC 我们提供流动性的价格区间为一个ETH对4545-5500USDC 我们将会从池子中购买ETH，并且保证价格在上述价格区间内。 模型的图像大致如下：
在开始代码部分之前，我们首先来手动计算模型中用到的所有数学参数。为了简单起见，作者将使用Python来进行计算而不是Solidity，因为Solidity在数学计算上有很多细微之处需要考虑。也就是说，我们将会把所有的参数硬编码进池子合约里。这会让我们获得一个最小可用的产品。
本章中所有用到的python计算都在unimath.py。
本章的完整代码可以参考这个github分支</description>
    </item>
    
    <item>
      <title>计算流动性</title>
      <link>https://uniswapv3book.com/docs/milestone_1/calculating-liquidity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_1/calculating-liquidity/</guid>
      <description>\[ \] 计算流动性 # 没有流动性就无法进行交易，因此为了能够完成我们的第一笔交易，我们首先需要向池子中添加一些流动性。为了向池子合约添加流动性，我们需要知道：
一个价格区间，即LP希望他的流动性仅在这个区间上提供和被利用 提供流动性的数量，也即提供的两种代币的数量，我们需要将它们转入池子合约。 在本节中，我们会手动计算上述变量的值；在后续章节中，我们会在合约中对此进行实现。首先我们来考虑价格区间
价格区间计算 # 回忆一下上一章所讲，在Uniswap V3中，整个价格区间被划分成了ticks：每个tick对应一个价格，以及有一个编号。在我们的第一个实现中，我们的现货价格设置为1ETH对5000USDC。购买ETH会移除池子中的一部分ETH，从而使得价格变得高于5000USDC。我们希望在一个包含此价格的区间中提供流动性，并且要确保最终的价格落在这个区间内。（跨区间的交易将会在后续章节提到）。
我们需要找到3个tick：
对应现货价格的tick（1ETH-5000USDC） 提供流动性的价格区间上下界对应的tick。在这里，下界为4545u，上界为5500u。 （译者注：4545u，$4545，4545USDC均代表相同含义，在本书中可能会混合使用）
从之前的章节中我们知道下述公式：
$$\sqrt{P} = \sqrt{\frac{y}{x}}$$
由于我们把ETH作为资产$x$，USDC作为资产$y$，每个tick对应的值为：
$$\sqrt{P_c} = \sqrt{\frac{5000}{1}} = \sqrt{5000} \approx 70.71$$
$$\sqrt{P_l} = \sqrt{\frac{4545}{1}} \approx 67.42$$
$$\sqrt{P_u} = \sqrt{\frac{5500}{1}} \approx 74.16$$
在这里，$P_c$代表现货价格，$P_l$代表区间下界，$P_u$代表区间上界。
接下来，我们可以计算价格对应的ticks。使用下面公式：
$$\sqrt{P(i)}=1.0001^{\frac{i}{2}}$$
我们可以得到关于$i$的公式：
$$i = log_{\sqrt{1.0001}} \sqrt{P(i)}$$
公式中的两个根号实际上是可以消去的，但由于我们会使用$\sqrt{p}$进行计算，我们选择保留根号
这几个对应的tick分别为:
现货tick: $i_c = log_{\sqrt{1.0001}} 70.71 = 85176$ 下界tick: $i_l = log_{\sqrt{1.0001}} 67.42 = 84222$ 上界tick: $i_u = log_{\sqrt{1.0001}} 74.16 = 86129$ 计算过程使用的是Python：</description>
    </item>
    
    <item>
      <title>提供流动性</title>
      <link>https://uniswapv3book.com/docs/milestone_1/providing-liquidity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_1/providing-liquidity/</guid>
      <description>\[ \] 提供流动性 # 有了这些理论，我们现在可以开始写代码了！
新建一个文件夹，cd进去运行forge init --vscode-来初始化一个Forge项目。加上--vscode会让Forge配置vscode的Solidity插件。 删除其中的合约和测试文件：
script/Contract.s.sol src/Contract.sol test/Contract.t.sol 现在，我们可以开始写我们的第一个合约了~
池子合约 # 正如我们在简介中提到的那样，Uniswap部署了多个池子合约，每一个都是负责一对token的交易。Uniswap的所有合约被分为以下两类：
核心合约(core contracts) 外部合约(periphery contracts) 正如其名，核心合约实现了核心的逻辑。这些合约是最小的，对用户不友好的，底层的合约。这些合约都只做一件事并且保证这件事尽可能地安全。在Uniswap V3中，核心合约包含以下两个：
池子(Pool)合约，实现了去中心化交易的核心逻辑 工厂(Factory)合约，作为池子合约的注册入口，使得部署池子合约更加简单。 我们将会从池子合约开始，这部分实现了Uniswap 99%的核心功能。
创建 src/UniswapV3Pool.sol:
pragma solidity ^0.8.14; contract UniswapV3Pool {} 让我们想一下这个合约需要存储哪些数据：
由于每个合约都是一对token的交易市场，我们需要存储两个token的地址。这些地址是静态的，仅设置一次并且保持不变的。(因此，这些变量需要被设置为immutable) 每个池子合约包含了一系列的流动性位置，我们需要用一个mapping来存储这些信息，key代表不同位置，value是包含这些位置相关的信息。 每个池子合约都包含一些tick的信息，需要一个mapping来存储tick的编号与对应的信息 tick的范围是固定的，这些范围在合约中存为常数 需要存储池子流动性的数量$L$ 最后，我们还需要跟踪现在的价格和对应的tock。我们将会把他们存储在一个slot中来节省gas费：因为这些变量会被频繁读写，所以我们需要充分考虑Solidity变量在存储中的分布特点 总之，合约大概存储了以下这些信息：
// src/lib/Tick.sol library Tick { struct Info { bool initialized; uint128 liquidity; } ... } // src/lib/Position.sol library Position { struct Info { uint128 liquidity; } ... } // src/UniswapV3Pool.</description>
    </item>
    
    <item>
      <title>第一笔交易</title>
      <link>https://uniswapv3book.com/docs/milestone_1/first-swap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_1/first-swap/</guid>
      <description>\[ \] 第一笔交易 # 现在我们已经有了流动性，我们可以进行我们的第一笔交易了！
计算交易数量 # 首先，我们需要知道如何计算交易出入的数量。同样，我们在这小节中也会硬编码我们希望交易的USDC数额，这里我们选择42，也即花费42USDC购买ETH
在决定了我们希望投入的资金量之后，我们需要计算我们会获得多少token。在Uniswap V2中，我们会使用现在池子的资产数量来计算，但是在V3中我们有$L$和$\sqrt{P}$，并且我们知道在交易过程中，$L$保持不变而只有$\sqrt{P}$发生变化（当在同一区间内进行交易时，V3的表现和V2一致）。我们还知道如下公式：
$$L = \frac{\Delta y}{\Delta \sqrt{P}}$$
并且，在这里我们知道了$\Delta y$！它正是我们希望投入的42USDC。因此，我们可以根据公式得出投入的 42USDC 会对价格造成多少影响：
$$\Delta \sqrt{P} = \frac{\Delta y}{L}$$
在V3中，我们选择我们希望交易导致的价格变动（回忆一下，交易使得现价沿着曲线移动）。知道了目标价格(target price)，合约可以计算出投入token的数量和输出token的数量。
我们将数字代入上述公式：
$$\Delta \sqrt{P} = \frac{42 \enspace USDC}{1517882343751509868544} = 2192253463713690532467206957$$
把差价加到现在的$\sqrt{P}$，我们就能得到目标价格：
$$\sqrt{P_{target}} = \sqrt{P_{current}} + \Delta \sqrt{P}$$
$$\sqrt{P_{target}} = 5604469350942327889444743441197$$
在Python中进行相应计算:
amount_in = 42 * eth price_diff = (amount_in * q96) // liq price_next = sqrtp_cur + price_diff print(&amp;#34;New price:&amp;#34;, (price_next / q96) ** 2) print(&amp;#34;New sqrtP:&amp;#34;, price_next) print(&amp;#34;New tick:&amp;#34;, price_to_tick((price_next / q96) ** 2)) # New price: 5003.</description>
    </item>
    
    <item>
      <title>管理合约</title>
      <link>https://uniswapv3book.com/docs/milestone_1/manager-contract/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_1/manager-contract/</guid>
      <description>管理合约(Manager Contract) # 在部署我们的池子合约之前，仍然有一个问题需要解决。我们之前提到过，Uniswap V3合约由两部分构成：
核心合约(core contracts)实现了最核心的功能，不提供用户友好的交互接口 外围合约(periphery contracts)为核心合约实现了用户友好的接口 池子合约是核心合约，它并不需要用户友好或者实现灵活功能。它需要调用者进行所有的计算并且提供合适的参数。同时，它也没有使用ERC20的transferFrom函数来从调用者处转账，而是使用了两个callback函数：
uniswapV3MintCallback，当铸造流动性的时候被调用 uniswapV3SwapCallback，当交易token的时候被调用 在我们的测试中，我们在测试合约中实现了这些函数。由于只有合约才能实现callback函数，池子合约并不能直接被普通用户(EOA)调用。这对核心合约是没问题的，但是我们接下来会解决它🙂。
我们下一步的目标是将这个池子合约部署在一个本地的区块链上，并且使用一个前端应用与其交互。因此我们需要创建一个合约，能够让非合约的地址也与池子进行交互。让我们来实现吧！
工作流程 # 下面我们描述了管理合约的功能：
为了铸造流动性，我们需要approve对应的token给管理合约。 我们会调用管理合约的mint函数来铸造流动性，参数为铸造需要的参数以及池子的合约地址 管理合约会调用池子的mint函数，并且会实现uniswapV3MintCallback。由于我们之前的approve，管理合约会从我们的账户中把token转到池子合约 为了交易token，我们也需要approve对应的token 我们会调用管理合约的swap函数，并且与mint过程类似，它会调用池子合约的对应函数。管理者合约会把我们的token转到赤字中，池子进行对应的交易，然后把得到的token发回给我们。 综上，管理合约主要作为用户和池子之间的中介来运行。
向callback传递数据 # 在实现管理合约之前，我们还需要更新我们的池子合约。
管理者合约需要能够与任何一个流动性池适配，并且能够允许任何地址调用它。为了达到这一点，我们需要对callback进行升级：我们需要将池子的地址和用户的地址作为参数传递。下面是我们对于uniswapV3MintCallback的之前的实现（测试合约中的）：
function uniswapV3MintCallback(uint256 amount0, uint256 amount1) public { if (transferInMintCallback) { token0.transfer(msg.sender, amount0); token1.transfer(msg.sender, amount1); } } 关键点：
这个函数转移的token是属于这个测试合约的——而我们希望使用transferFrom来从管理合约的调用者出转出token 这个函数需要知道token0和token1，但这两个变量会随着不同池子而变化。 想法：我们需要改变callback的参数，来将用户和池子的合约地址传进去
接下来看一下swap的callback：
function uniswapV3SwapCallback(int256 amount0, int256 amount1) public { if (amount0 &amp;gt; 0 &amp;amp;&amp;amp; transferInSwapCallback) { token0.transfer(msg.sender, uint256(amount0)); } if (amount1 &amp;gt; 0 &amp;amp;&amp;amp; transferInSwapCallback) { token1.</description>
    </item>
    
    <item>
      <title>部署合约</title>
      <link>https://uniswapv3book.com/docs/milestone_1/deployment/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_1/deployment/</guid>
      <description>\[ \] 部署 # 我们的第一版合约已经完成了。现在，让我们来看看如何把它部署在一个本地以太坊网络上，方便我们之后用前端app交互。
选择本地网络 # 智能合约的开发需要运行一个本地的网络来在开发过程中进行部署和测试。这样的网络需要具有以下特点：
真实的区块链。它必须是一个真实的区块链网络而不是一个模拟器，我们希望我们的合约如果能够在这样的网络上正常工作那也一定能在主网上正常工作 速度。我们希望我们的交易能够快速被执行，这样我们能快速迭代。 以太币。为了支付gas费，我们需要一些eth，因此我们希望这个网络能够允许我们生成任意数量的eth cheat code。除了提供标准的API，我们还希望这个网络能让我们做更多的事，例如：在任何地址上部署合约，以任何地址执行交易，直接修改合约状态等等。 今天，有许多的工具能够提供这样的功能：
Truffle套件中的Ganache Hardhat，一套智能合约开发环境，除了包含本地网络节点以外还有很多有用的工具 Foundry中的Anvil 所有这些解决方案都能够满足我们的需求。尽管如此，项目现在都逐渐从Ganache（最早的解决方案）迁移到Hardhat（目前使用最广的方案），而Foundry也成为开发者的新宠。Foundry也是上述三个方案中唯一使用Solidity来编写测试的框架（其他框架都使用JavaScript）。除此以外，Foundry还允许使用Solidity来编写部署脚本。因此，由于我们想在各处都使用Solidity，我们会使用 Anvil 来运行一个本地区块链，并且使用Solidity编写部署脚本。
运行本地区块链 # Anvil不需要进行配置，我们可以直接在命令行运行：
$ anvil _ _ (_) | | __ _ _ __ __ __ _ | | / _` | | &amp;#39;_ \ \ \ / / | | | | | (_| | | | | | \ V / | | | | \__,_| |_| |_| \_/ |_| |_| 0.</description>
    </item>
    
    <item>
      <title>用户界面</title>
      <link>https://uniswapv3book.com/docs/milestone_1/user-interface/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://uniswapv3book.com/docs/milestone_1/user-interface/</guid>
      <description>\[ \] 用户界面 # 现在，我们可以进行这个milestone的最后一步了——搭建一个UI！
由于搭建前端app并不是本书的主要目的，本书将不会讲解如何从头搭建一个这样的前端，而是展示如何使用MetaMask与智能合约进行交互。
如果你希望自己尝试这个app，在本地运行它，你可以在代码仓库中的 ui文件夹找到对应代码。这就是一个简单的React应用，本地运行只需要在App.js中设置合约地址，然后运行yarn start。
相关工具一览 # 什么是MetaMask？ # MetaMask是一个浏览器插件的以太坊钱包。它能够创建和存储私钥、展示账户余额、允许链接到不同网络、发送和接受以太或其他token——钱包能做的所有事情几乎都可以在其中实现。
除此之外，MetaMask还能够作为signer和provider来运行。作为provider，它链接到一个以太坊节点，并且提供一个接口来使用对应节点的JSON-RPC API。作为一个signer，它提供了一个能够进行安全交易签名的接口，因此能够使用钱包中的私钥来签名任意交易。 （译者注：signer和provider都是js库中的常用名词，因此在这里不作翻译） 常用库 # 事实上，MetaMask也并没有提供那么多的功能：它仅仅是能够管理账户和发送交易。我们需要其他一些库来使得与合约的交互更加容易，并且能更轻松地解析EVM相关的数据。
这样的库有很多，其中最流行的两个是 web3.js 和 ethers.js。选择哪一个取决于你的个人喜好。对本书作者来说，选择 Ethers.js 因为其与合约交互的接口更加清晰
工作流 # 现在，让我们看一下如何使用 MetaMask + Ethers.js 来实现交互。
连接到本地节点 # 为了能够发送交易和获取区块链数据，MetaMask链接到一个以太坊节点。为了与我们的合约交互，我们需要钱包链接到本地的Anvil节点。打开MetaMask，点击网络列表——添加网络，增加一个网络，RPC URL为http://localhost:8545。钱包将会自动检测对应的chain ID（在Anvil中为31331）.
链接到本地节点之后，我们需要导入一个私钥。在MetaMask中，点击地址列表——导入账户，把之前选择的地址对应的私钥粘贴在这里。然后进入资产列表，导入两种token的地址。现在你可以在MetaMask上看到两种token的余额了。
MetaMask实际上有一些bug。一个我经常遇到的bug是，当它连接到本地节点时，它通常会缓存链状态。因此每次重启节点的时候，你有可能会看到旧的余额和状态。解决方法是：打开高级设置，点击“重置账户”。每次重启节点后你可能都需要进行这个步骤。
链接到MetaMask # 并不是每一个网站都能够访问到你在MetaMask中的地址。一个网站首先需要链接到MetaMask。当一个新的网站想要连接MetaMask时，你会看到一个弹窗来请求许可。
前端连接MetaMask的方式如下：
// ui/src/contexts/MetaMask.js const connect = () =&amp;gt; { if (typeof (window.ethereum) === &amp;#39;undefined&amp;#39;) { return setStatus(&amp;#39;not_installed&amp;#39;); } Promise.all([ window.ethereum.request({ method: &amp;#39;eth_requestAccounts&amp;#39; }), window.ethereum.request({ method: &amp;#39;eth_chainId&amp;#39; }), ]).</description>
    </item>
    
  </channel>
</rss>
