<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction on Uniswap V3 Book 中文版</title><link>https://uniswapv3book.com/</link><description>Recent content in Introduction on Uniswap V3 Book 中文版</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://uniswapv3book.com/index.xml" rel="self" type="application/rss+xml"/><item><title>Introduction</title><link>https://uniswapv3book.com/docs/milestone_1/introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_1/introduction/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] First Swap # In this milestone, we&amp;rsquo;ll build a pool contract that can receive liquidity from users and make swaps within a price range.</description></item><item><title>Introduction</title><link>https://uniswapv3book.com/docs/milestone_2/introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/introduction/</guid><description>Second Swap # Alright, this is where it gets real. So far, our implementation has been looking too synthetic and static. We have calculated and hard coded all the amounts to make the learning curve less steep, and now we&amp;rsquo;re ready to make it dynamic. We&amp;rsquo;re going to implement the second swap, that is a swap in the opposite direction: sell ETH to buy USDC. To do this, we&amp;rsquo;re going to improve our smart contracts significantly:</description></item><item><title>Introduction</title><link>https://uniswapv3book.com/docs/milestone_3/introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_3/introduction/</guid><description>You&amp;rsquo;ll find the complete code of this chapter in this Github branch.
This milestone introduces a lot of code changes in existing contracts. Here you can see all changes since the last milestone
Cross-tick Swaps # We have made a great progress so far and our Uniswap V3 implementation is quote close to the original one! However, our implementation only supports swaps within a price range–and this is what we&amp;rsquo;re going to improve in this milestone.</description></item><item><title>Introduction</title><link>https://uniswapv3book.com/docs/milestone_4/introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_4/introduction/</guid><description>Multi-pool Swaps # After implementing cross-tick swaps, we&amp;rsquo;ve got really close to real Uniswap V3 swaps. One significant limitation of our implementation is that it allows only swaps within a pool–if there&amp;rsquo;s no pool for a swap of tokens, then swapping between these tokens is not possible. This is not so in Uniswap since it allows multi-pool swaps. In this chapter, we&amp;rsquo;re going to add multi-pool swaps to our implementation.</description></item><item><title>Introduction</title><link>https://uniswapv3book.com/docs/milestone_5/introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_5/introduction/</guid><description>Fees and Price Oracle # In this milestone, we&amp;rsquo;re going to add two new features to our Uniswap implementation. They share one similarity: they work on top of what we have already built–that&amp;rsquo;s why we&amp;rsquo;ve delayed them until this milestone. However, they&amp;rsquo;re not equally important.
We&amp;rsquo;re going to add swap fees and a price oracle:
Swap fees is a crucial mechanism of the DEX design we&amp;rsquo;re implementing. They&amp;rsquo;re the glue that makes things stick together.</description></item><item><title>Introduction</title><link>https://uniswapv3book.com/docs/milestone_6/introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_6/introduction/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] NFT Positions # This is the cherry on the cake of this book. In this milestone, we&amp;rsquo;re going to learn how Uniswap contract can be extended and integrated into third-party protocols.</description></item><item><title>中英名词对照</title><link>https://uniswapv3book.com/docs/reference/dictionary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/reference/dictionary/</guid><description> 中文 英文简称 全称 去中心化交易所 DEX Decentralized Exchange 中心化交易所 CEX Centralized Exchange 流动性 liquidity liquidity 流动性提供者 LP Liquidity Provider 自动做市商 AMM Automated Market Maker 恒定函数做市商 CFMM Constant Function Market Maker</description></item><item><title>交易市场简介</title><link>https://uniswapv3book.com/docs/introduction/introduction-to-markets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/introduction/introduction-to-markets/</guid><description>交易市场简介 # 中心化交易所(CEX)如何工作 # 在本书中，我们将会搭建一个运行在以太坊(Ethereum)上的去中心化交易所(DEX)。DEX的设计模式非常复杂多样，因此我们先来考虑中心化交易所的设计。中心化交易所(CEX)的核心为订单簿(order book)，存储了用户的所有买单和卖单。订单簿中的每一笔订单都包含了订单成交的价格以及成交数量。
交易能够正常进行的保障是流动性(liquidity)，也即整个市场中所有可获得的资产数目。假设你希望购买一个衣柜但是没有人售卖，即为没有流动性；如果你希望卖出一个衣柜但是没有人愿意购买，即为市场有流动性但是没有买方。没有流动性，就无法在市场中进行买卖。
在CEX中，流动性存放在订单簿中。如果某个用户提交了一个卖单，他就为市场提供了流动性；如果某人提交了一个买单，他们希望市场有流动性，否则交易就无法进行。
如果市场没有流动性，但是仍然希望进行交易，就需要做市商(market maker)。做市商是向市场提供流动性的，拥有大量各种资产的公司或个人。通过提供流动性，做市商能够从交易中获取利润。
去中心化交易所(DEX)如何工作 # 毫无疑问，去中心化的交易也需要流动性，并且也需要做市商向市场提供多种资产的流动性。然而，在DEX中这个过程无法被中心化地处理，我们需要一种去中心化的做市商方案。相关解决方案非常多样化，而本书将主要关注Uniswap提供的方案。
自动做市商(AMM) # 链上交易市场的历史 一文提到了一种称作自动做市商(Automated Market Maker)的思路。正如其名，这种算法能够自动化完成像做市商一样的工作。更进一步，这种算法是去中心化且无需许可的，也即：
没有被任何单个中心化机构控制 所有资产并不存储在同一地方 任何人在任何地点都能使用 什么是自动做市商AMM？ # 一个AMM是一套定义如何管理流动性的智能合约。每个单独的交易对（例如ETH/USDC）都是一个单独的智能合约，存储了ETH和USDC的资产并且撮合交易，在这个合约中我们可以将ETH兑换成USDC或者将USDC兑换成ETH。
在AMM中，一个核心思想为池子(pooling)：每个合约都是一个存储流动性的池子，允许不同的用户（包括其他合约）在其中进行某种方式的交易。在AMM中有两种角色，*流动性提供者(LP)*以及交易者；这两者通过流动性池进行交互，交互的方式由合约进行规定且不可更改。
这种方法与CEX的关键区别在于： 智能合约是完全自动化的并且不受任何人控制。没有经理，没有系统管理员，没有特权用户，一切都没有。这里只有LP和交易者，任何人都可以担任这两种角色（也可以同时），并且所有的算法都是公开的、程序规定的、不可更改的。
在后面的篇章，我们将更进一步了解Uniswap是如何实现AMM的。
注意在后文中，pool和pair两个词可能会被交替使用，因为一个Uniswap的流动性池即一对token</description></item><item><title>Calculating Liquidity</title><link>https://uniswapv3book.com/docs/milestone_1/calculating-liquidity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_1/calculating-liquidity/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Calculating liquidity # Trading is not possible without liquidity, and to make our first swap we need to put some liquidity into the pool contract.</description></item><item><title>Different Price Ranges</title><link>https://uniswapv3book.com/docs/milestone_3/different-ranges/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_3/different-ranges/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Different Price Ranges # The way we implemented it, our Pool contract creates only price ranges that include the current price:</description></item><item><title>ERC721 Overview</title><link>https://uniswapv3book.com/docs/milestone_6/erc721-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_6/erc721-overview/</guid><description>ERC721 Overview # Let&amp;rsquo;s begin with an overview of EIP-721, the standard that defines NFT contracts.
ERC721 is a variant of ERC20. The main difference between them is that ERC721 tokens are non-fungible, that is: one token is not identical to another. To distinguish ERC721 tokens, each of them has a unique ID, which is almost always the counter at which a token was minted. ERC721 tokens also have an extended concept of ownership: owner of each token is tracked and stored in the contract.</description></item><item><title>Factory Contract</title><link>https://uniswapv3book.com/docs/milestone_4/factory-contract/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_4/factory-contract/</guid><description>Factory Contract # Uniswap is designed in a way that assumes many discrete Pool contracts, with each pool handling swaps of one token pair. This looks problematic when we want to swap between two tokens that don&amp;rsquo;t have a pool–is there&amp;rsquo;s no pool, no swaps are possible. However, we can still do intermediate swaps: first swap to a token that has pairs with either of the tokens and then swap this token to the target token.</description></item><item><title>Output Amount Calculation</title><link>https://uniswapv3book.com/docs/milestone_2/output-amount-calculation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/output-amount-calculation/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Output Amount Calculation # Our collection of Uniswap math formulas lacks a final piece: the formula of calculating the output amount when selling ETH (that is: selling token $x$).</description></item><item><title>Swap Fees</title><link>https://uniswapv3book.com/docs/milestone_5/swap-fees/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_5/swap-fees/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Swap Fees # As a mentioned in the introduction, swap fees is a core mechanism of Uniswap. Liquidity providers need to get paid for the liquidity they provide, otherwise they&amp;rsquo;ll just use it somewhere else.</description></item><item><title>恒定函数做市商(CFMM)</title><link>https://uniswapv3book.com/docs/introduction/constant-function-market-maker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/introduction/constant-function-market-maker/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] 恒定函数做市商 (Constant Function Market Makers) # 本章节主要讲述了Uniswap V2白皮书中的内容. 理解其中的数学原理能帮助你更好地构建像Uniswap这样的应用, 不过假设你没有理解本章全部内容也没有关系
正如我们在上一节中提到的那样，AMM的构建有许多不同的方法。我们将主要关注与构建一种特定的AMM：恒定函数做市商（有时也被称为恒定乘积做市商）。尽管名字听起来很复杂，但是它的核心数学原理只是一个非常简单的公式：
$$x * y = k$$</description></item><item><title>Cross-Tick Swaps</title><link>https://uniswapv3book.com/docs/milestone_3/cross-tick-swaps/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_3/cross-tick-swaps/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Cross-Tick Swaps # Cross-tick swaps is probably the most advanced feature of Uniswap V3. Luckily, we have already implemented almost everything we need to make cross-tick swaps.</description></item><item><title>Flash Loan Fees</title><link>https://uniswapv3book.com/docs/milestone_5/flash-loan-fees/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_5/flash-loan-fees/</guid><description>Flash Loan Fees # In a previous chapter we implemented flash loans and made them free. However, Uniswap collect swap fees on flash loans, and we&amp;rsquo;re going to add this to our implementation–the amounts repaid by flash loan borrowers must including the fee.
Here&amp;rsquo;s what the updated flash function looks like:
function flash( uint256 amount0, uint256 amount1, bytes calldata data ) public { uint256 fee0 = Math.</description></item><item><title>Math in Solidity</title><link>https://uniswapv3book.com/docs/milestone_2/math-in-solidity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/math-in-solidity/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Math in Solidity # Due to Solidity not supporting numbers with th fractional part, math in Solidity is somewhat complicated.</description></item><item><title>NFT Manager</title><link>https://uniswapv3book.com/docs/milestone_6/nft-manager/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_6/nft-manager/</guid><description>NFT Manager Contract # Obviously, we&amp;rsquo;re not going to add NFT-related functionality to the pool contract–we need a separate contract that will merge NFT and concentrated liquidity. Recall that, while working on our implementation, we built the UniswapV3Manager contract to facilitate interaction with pool contracts (to make some calculations simpler and to enable multi-pool swaps). This contract was a good demonstration of how core Uniswap contracts can be extended. And we&amp;rsquo;re going to push this idea a little bit further.</description></item><item><title>Providing Liquidity</title><link>https://uniswapv3book.com/docs/milestone_1/providing-liquidity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_1/providing-liquidity/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Providing Liquidity # Enough of theory, let&amp;rsquo;s start coding!
Create a new folder (mine is called uniswapv3-code), and run forge init --vscode in it–this will initialize a Forge project.</description></item><item><title>Swap Path</title><link>https://uniswapv3book.com/docs/milestone_4/path/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_4/path/</guid><description>Swap Path # Let&amp;rsquo;s imagine that we have only these pools: WETH/USDC, USDC/USDT, WBTC/USDT. If we want to swap WETH for WBTC, we&amp;rsquo;ll need to make multiple swaps (WETH→USDC→USDT→WBTC) since there&amp;rsquo;s no WETH/WBTC pool. We can do this manually or we can improve our contracts to handle such chained, or multi-pool, swaps. Of course, we&amp;rsquo;ll do the latter!
When doing multi-pool swaps, we&amp;rsquo;re sending output of a previous swap to the input of the next one.</description></item><item><title>Uniswap V3</title><link>https://uniswapv3book.com/docs/introduction/uniswap-v3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/introduction/uniswap-v3/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Uniswap V3简介 # 本章节主要讲述了Uniswap V3白皮书中的内容。同样，假设你没有理解本章的所有概念也没有关系，我们在后面章节直接看代码可能会更清晰。
为了更好地理解Uniswap V3的创新之处在哪里，我们首先来看Uniswap V2的缺点有哪些。
Uniswap V2使用AMM机制实现了一个通用的交易市场。然而，并不是所有的交易对都是平等的，交易对可以根据价格的波动性分为以下两类
价格波动性为中等或高的代币对。这一类包含绝大多数的代币，因为绝大多数代币并没有锚定(pegged to)到某些东西，因此其价格随着市场波动而波动。 价格波动性低的代币对。这一类包含了有锚定的代币，主要为稳定币：USDT/USDC，USDC/DAI，USDT/DAI等等。也包括ETH/stETH，ETH/rETH（一些wrapped ETH）等类型。 这些类对于我们称作“流动性池配置”的概念有不同的要求。最主要的区别在于，锚定代币对需要非常高的流动性来降低大额交易对其的影响。USDC与USDT的价格必须保持在1附近，无论我要买卖多大数目的代币。由于Uniswap V2的通用AMM算法对于稳定币交易并没有很好的适配，其他的AMM（主要是Curve）则在稳定币交易中更加流行。</description></item><item><title>First Swap</title><link>https://uniswapv3book.com/docs/milestone_1/first-swap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_1/first-swap/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] First Swap # Now that we have liquidity, we can make our first swap!
Calculating Swap Amounts # First step, of course, is to figure out how to calculate swap amounts.</description></item><item><title>Multi-pool Swaps</title><link>https://uniswapv3book.com/docs/milestone_4/multi-pool-swaps/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_4/multi-pool-swaps/</guid><description>Multi-pool Swaps # We&amp;rsquo;re now proceeding to the core of this milestone–implementing multi-pool swaps in our contracts. We won&amp;rsquo;t touch Pool contract in this milestone because it&amp;rsquo;s a core contract that should implement only core features. Multi-pool swaps is a utility feature, and we&amp;rsquo;ll implement it in Manager and Quoter contracts.
Updating Manager Contract # Single-pool and Multi-pool Swaps # In our current implementation, swap function in Manager contract supports only single-pool swaps and takes pool address in parameters:</description></item><item><title>NFT Renderer</title><link>https://uniswapv3book.com/docs/milestone_6/nft-renderer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_6/nft-renderer/</guid><description>NFT Renderer # Now we need to build an NFT renderer: a library that will handle calls to tokenURI in the NFT manager contract. It will render JSON metadata and SVG for each minted token. As we discussed earlier, we&amp;rsquo;ll use the data URI syntax, which requires base64 encoding–this means we&amp;rsquo;ll need a base64 encoder in Solidity. But first, let&amp;rsquo;s look at how our tokens will look like.
SVG Template # I built this simplified variation of the Uniswap V3 NFTs:</description></item><item><title>Protocol Fees</title><link>https://uniswapv3book.com/docs/milestone_5/protocol-fees/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_5/protocol-fees/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Protocol Fees # While working on the Uniswap implementation, you&amp;rsquo;ve probably asked yourself, &amp;ldquo;How does Uniswap make money?</description></item><item><title>Slippage Protection</title><link>https://uniswapv3book.com/docs/milestone_3/slippage-protection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_3/slippage-protection/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Slippage Protection # Slippage is a very important issued in decentralized exchanges. Slippage simply means the difference between the price that you see on the screen when initialing a transaction and the actual price the swap is executed at.</description></item><item><title>Tick Bitmap Index</title><link>https://uniswapv3book.com/docs/milestone_2/tick-bitmap-index/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/tick-bitmap-index/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Tick Bitmap Index # As the first step towards dynamic swaps, we need to implement an index of ticks.</description></item><item><title>开发环境</title><link>https://uniswapv3book.com/docs/introduction/dev-environment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/introduction/dev-environment/</guid><description>开发环境 # 本书中，我们会搭建两个应用：
链上：一套部署在以太坊上的智能合约 链下：一个与智能合约交互的前端应用 尽管本书把前端应用作为其中一部分，但不是我们的主要关注点。我们搭建前端仅仅为了展示智能合约是如何集成到前端应用中的。因为，前端部分是可选读内容，但在本书代码仓库中也提供者这部分的代码
以太坊简介 # 以太坊是一个允许任何人在上面运行应用的区块链。它与一个传统云服务的主要区别在于：
维持这个应用不需要付费，部署应用需要付费 应用代码是不可变的，在其部署后你没有办法再进行修改 用户调用你的应用需要花费gas（手续费） 为了更好地理解这些区别，我们来看一下以太坊的构建。
以太坊的核心（其他区块链也是同理）是一个数据库。这个数据库中最有价值的数据是账户状态。以太坊中的每个账户包含一个地址，以及以下数据：
余额：账户的以太坊(ether)余额 代码：部署在这个地址上的智能合约的字节码 存储：智能合约存储数据的空间 nonce：一个用来防止重放攻击的整数序号 （译者注：Ethereum和ether的中文译名均为以太坊，读者注意区分。Ethereum指的是这条区块链，ether指的是该链上的原生代币）
以太坊的主要任务是安全地维护这些数据，防止未经授权的更改。
同时，以太坊也是一个网络，网络中的每个计算机都独立地构建和维持这些状态。网络的主要目标是能够去中心化地访问数据库：没有任何单个权威机构可以单方面修改任何数据。这是通过叫做*共识(consensus)*的机制来实现的，即网络中节点遵守的一系列规则。如果有节点违反了规则，它将会被从这个网络中排除。
有趣的是，区块链也可以使用MSQL！只是可能会存在一定的性能问题。以太坊中使用的是LevelDB，一个高效的KV数据库。
每个以太坊节点运行EVM，以太坊虚拟机。虚拟机是一个能够执行其他程序的程序，EVM则是执行智能合约程序的程序。用户通过交易(transactions)与合约交互，除了能够简单的发送ether，交易也能够调用智能合约，需要传输的数据包括：
一个合约函数的签名 函数参数 交易被打包进区块，区块被矿工挖出。网络中的每个节点都可以验证每一个区块中的每一笔交易。
某种意义上来说，智能合约与JSON APIs有一定类似，区别就是你调用的是智能合约函数。与API的后端类似，智能合约也执行程序逻辑，并且也可能更改智能合约中存储的数据。与API不同的是，你需要发送一笔交易来改变区块链的状态，并且你需要为每一笔交易付费。
最后，以太坊节点也实现了一套JSON-RPC API。我们可以通过这个API与节点进行交互：获取账户余额、估算gas费、获取区块和交易、发送交易、执行不上链的智能合约调用（仅能读数据）。在这里你可以获得一个可用端点的列表。
交易也是通过这个API发送的, 参见 eth_sendTransaction.
本地开发环境 # 我们将要搭建智能合约并且在以太坊上运行它们，这意味着我们需要一个节点。在本地测试和运行合约也需要一个节点。曾经这使得智能合约开发十分麻烦，因为在一个真实节点上运行大量的测试会十分缓慢。不过现在已经有了很多快速简洁的解决方案。例如Truffle 和 Hardhat。不过这些工具的问题在于我们需要用JavaScript来写测试以及与区块链的交互，这事因为Truffle和Hardhat都运行了一个本地节点，并且使用JavaScript的Web3库来与节点交互。
我们将会选择一个新的框架，Foundry。
Foundry # Foundry是一套用于以太坊应用开发的工具包。我们将会使用以下这些工具：
Forge，一个Solidity的测试框架. Anvil，一个本地以太坊节点。我们将会用它来部署我们的合约，并且与前端app交互。 Cast, 一个非常好用的CLI工具。 Forge使智能合约开发更加容易。当使用Forge开发时，我们不需要运行一个本地节点来进行测试；Forge会在其内置的EVM上运行测试，大大加快了速度，不再需要给节点发送交易和挖出区块。除此以外，Forge还能够使用Solidity编写测试！Forge也内置了机制方便我们模拟区块链的各种状态：修改某个账户余额，从其他地址执行合约，把合约部署在任意地址等等。
然而，我们仍然需要一个本地节点来部署合约。在这里我们将会使用Anvil。前端应用可以使用JavaScript的Web3库来与以太坊节点进行交互。
Ethers.js # Ethers.js 是一个与Ethereum交互的JavaScript库.</description></item><item><title>Generalize Minting</title><link>https://uniswapv3book.com/docs/milestone_2/generalize-minting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/generalize-minting/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Generalize Minting # Now, we&amp;rsquo;re ready to update mint function so it calculates the amounts of tokens instead of hard coding them.</description></item><item><title>Liquidity Calculation</title><link>https://uniswapv3book.com/docs/milestone_3/liquidity-calculation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_3/liquidity-calculation/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Liquidity Calculation # Of the whole math of Uniswap V3, what we haven&amp;rsquo;t yet implemented in Solidity is liquidity calculation.</description></item><item><title>Manager Contract</title><link>https://uniswapv3book.com/docs/milestone_1/manager-contract/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_1/manager-contract/</guid><description>Manager Contract # Before deploying our pool contract, we need to solve one problem. As you remember, Uniswap V3 contracts are split into two categories:
Core contracts that implement the core functions and don&amp;rsquo;t provide user-friendly interfaces. Periphery contracts that implement user-friendly interfaces for the core contracts. The pool contract is a core contract, it&amp;rsquo;s not supposed to be user-friendly and flexible. It expects the caller to do all the calculations (prices, amounts) and to provide proper call parameters.</description></item><item><title>Price Oracle</title><link>https://uniswapv3book.com/docs/milestone_5/price-oracle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_5/price-oracle/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Price Oracle # The final mechanism we&amp;rsquo;re going to add to our DEX is a price oracle. Even though it&amp;rsquo;s not essential to a DEX (there are DEXes that don&amp;rsquo;t implement a price oracle), it&amp;rsquo;s still an important feature of Uniswap and something that&amp;rsquo;s interesting to learn about.</description></item><item><title>User Interface</title><link>https://uniswapv3book.com/docs/milestone_4/user-interface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_4/user-interface/</guid><description>User Interface # After introducing swap paths, we can significantly simplify the internal of our web app. First of all, every swap now uses a path since path doesn&amp;rsquo;t have to contain multiple pools. Second, it&amp;rsquo;s now easier to change the direction of swap: we can simply reverse the path. And, thanks to the unified pool address generation via CREATE2 and unique salts, we no longer need to store pool addresses and care about tokens order.</description></item><item><title>A Little Bit More on Fixed-point Numbers</title><link>https://uniswapv3book.com/docs/milestone_3/more-on-fixed-point-numbers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_3/more-on-fixed-point-numbers/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] A Little Bit More on Fixed-point Numbers # In this bonus chapter, I&amp;rsquo;d like to show you how to convert prices to ticks in Solidity.</description></item><item><title>Deployment</title><link>https://uniswapv3book.com/docs/milestone_1/deployment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_1/deployment/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Deployment # Alright, our pool contract is done. Now, let&amp;rsquo;s see how we can deploy it to a local Ethereum network so we could use it from a front-end app later on.</description></item><item><title>Generalize Swapping</title><link>https://uniswapv3book.com/docs/milestone_2/generalize-swapping/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/generalize-swapping/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Generalize Swapping # This will be the hardest chapter of this milestone. Before updating the code, we need to understand how the algorithm of swapping in Uniswap V3 works.</description></item><item><title>Tick Rounding</title><link>https://uniswapv3book.com/docs/milestone_4/tick-rounding/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_4/tick-rounding/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Tick Rounding # Let&amp;rsquo;s review some other changes we need to make to support different tick spacings.</description></item><item><title>User Interface</title><link>https://uniswapv3book.com/docs/milestone_5/user-interface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_5/user-interface/</guid><description>User Interface # In this milestone, we&amp;rsquo;ve added the ability to remove liquidity from a pool and collect accumulated fees. Thus, we need to reflect these changes in the user interface to allow users to remove liquidity.
Fetching Positions # To let user choose how much liquidity to remove, we first need to fetch user&amp;rsquo;s positions from a pool. To makes this easier, we can add a helper function to the Manager contract, which will return user position in a specific pool:</description></item><item><title>Flash Loans</title><link>https://uniswapv3book.com/docs/milestone_3/flash-loans/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_3/flash-loans/</guid><description>Flash Loans # Both Uniswap V2 and V3 implement flash loans: an unlimited and uncollateralized loan that must be repaid in the same transaction. Pools are basically giving caller an arbitrary amount of tokens that caller requests, but, by the end of the call, caller must return the full amount plus fee.
The fact that flash loans must be repaid in the same transaction means that flash loans cannot be taken by regular users: as a user, you cannot program custom logic in transactions.</description></item><item><title>Quoter Contract</title><link>https://uniswapv3book.com/docs/milestone_2/quoter-contract/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/quoter-contract/</guid><description>Quoter Contract # To integrate our updated Pool contract into the front end app, we need a way to calculate swap amounts without making a swap. Users will type in the amount they want to sell, and we want to calculate and show them the amount they&amp;rsquo;ll get in exchange. We&amp;rsquo;ll do this through Quoter contract.
Since liquidity in Uniswap V3 is scattered over multiple price ranges, we cannot calculate swap amounts with a formula (which was possible in Uniswap V2).</description></item><item><title>User Interface</title><link>https://uniswapv3book.com/docs/milestone_1/user-interface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_1/user-interface/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] User Interface # Finally, we made it to the final stop of this milestone–building a user interface!</description></item><item><title>User Interface</title><link>https://uniswapv3book.com/docs/milestone_2/user-interface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/user-interface/</guid><description>User Interface # Let&amp;rsquo;s make our web app work more like a real DEX. We can now remove hardcoded swap amounts and let users type arbitrary amounts. Moreover, we can now let users swap in the both direction, so we also need a button to swap the token inputs. After updating, the swap form will look like:
&amp;lt;form className=&amp;#34;SwapForm&amp;#34;&amp;gt; &amp;lt;SwapInput amount={zeroForOne ? amount0 : amount1} disabled={!enabled || loading} readOnly={false} setAmount={setAmount_(zeroForOne ?</description></item><item><title>User Interface</title><link>https://uniswapv3book.com/docs/milestone_3/user-interface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_3/user-interface/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] User Interface # We&amp;rsquo;re now ready to update the UI with the changes we made in this milestone.</description></item></channel></rss>